[{"content":"å’•å’•å’•\n","date":"2022-04-16T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-08/","title":"åšé¢˜ç¬”è®°08ï¼šå‰‘æŒ‡Offer"},{"content":"BM83 å­—ç¬¦ä¸²å˜å½¢ æ„Ÿæ© Pythonï¼\nclass Solution: def trans(self , s: str, n: int) -\u0026gt; str: return \u0026#39; \u0026#39;.join(s.swapcase().split(\u0026#39; \u0026#39;)[::-1]) BM84 æœ€é•¿å…¬å…±å‰ç¼€ class Solution: def longestCommonPrefix(self , strs: List[str]) -\u0026gt; str: res = \u0026#34;\u0026#34; for e in zip(*strs): if len(set(e)) == 1: res += e[0] else: break return res BM85 éªŒè¯IPåœ°å€ å¥½æ— èŠçš„é¢˜ç›®ï¼Œæ˜æ˜æœ‰å†…ç½®å‡½æ•°ä¸ç»™ç”¨â€¦â€¦ç›´æ¥æŠ„é¢˜è§£äº†ï¼š\nclass Solution: def validate_IPv4(self, IP: str) -\u0026gt; str: nums = IP.split(\u0026#39;.\u0026#39;) for x in nums: # Validate integer in range (0, 255): # 1. length of chunk is between 1 and 3 if len(x) == 0 or len(x) \u0026gt; 3: return \u0026#34;Neither\u0026#34; # 2. no extra leading zeros # 3. only digits are allowed # 4. less than 255 if x[0] == \u0026#39;0\u0026#39; and len(x) != 1 or not x.isdigit() or int(x) \u0026gt; 255: return \u0026#34;Neither\u0026#34; return \u0026#34;IPv4\u0026#34; def validate_IPv6(self, IP: str) -\u0026gt; str: nums = IP.split(\u0026#39;:\u0026#39;) hexdigits = \u0026#39;0123456789abcdefABCDEF\u0026#39; for x in nums: # Validate hexadecimal in range (0, 2**16): # 1. at least one and not more than 4 hexdigits in one chunk # 2. only hexdigits are allowed: 0-9, a-f, A-F if len(x) == 0 or len(x) \u0026gt; 4 or not all(c in hexdigits for c in x): return \u0026#34;Neither\u0026#34; return \u0026#34;IPv6\u0026#34; def solve(self , IP: str) -\u0026gt; str: if IP.count(\u0026#39;.\u0026#39;) == 3: return self.validate_IPv4(IP) elif IP.count(\u0026#39;:\u0026#39;) == 7: return self.validate_IPv6(IP) else: return \u0026#34;Neither\u0026#34; BM86 å¤§æ•°åŠ æ³• çœŸçš„å¥½æ— èŠï¼Œæ˜æ˜ä¹‹å‰åœ¨é“¾è¡¨åšè¿‡äº†â€¦â€¦\nclass Solution: def solve(self , s: str, t: str) -\u0026gt; str: return str(int(s)+int(t)) BM87 åˆå¹¶ä¸¤ä¸ªæœ‰åºçš„æ•°ç»„ åˆå¹¶æ’åºï¼Œç†Ÿæ‚‰çš„åŒæŒ‡é’ˆï¼š\nclass Solution: def merge(self , A, m, B, n): head = m + n - 1 while m \u0026gt; 0 and n \u0026gt; 0: if A[m - 1] \u0026gt; B[n - 1]: A[head] = A[m - 1] head, m = head - 1, m - 1 else: A[head] = B[n - 1] head, n = head - 1, n - 1 if n \u0026gt; 0: while head \u0026gt;= 0: A[head] = B[head] head = head - 1 çœ‹äº†é¢˜è§£æ‰çŸ¥é“å¯ä»¥é€ƒè¯¾ï¼Œæ–°æŠ€èƒ½ getï¼\nclass Solution: def merge(self , A, m, B, n): A[m: m + n] = B return A.sort() BM88 åˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡å­—ç¬¦ä¸² é€ƒè¯¾ä¸‡å²ï¼\nclass Solution: def judge(self , s: str) -\u0026gt; bool: return s == s[::-1] åŒæŒ‡é’ˆåè€Œæ˜¯æœ€æ…¢çš„ğŸ˜‚\nclass Solution: def judge(self , s: str) -\u0026gt; bool: return all(s[i] == s[-1-i] for i in range(len(s) // 2)) BM89 åˆå¹¶åŒºé—´ å…ˆæŒ‰å¼€å¤´æ•°å­—æ’åºå†åˆå¹¶ï¼š\nclass Solution: def merge(self , intervals: List[Interval]) -\u0026gt; List[Interval]: intervals.sort(key = lambda x: x.start) result = [] for i in intervals: if not result or i.start \u0026gt; result[-1].end: result.append(i) else: result[-1].end = max(result[-1].end, i.end) return result BM90 æœ€å°è¦†ç›–å­ä¸² çœ‹æ¸…æ¥šé¢˜ç›®å¾ˆé‡è¦ğŸ˜‚\nè¿™é‡Œçš„è¦†ç›–ï¼ŒæŒ‡çš„æ˜¯åŒ…å« T ä¸­æ‰€æœ‰å­—æ¯ï¼Œå¹¶ä¸”å­—æ¯çš„æ•°é‡ä¹Ÿè¦è¦†ç›–ã€‚æ¯”å¦‚ T ä¸­æœ‰ 3 ä¸ª \u0026quot;a\u0026quot;ï¼Œè¦†ç›–çš„å­ä¸²ä¹Ÿè¦è‡³å°‘å«æœ‰ 3 ä¸ª \u0026quot;a\u0026quot;ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ\u0026quot;a\u0026quot; ä¸èƒ½è¦†ç›– \u0026quot;aa\u0026quot;ã€‚\nç©·ä¸¾å¤§æ¦‚æ˜¯æœ€å®¹æ˜“æƒ³åˆ°çš„åŠæ³•äº†ã€‚é¦–å…ˆå‡†å¤‡ä¸€ä¸ª end æŒ‡é’ˆéå† Sï¼Œå¦‚æœ S å‰ end ä¸ªå­—æ¯èƒ½è¦†ç›– Tï¼Œå°±ç”¨å¦ä¸€ä¸ªæŒ‡é’ˆ start ä»æœ€å·¦è¾¹å¼€å§‹æ±‚æœ€å°è¦†ç›–ï¼š\nclass Solution: def minWindow(self , S: str, T: str) -\u0026gt; str: def cover(S, T): return all(t in S and S.count(t) \u0026gt;= T.count(t) for t in set(T)) result = \u0026#34;\u0026#34; for end in range(len(S)): if cover(S[0: end + 1], T): start = 1 while cover(S[start: end + 1], T): start += 1 if not result or len(result) \u0026gt; (end + 1 - start + 1): result = S[start - 1: end + 1] return result ç„¶åå°±è¶…æ—¶å•¦ğŸ˜‚\næœ‰ä»€ä¹ˆåŠæ³•å¯ä»¥æ”¹è¿›ä¸€ä¸‹å‘¢ï¼Ÿä¸éš¾çœ‹åˆ°æœ€å¤§çš„é—®é¢˜æ˜¯ start æ€»æ˜¯ä» 0 å¼€å§‹ï¼Œä¸èƒ½ä½¿ç”¨å‰ä¸€æ¬¡çš„ç»“æœã€‚æ³¨æ„åˆ°ï¼š\n å‘½é¢˜ å¦‚æœå­˜åœ¨æ¯”å½“å‰æ›´å°çš„è¦†ç›–å­ä¸²ï¼Œåˆ™è¯¥å­ä¸²çš„ start ä¸€å®šè‡³å°‘æ˜¯å½“å‰çš„ start + 1ã€‚\nè¯æ˜ é¦–å…ˆæ˜¾ç„¶ S[start:end + 1] æ˜¯ S[:end + 1] çš„æœ€å°è¦†ç›–å­ä¸²ï¼Œå› ä¸ºç›´åˆ°ç¬¬ end ä½æ‰å‡‘é½æ‰€æœ‰å­—æ¯ï¼Œç»“æŸä½ä¸å¯èƒ½å°äº endï¼›åˆç”±äº start åœ¨å‡å°‘åˆ° S[start:end + 1] ä¸ä¸ºæœ€å°è¦†ç›–å­ä¸²ååœæ­¢ï¼Œå¼€å§‹ä½ä¹Ÿä¸å¯èƒ½å¤§äº startï¼Œå¾—è¯ã€‚\nå› æ­¤ï¼Œå¦‚æœå­˜åœ¨æ›´å°çš„è¦†ç›–å­ä¸²ï¼Œå­ä¸²çš„ end ä¸€å®šå¤§äºå½“å‰çš„ endï¼Œä»è€Œ start ä¹Ÿå¿…ç„¶ä¼šå¤§äºå½“å‰çš„ startã€‚\n è¿™å°±æ˜¯é¢˜è§£ä½¿ç”¨çš„ æ»‘åŠ¨çª—å£æ³• äº†ï¼Œä¸è¿‡ä¾ç„¶æ˜¯è¶…æ—¶ğŸ˜‚\nclass Solution: def minWindow(self , S: str, T: str) -\u0026gt; str: def cover(S, T): return all(t in S and S.count(t) \u0026gt;= T.count(t) for t in set(T)) result = \u0026#34;\u0026#34; for end in range(len(S)): start = 0 if cover(S[start: end + 1], T): while cover(S[start: end + 1], T): start += 1 if not result or len(result) \u0026gt; (end + 1 - start + 1): result = S[start - 1: end + 1] return result ä¸éš¾çœ‹åˆ°ç›®å‰çš„æ€§èƒ½ç“¶é¢ˆå°±æ˜¯ cover å‡½æ•°äº†ï¼Œæœ‰ä»€ä¹ˆåŠæ³•å¯ä»¥æŠŠ cover çš„æ—¶é—´å¤æ‚åº¦é™åˆ° O(1) å‘¢ï¼Ÿè‡ªç„¶æ˜¯ä»¥ç©ºé—´æ¢æ—¶é—´äº†ï¼š\n ä½¿ç”¨ä¸€ä¸ªå­—å…¸ d å­˜æ”¾ T ä¸­æ‰€æœ‰å­—æ¯å’Œå‡ºç°çš„æ¬¡æ•°ï¼Œä½¿ç”¨ä¸€ä¸ªå˜é‡ missing å­˜æ”¾è¿˜ç¼ºå°‘çš„å­—æ¯æ•°é‡ï¼Œæ˜¾ç„¶æ£€æŸ¥ cover å˜æˆäº†æ£€æŸ¥ missing æ˜¯å¦ç­‰äº 0ã€‚ ä»å·¦å¾€å³æ‰«æ Sï¼Œå¦‚æœé‡åˆ° d ä¸­å­˜åœ¨çš„å­—æ¯ï¼Œä¸” d[s] \u0026gt; 0ï¼Œåˆ™ d[s] å’Œ missing åŒæ—¶å‡ 1ï¼› å¦‚æœ d[s] \u0026lt;= 0 åˆ™ missing ä¿æŒä¸å˜ï¼Œd[s] å‡ 1ï¼› æ¥ä¸‹æ¥æ£€æŸ¥ missingï¼Œå¦‚æœ missing ç­‰äº 0ï¼Œè¯´æ˜å½“å‰çª—å£ S[start: end + 1] æ˜¯è¦†ç›–äº†æ‰€æœ‰å­—æ¯çš„å­ä¸²ï¼Œå°è¯• start è‡ªå¢ä»¥ç¼©å°çª—å£ï¼› åœ¨ start åŠ ä¸€ä¹‹å‰ï¼Œéœ€è¦åŒæ—¶æŠŠ d[S[start]] åŠ ä¸€ã€‚å¦‚æœ d[S[start]] å¤§äºç­‰äº 0ï¼Œè¿˜è¦åŒæ—¶æŠŠ missing åŠ ä¸€ï¼› å½“ start è‡ªå¢åˆ° S[start: end + 1] ä¸æ˜¯è¦†ç›–å­ä¸²æ—¶ï¼Œè®°å½•ä¸‹ S[start - 1: end + 1] ä½œä¸ºç»“æœã€‚  class Solution: def minWindow(self , S: str, T: str) -\u0026gt; str: from collections import Counter missing, d, result, start = len(T), Counter(T), \u0026#34;\u0026#34;, 0 for end in range(len(S)): if S[end] in d: # è®°å½•å½“å‰å­—æ¯ missing -= (d[S[end]] \u0026gt; 0) d[S[end]] -= 1 if missing == 0: # ç›®å‰çª—å£åŒ…å«äº†æ‰€æœ‰å­—æ¯ï¼Œå·¦æŒ‡é’ˆå¾€å³ç§» while missing == 0: if S[start] in d: missing += (d[S[start]] \u0026gt;= 0) d[S[start]] += 1 start += 1 if not result or len(result) \u0026gt; (end + 1 - start + 1): result = S[start - 1: end + 1] # è®°å½•ç»“æœ return result è™½ç„¶æ˜¯é€šè¿‡äº†ï¼Œä½†è¿™ä¸ªæ–¹æ³•ä¸€å®šå¯ä»¥æ‰¾åˆ°æœ€å°è¦†ç›–å­ä¸²å—ï¼Ÿè¿™å°±éœ€è¦è¯æ˜ start èƒ½åˆ°è¾¾æœ€å°è¦†ç›–å­ä¸²çš„å¼€å¤´å­—æ¯ï¼Œä¸”åœ¨æ­¤ä¹‹å‰ end æ²¡æœ‰è¾¾åˆ°æœ€å°è¦†ç›–å­ä¸²çš„ç»“æŸå­—æ¯ä¹‹åã€‚åè€…æ˜¯æ˜¾ç„¶çš„ï¼Œå› ä¸ºæœ€å°è¦†ç›–å­ä¸²å·²ç»æ¶µç›–äº†æ‰€æœ‰å­—æ¯ï¼Œç”±éå†çš„è¿‡ç¨‹ï¼Œä¸å¯èƒ½åœ¨ start åˆ°è¾¾å¼€å¤´ä¹‹å‰ end å·²ç»è·³è¿‡äº†ç»“å°¾ã€‚è‡³äºå‰è€…ï¼Œæƒ³äº†åŠå°æ—¶æ‰æƒ³æ˜ç™½ğŸ˜‚\nå› ä¸º start æ˜¯ä¸€ä¸ªä¸€ä¸ªå…ƒç´ éå†çš„ï¼Œåªéœ€è¦è¯æ˜ start å¿…ç„¶ä¼šåœåœ¨æœ€å°å­ä¸²çš„å¼€å¤´å³å¯ã€‚å¦‚æœåœ¨ start è¿˜æ²¡åˆ°è¾¾å¼€å¤´ä¹‹å‰ï¼Œend å·²ç»åˆ°è¾¾ç»“å°¾ï¼Œåˆ™å·²ç»ç¬¦åˆè¦æ±‚ï¼›å¦‚æœ end æ²¡æœ‰åˆ°è¾¾ç»“å°¾ï¼Œæ¯”å¦‚åˆšå¥½æ˜¯å€’æ•°ç¬¬ 2 ä¸ªå…ƒç´ ï¼Œåˆ™ start å¤„çš„å€¼ä¸€å®šå’Œæœ€å°å­ä¸²æœ€åä¸€ä¸ªå…ƒç´ çš„å€¼ç›¸ç­‰ï¼Œæ˜¾ç„¶ä¸‹ä¸€æ¬¡ç§»åŠ¨å°±èƒ½è¾¾åˆ°è¦æ±‚ï¼›åŒç†ï¼Œå€’æ•°ç¬¬ n ä¸ªå…ƒç´ æœ€å¤šåªéœ€è¦å†ç§»åŠ¨ n-1 æ¬¡ï¼Œä¸€å®šä¼šç§»åŠ¨åˆ°æœ€å°å­ä¸²çš„å¼€å¤´ã€‚\nBM91 åè½¬å­—ç¬¦ä¸² å› ä¸º Python çš„å­—ç¬¦ä¸²ä¸å¯å˜ï¼Œç”¨ä¸äº†åŒæŒ‡é’ˆï¼Œå¯ä»¥ç†ç›´æ°”å£®é€ƒè¯¾ğŸ˜‚\nclass Solution: def solve(self , s: str) -\u0026gt; str: return s[::-1] BM92 æœ€é•¿æ— é‡å¤å­æ•°ç»„ å’Œ BM90 å¾ˆåƒï¼Œä¹Ÿæ˜¯æ»‘åŠ¨çª—å£ã€‚å¦‚æœ arr[start:end] æ²¡æœ‰é‡å¤è€Œ arr[start: end + 1] å‡ºç°äº†é‡å¤ï¼Œä¹Ÿå°±æ˜¯è¯´ arr[end] å‡ºç°åœ¨ arr[start:end] çš„æŸä¸ªä½ç½® posï¼Œæ˜¾ç„¶ä¸‹ä¸€ä¸ªå¯èƒ½çš„æœ€é•¿æ— é‡å¤å­æ•°ç»„çš„ start ä¸€å®šæ˜¯ä» pos + 1 å¼€å§‹ã€‚\nclass Solution: def maxLength(self , arr: List[int]) -\u0026gt; int: d, start, result = {}, 0, 0 for end in range(len(arr)): if arr[end] in d: # å‡ºç°é‡å¤ï¼Œåˆ°è¾¾ä¸‹ä¸€ä¸ªå­ä¸² while arr[start] != arr[end]: d.pop(arr[start]) start += 1 start += 1 else: # æ²¡æœ‰é‡å¤ d[arr[end]] = 1 result = max(result, end - start + 1) return result BM93 ç››æ°´æœ€å¤šçš„å®¹å™¨ ç¬¨åŠæ³•è‡ªç„¶æ˜¯ç©·ä¸¾æ‰€æœ‰å¯èƒ½ï¼Œç„¶åå¾ˆå¿«æ„è¯†åˆ°å¹¶ä¸éœ€è¦ï¼Œå¦‚æœ height[start] \u0026lt; height[end]ï¼Œend å†æ€ä¹ˆå˜åŒ–ï¼Œç››æ°´çš„é‡ä¹Ÿä¸ä¼šå˜å¤šï¼Œäºæ˜¯åªéœ€è¦æŠŠè¾ƒå°çš„ä¸€è¾¹å‰å¾€ä¸‹ä¸€ä¸ªå¯èƒ½çš„å€¼å³å¯ï¼š\nclass Solution: def maxArea(self , height: List[int]) -\u0026gt; int: start, end, result = 0, len(height) - 1, 0 while start \u0026lt; end: result = max(result, min(height[start], height[end]) * (end - start)) if height[start] \u0026lt; height[end]: start += 1 else: end -= 1 return result BM94 æ¥é›¨æ°´é—®é¢˜ æ–¹æ³•ä¸€ï¼šæ­£åéå† è¿™é¢˜å¦‚æœç›´æ¥åšå¯èƒ½æ— ä»ä¸‹æ‰‹ï¼Œå¥½åœ¨åšè¿‡ BM93 ä¹‹åï¼Œå¤šå¤šå°‘å°‘ä¼šæœ‰å¤´ç»ªï¼šå¦‚æœä¸€ä¸ªä½ç½® i è¦å‚¨æ°´ï¼Œä¸€å®šè¦æ¯”æ°´æ¡¶çš„ä¸¤è¾¹éƒ½è¦ä½ã€‚æ€ä¹ˆæ‰¾åˆ°æ°´æ¡¶çš„ä¸¤è¾¹å‘¢ï¼Ÿ\nå†ä»”ç»†æƒ³æƒ³å°±ä¼šæ˜ç™½ï¼Œæ°´æ¡¶çš„å·¦è¾¹æ˜¯ i å·¦è¾¹çš„æœ€å¤§å€¼ï¼Œæ°´æ¡¶çš„å³è¾¹æ˜¯ i å³è¾¹çš„æœ€å¤§å€¼ï¼Œäºæ˜¯å¯ä»¥ä½¿ç”¨ä¸€ä¸ªä¸¤é‡å¾ªç¯æ¥è§£å†³ã€‚ç„¶åå¾ˆå¿«å°±ä¼šå‘ç°ï¼Œi å·¦è¾¹çš„æœ€å¤§å€¼å’Œ i å³è¾¹çš„æœ€å¤§å€¼éƒ½å¯ä»¥é€šè¿‡ä¸€æ¬¡éå†å¾—åˆ°ï¼Œäºæ˜¯æ—¶é—´å¤æ‚åº¦å°±é™åˆ°äº† O(n)ï¼š\nclass Solution: def maxWater(self , arr: List[int]) -\u0026gt; int: left_max, right_max = [0] * len(arr), [0] * len(arr) for i in range(len(arr) - 1): left_max[i + 1] = max(left_max[i], arr[i]) right_max[- i - 2] = max(right_max[- i - 1], arr[- i - 1]) result = 0 for i in range(len(arr)): # å…¶å®ç¬¬ä¸€ä½å’Œæœ€åä¸€ä½éƒ½æ¥ä¸äº†é›¨æ°´ if arr[i] \u0026lt; min(left_max[i], right_max[i]): # æ¥é›¨æ°´ result += min(left_max[i], right_max[i]) - arr[i] return result æ–¹æ³•äºŒï¼šåŒæŒ‡é’ˆ å’Œ BM93 çš„åŒæŒ‡é’ˆæ³•å¾ˆç›¸ä¼¼ï¼Œé¦–å…ˆæŠŠ start, end æŒ‡å‘æ•°ç»„çš„ä¸¤ç«¯ï¼Œå¹¶å‡†å¤‡ left_max, right_max ä¸¤ä¸ªæ•°ç»„ï¼ˆå…¶å®åªéœ€è¦ä¸¤ä¸ªæ•°ï¼‰ï¼š\n å¦‚æœ left_max[start] \u0026lt; right_max[end]ï¼Œå› ä¸º right_max[end] \u0026lt;= right_max[start]ï¼Œæ˜¾ç„¶æ­¤æ—¶å¯¹ start è€Œè¨€ï¼Œå·¦è¾¹æ˜¯æœ€å°çš„ä¸€è¾¹ï¼Œè®¡ç®—å‡ºé›¨æ°´é‡çš„å¤§å°ï¼Œç„¶å start å¾€å³ç§»ï¼› å¦‚æœ left_max[start] \u0026gt;= right_max[end]ï¼Œå› ä¸º left_max[end] \u0026gt;= left_max[start]ï¼Œæ˜¾ç„¶æ­¤æ—¶å¯¹ end è€Œè¨€ï¼Œå³è¾¹æ˜¯æœ€å°çš„ä¸€è¾¹ï¼Œè®¡ç®—å‡ºé›¨æ°´é‡çš„å¤§å°ï¼Œç„¶å end å¾€å·¦ç§»ï¼› å½“ start \u0026gt; end æ—¶ç»ˆæ­¢å¾ªç¯ï¼Œè¿”å›ç»“æœã€‚  ç®—æ³•çš„æ­£ç¡®æ€§æ—¶æ˜¾ç„¶çš„ï¼Œå› ä¸ºæ¯æ¬¡å¾ªç¯æ°å¥½ç®—å‡ºä¸€ä¸ªä½ç½®çš„é›¨æ°´é‡ã€‚\nclass Solution: def maxWater(self , arr: List[int]) -\u0026gt; int: start, end, left_max, right_max, result = 0, len(arr) - 1, 0, 0, 0 while start \u0026lt;= end: left_max = max(left_max, arr[start]) right_max = max(right_max, arr[end]) if left_max \u0026lt; right_max: result += left_max - arr[start] start += 1 else: result += right_max - arr[end] end -= 1 return result æ–¹æ³•ä¸‰ï¼šå•è°ƒæ ˆ è¿™ä¸ªç®—æ³•ä»¿ä½›æ˜¯ä¸ºè¿™é“é¢˜ç›®é‡èº«å®šåˆ¶çš„ï¼Œä½†æ˜¯å‹æ ¹æƒ³ä¸å‡ºæ¥ï¼š\n ä½¿ç”¨ä¸€ä¸ªå•è°ƒæ ˆå­˜å‚¨å…ƒç´ çš„ç´¢å¼•ï¼› å¦‚æœå…ƒç´ çš„å¤§å°å°äºç­‰äºæ ˆé¡¶å…ƒç´ çš„å¤§å°ï¼Œå…¥æ ˆï¼› å¦‚æœå…ƒç´ çš„å¤§å°å¤§äºæ ˆé¡¶å…ƒç´ çš„å¤§å°ï¼Œå‡ºæ ˆï¼Œç›´åˆ°å…ƒç´ çš„å¤§å°å°äºç­‰äºæ ˆé¡¶å…ƒç´ çš„å¤§å°ä¸ºæ­¢ï¼ˆæˆ–è€…æ ˆä¸ºç©ºï¼‰ï¼› æ¯å‡ºæ ˆä¸€ä¸ªï¼ˆéæ ˆåº•ï¼‰å…ƒç´ ï¼Œç®—ä¸€æ¬¡é›¨æ°´çš„å®½åº¦ï¼ˆi å’Œå‰©ä¸‹çš„æ ˆé¡¶å…ƒç´ çš„é—´éš”ï¼‰å’Œé«˜åº¦ï¼ˆi å’Œå‰©ä¸‹æ ˆé¡¶å…ƒç´ çš„æœ€å°å€¼ï¼Œå‡å»å‡ºæ ˆå…ƒç´ çš„å€¼ï¼‰ï¼Œç´¯åŠ èµ·æ¥å°±æ˜¯ç»“æœã€‚  å®˜æ–¹é¢˜è§£ æ›´è¯¦ç»†ï¼Œä¸è¿‡æ—¢ç„¶æœ‰æ›´å¥½çš„è§£æ³•äº†ï¼Œçœ‹ä¸æ‡‚ä¹Ÿæ²¡ä»€ä¹ˆå…³ç³»ğŸ˜‚\nclass Solution: def maxWater(self , arr: List[int]) -\u0026gt; int: stack, result = [], 0 for i in range(len(arr)): if not stack or arr[i] \u0026lt;= arr[stack[-1]]: # å…¥æ ˆ stack.append(i) else: # å‡ºæ ˆï¼Œç®—é›¨æ°´ while arr[i] \u0026gt; arr[stack[-1]]: top = stack.pop() if not stack: # æ ˆåº•å…ƒç´ ï¼Œè·³è¿‡ break else: left = stack[-1] # å‰©ä¸‹çš„æ ˆé¡¶å…ƒç´  width = i - left - 1 height = min(arr[left], arr[i]) - arr[top] result += width * height stack.append(i) return result BM95 åˆ†ç³–æœé—®é¢˜ çœ‹äº†é¢˜è§£å¥½ä¹…è¿˜æ˜¯æ²¡çœ‹æ‡‚â€¦â€¦å¦‚æœé¢è¯•é‡åˆ°è¿™é“é¢˜å°±åªèƒ½ğŸ˜­\næ–¹æ³•ä¸€ï¼šç›´æ¥æ³•  ä»å·¦åˆ°å³éå†æ•°ç»„ï¼› å¦‚æœ arr[i] \u0026gt; arr[i - 1]ï¼Œå°±åˆ† pre + 1 é¢—ç³–ï¼Œä¸Šå‡è®¡æ•°+1ï¼› å¦‚æœ arr[i] == arr[i - 1]ï¼Œåªéœ€è¦åˆ† 1 é¢—ç³–ï¼Œé‡æ–°å¼€å§‹ï¼› å¦‚æœ arr[i] \u0026lt; arr[i - 1]ï¼Œåªéœ€è¦åˆ† 1 é¢—ç³–ï¼Œå¹¶ä¸”æŠŠå‰é¢è¿ç»­é€’å‡çš„æ•°å­—éƒ½ +1ã€‚  å‰é¢ 3 æ­¥éƒ½å¾ˆå®¹æ˜“ç†è§£ï¼Œå”¯ç‹¬ç¬¬ 4 æ­¥ä¸å®¹æ˜“ç†è§£ä¹Ÿä¸å¥½å†™ï¼Œé¢˜è§£ çš„åšæ³•æ˜¯ç”¨ increase è®°å½•å‰é¢çš„ä¸Šå‡æ¬¡æ•°ï¼ˆå³å³°å€¼ï¼‰ï¼Œå¦‚æœé‡åˆ°è¿ç»­é€’å‡çš„æ•°å­—ä¸ªæ•° decrease æ°å¥½ä¸å³°å€¼çš„æ•°å­—ç›¸åŒï¼ˆæ¯”å¦‚å³°å€¼ä¸º 5ï¼Œå‰é¢åˆæœ‰ 4 ä¸ªé€’å‡çš„æ•° 4,3,2,1ï¼Œæ­¤æ—¶ decrease = 4ï¼Œè¿™æ—¶åˆé‡åˆ°ä¸€ä¸ªé€’å‡çš„æ•°ï¼‰ï¼Œå°±æŠŠå³°å€¼ä¹Ÿçº³å…¥é€’å‡åºåˆ—ä¸­ï¼Œå³ç»™ decrease å† +1ã€‚\nclass Solution: def candy(self , arr: List[int]) -\u0026gt; int: result = 0 for i in range(len(arr)): if not result or arr[i] == arr[i - 1]: increase, decrease, pre = 1, 0, 1 result += pre elif arr[i] \u0026gt; arr[i - 1]: pre += 1 result += pre decrease = 0 increase = pre else: decrease += 1 if decrease == increase: decrease += 1 result += decrease pre = 1 return result æ–¹æ³•äºŒï¼šè´ªå¿ƒæ³• è´ªå¿ƒæ³•æ›´å®¹æ˜“ç†è§£ä¸å®ç°ï¼š\n æ­£å‘éå†ï¼Œå¦‚æœ arr[i] \u0026gt; arr[i - 1]ï¼Œåˆ™ left[i] = left[i - 1] + 1ï¼Œå¦åˆ™ left[i] = 1ï¼› åå‘éå†ï¼Œå¦‚æœ arr[i] \u0026gt; arr[i + 1]ï¼Œåˆ™ right[i] = right[i + 1] + 1ï¼Œå¦åˆ™ right[i] = 1ï¼› è”ç«‹èµ·æ¥æ±‚æœ€å¤§å€¼ï¼Œå³ result[i] = max(left[i], right[i])ï¼Œå†è¿”å› result æ•°ç»„çš„å’Œã€‚  class Solution: def candy(self , arr: List[int]) -\u0026gt; int: left, right = [1] * len(arr), [1] * len(arr) for i in range(1, len(arr)): if arr[i] \u0026gt; arr[i - 1]: left[i] = left[i - 1] + 1 for i in range(len(arr) - 2, -1, -1): if arr[i] \u0026gt; arr[i + 1]: right[i] = right[i + 1] + 1 return sum(max(i, j) for i,j in zip(left, right)) ä½†æ˜¯è´ªå¿ƒæ³•ä¸ºä»€ä¹ˆæ˜¯æ­£ç¡®çš„å‘¢ï¼Ÿå› ä¸ºæ­£å‘éå†å’Œåå‘éå†ï¼Œè®¡ç®—å‡ºæ¥çš„éƒ½æ˜¯æ»¡è¶³é¢˜ç›®è¦æ±‚çš„æœ€å°å€¼çš„ä¸€ä¸ªä¸‹ç•Œï¼Œå³ result[i] \u0026gt;= max(left[i], right[i])ï¼Œåªéœ€è¦éªŒè¯ max(left[i], right[i]) ç¡®å®æ˜¯ç¬¦åˆé¢˜ç›®è¦æ±‚çš„ä¸€ä¸ªè§£ã€‚\nå‡è®¾ A,B æ˜¯æ•°ç»„ä¸­ç›¸é‚»çš„ä¸¤ä¸ªæ•°çš„ä¸‹æ ‡ï¼Œä¸” arr[A] \u0026gt; arr[B]ï¼Œå¦‚æœ A \u0026gt; Bï¼Œåˆ™ left[A] \u0026gt; left[B] \u0026gt;= 1, right[A] \u0026gt;= right[B] = 1ï¼Œæ•… max(left[A], right[A]) \u0026gt;= left[A] \u0026gt; max(left[B], right[B]) = left[B]ã€‚ç”±å¯¹ç§°æ€§ï¼ŒB \u0026gt; A æ—¶ä¹Ÿæˆç«‹ã€‚å½“ arr[A] == arr[B] æ—¶ï¼Œä¹Ÿæ˜¾ç„¶æ˜¯é¢˜ç›®çš„è§£ï¼ˆå› ä¸ºé¢˜ç›®æ²¡ä½œè¦æ±‚ï¼‰ï¼Œå› æ­¤ max(left[i], right[i]) ç¡®å®æ˜¯ç¬¦åˆè¦æ±‚çš„è§£ã€‚æ•…ç¡®å®ä¸ºæœ€å°å€¼ã€‚\nBM96 ä¸»æŒäººè°ƒåº¦ï¼ˆäºŒï¼‰ ä¸€å¼€å§‹æƒ³åˆ° åŒºé—´è°ƒåº¦é—®é¢˜ å»äº†ï¼ŒæŠŠç®€å•çš„é—®é¢˜å¤æ‚åŒ–äº†â€¦â€¦\nå…¶å®å°±æ˜¯æ¨¡æ‹Ÿä¸€ä¸ªé˜Ÿåˆ—ç³»ç»Ÿï¼Œæ´»åŠ¨åˆ°å¼€å§‹æ—¶é—´å°±è¿›å…¥é˜Ÿåˆ—ï¼Œåˆ°ç»“æŸæ—¶é—´å°±ç¦»å¼€é˜Ÿåˆ—ï¼Œè®°å½•é˜Ÿåˆ—ä¸­æ´»åŠ¨æ•°é‡çš„æœ€å¤§å€¼ã€‚å¯ä»¥ç›´æ¥éå†ï¼Œä¹Ÿå¯ä»¥å€ŸåŠ©æ•°æ®ç»“æ„ï¼ˆå¦‚å°é¡¶å †ï¼‰ï¼š\nclass Solution: def minmumNumberOfHost(self , n: int, startEnd: List[List[int]]) -\u0026gt; int: import heapq startEnd.sort() queue = [] heapq.heapify(queue) result = 0 for start, end in startEnd: while queue and queue[0] \u0026lt;= start: heapq.heappop(queue) heapq.heappush(queue, end) result = max(result, len(queue)) return result ä¹Ÿæœ‰æ›´ç®€å•ç›´è§‚çš„æ–¹æ³•ï¼šè®°å½•ä¸‹æ‰€æœ‰å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´ï¼Œå¹¶æŒ‰æ—¶é—´å‰åæ’åºï¼Œresult ä» 0 å¼€å§‹ï¼Œé‡åˆ°å¼€å§‹æ—¶é—´ +1ï¼Œé‡åˆ°ç»“æŸæ—¶é—´ -1ï¼Œæœ€åè¿”å› result çš„æœ€å¤§å€¼ï¼š\nclass Solution: def minmumNumberOfHost(self , n: int, startEnd: List[List[int]]) -\u0026gt; int: start = [(i[0],1) for i in startEnd] end = [(i[1], -1) for i in startEnd] queue = sorted(start + end) result, tmp = 0, 0 for event in queue: tmp += event[1] result = max(result, tmp) return result BTWï¼Œæ— æƒé‡çš„åŒºé—´è°ƒåº¦é—®é¢˜ï¼ˆå³é€‰æ‹©æ•°é‡æœ€å¤šçš„ä¸é‡åˆåŒºé—´ï¼‰ä¹Ÿæ˜¯å¯ä»¥ä½¿ç”¨è´ªå¿ƒç®—æ³•å¾—åˆ°æœ€ä¼˜è§£çš„ã€‚\nBM97 æ—‹è½¬æ•°ç»„ è¿™ä¸ªé—®é¢˜çš„å†å²å¯èƒ½æ¯” Unix è¿˜è¦æ‚ ä¹…ğŸ˜‚\næ–¹æ³•ä¸€ï¼šä¸‰æ¬¡é•œåƒ æŠŠæ•°ç»„åˆ†æˆ [A B]ï¼Œå…ˆç¿»è½¬ä¸€æ¬¡å¾—åˆ° [B' A']ï¼Œå†åˆ†åˆ«ç¿»è½¬è¿‡æ¥ï¼Œå°±å¾—åˆ°äº† [B A]ï¼Œåè¿‡æ¥ä¹Ÿå¯ä»¥ã€‚\nclass Solution: def solve(self , n: int, m: int, arr: List[int]) -\u0026gt; List[int]: m = m % n def reverse(nums, start, end): while start \u0026lt; end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 reverse(arr, 0, n - 1) reverse(arr, 0, m - 1) reverse(arr, m, n - 1) return arr è¿™ä¸€ç®—æ³•æœ‰è¯¸å¤šä¼˜ç‚¹ï¼šå®¹æ˜“ç†è§£ä¸å®ç°ï¼Œç©ºé—´å’Œæ—¶é—´éƒ½å¾ˆé«˜æ•ˆï¼Œä»£ç ç®€çŸ­éš¾ä»¥å‡ºé”™ã€‚Ken Thompson åœ¨ 1971 å¹´å¼€å‘ ed æ–‡æœ¬ç¼–è¾‘å™¨æ—¶ä½¿ç”¨äº†è¿™ä¸€ç®—æ³•ï¼Œå¹¶ä¸»å¼ æŠŠå®ƒä½œä¸ºä¸€ç§ç¼–ç¨‹å¸¸è¯†ã€‚\næ–¹æ³•äºŒï¼šå¾ªç¯ç§»ä½ æ³¨æ„åˆ°ç§»ä½åçš„åæ ‡ï¼Œ0-\u0026gt;m, 1-\u0026gt;m+1,...,n-1-\u0026gt;m-1ï¼Œæ°å¥½æ˜¯æ¯ä¸ªåæ ‡åŠ ä¸Š mï¼ˆå†å¯¹ n æ±‚ä½™ï¼‰ï¼Œåªè¦æ‰¾åˆ°ä¸€æ¡éå†çš„è·¯å¾„å°±å¥½ã€‚\nä½¿ç”¨ä¸€ç‚¹å¾ªç¯ç¾¤çš„çŸ¥è¯†ï¼Œå¦‚æœ m,n äº’ç´ ï¼Œ0-\u0026gt;m-\u0026gt;2m-\u0026gt;...-\u0026gt;(n-1)m-\u0026gt;0 (mod n) å¯ä»¥éå†æ•°ç»„çš„æ‰€æœ‰æ•°ã€‚å¦‚æœ m å’Œ n æœ€å¤§å…¬çº¦æ•°ä¸º g \u0026gt; 1ï¼Œéœ€è¦åˆ†åˆ«ä»¥ range(g) ä¸ºå¼€å¤´éå†æ‰èƒ½å®Œæˆã€‚æƒ³æ³•è™½ç„¶ç®€å•ï¼Œè¦å†™å‡ºä»£ç å¹¶ä¸å®¹æ˜“â€¦â€¦\nclass Solution: def solve(self , n: int, m: int, arr: List[int]) -\u0026gt; List[int]: from math import gcd m = m % n for i in range(gcd(m, n)): tmp = arr[i] start = i while start != (i + m) % n: arr[start] = arr[(start + n - m) % n] # é¢˜æ„è¦åè¿‡æ¥ start = (start + n - m) % n arr[start] = tmp return arr ç†è®ºä¸Šï¼Œè¿™ä¸ªç®—æ³•ä¼¼ä¹æ˜¯æœ€å¿«çš„ï¼Œå› ä¸ºåªæ˜¯éå†æ‰€æœ‰æ•°ä¸€æ¬¡è¿›è¡Œäº†ç§»ä½ï¼Œæ“ä½œæ•°é‡åº”è¯¥æ˜¯æœ€å°‘çš„ã€‚ç„¶è€Œç°å®ä¸­ï¼Œéšç€ m,n çš„å¢å¤§ï¼Œç®—æ³•çš„é€Ÿåº¦å¹¶ä¸è®©äººæ»¡æ„ã€‚Jon Bentley çŒœæµ‹ï¼Œè¿™ä¸ªç®—æ³•ä¸èƒ½å¾ˆå¥½åœ°åˆ©ç”¨é«˜é€Ÿç¼“å­˜ï¼Œè¿˜ä¼šå½±å“ç³»ç»Ÿé¡µé¢çš„æ€§èƒ½ã€‚\næ–¹æ³•ä¸‰ï¼šå—äº¤æ¢ å…¶å®é€ƒè¯¾æ‰æ˜¯æ­£å¸¸æƒ³æ³•å§ï¼\nclass Solution: def solve(self , n: int, m: int, arr: List[int]) -\u0026gt; List[int]: m = m % n arr[:m], arr[m:] = arr[-m:], arr[:n-m] return arr ä½†æ˜¯é¢˜ç›®ä¸å…è®¸ä½¿ç”¨é¢å¤–çš„ç©ºé—´è¿›è¡Œäº¤æ¢ï¼Œæœ‰ä»€ä¹ˆæ–¹æ³•å‘¢ï¼Ÿä¸å¦¨å‡è®¾ [A B] -\u0026gt; [B A]ï¼š\n å¦‚æœ A å’Œ B ç­‰é•¿ï¼Œç›´æ¥ swap(A, B) å³å¯ï¼› å¦‚æœ A æ¯” B é•¿ï¼Œåˆ™åˆ†æˆ [A1 A2 B] å† swap(A1, B) -\u0026gt;[B A2 A1]ï¼Œè½¬åŒ–æˆäº†äº¤æ¢ A2 å’Œ A1 çš„å­é—®é¢˜ï¼› å¦‚æœ A æ¯” B çŸ­ï¼ŒåŒæ ·åˆ†æˆ [A B1 B2] å† swap(A, B2) -\u0026gt; [B2 B1 A]ï¼Œè½¬åŒ–æˆäº†äº¤æ¢ B2 ä¸ B1 çš„å­é—®é¢˜ã€‚  å¯ä»¥çœ‹åˆ°è¿™ä¸€æµç¨‹ç­‰ä»·äºæ±‚æœ€å¤§å…¬çº¦æ•°çš„æ›´ç›¸å‡æŸæœ¯ï¼Œæ•…ä¸€å®šä¼šç»ˆæ­¢ã€‚å¯ä»¥ä½¿ç”¨é€’å½’ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨è¿­ä»£ï¼ˆGries \u0026amp; Millsï¼‰ï¼š\nclass Solution: def solve(self , n: int, m: int, arr: List[int]) -\u0026gt; List[int]: def swap(a, b, m): # arr[a,...,a+m-1] \u0026lt;-\u0026gt; arr[b,...,b+m-1] for i in range(m): arr[a + i], arr[b + i] = arr[b + i], arr[a + i] m = m % n if m == 0: return arr p, i, j = n - m, n - m, m # æŠŠå‰é¢ n-m ä¸ªå…ƒç´ ç§»åˆ°åé¢ while i != j: # p - åˆ†ç•Œç‚¹ï¼Œi - å·¦è¾¹é•¿åº¦ï¼Œj - å³è¾¹é•¿åº¦ if i \u0026gt; j: # å·¦è¾¹æ¯”å³è¾¹é•¿ [A1 A2 B] -\u0026gt; [B A2 A1] swap(p - i, p, j) i -= j else: # å³è¾¹æ¯”å·¦è¾¹é•¿ [A B1 B2] -\u0026gt; [B2 B1 A] swap(p - i, p + j - i, i) j -= i swap(p - i, p, i) return arr è¿™æ˜¯å®é™…æµ‹è¯•ä¸­æœ€å¿«çš„ç®—æ³•ï¼ˆå¯èƒ½å› ä¸ºèƒ½åˆ©ç”¨é«˜é€Ÿç¼“å­˜ï¼‰ï¼Œä¸è¿‡å†™èµ·æ¥å¤æ‚å®¹æ˜“å‡ºé”™ã€‚\næ‰©å±•é˜…è¯»ï¼šã€Šç¼–ç¨‹ç ç‘ã€‹by Jon Bentley\nBM98 èºæ—‹çŸ©é˜µ æŒºæ™®é€šçš„ä¸€é“é¢˜â€¦â€¦æ¨¡æ‹Ÿ 4 ä¸ªè¾¹ç•Œï¼Œæ’åˆ°è¾¹ç•Œä¹‹åæ›´æ–°è¾¹ç•Œçš„å€¼å’Œå‰è¿›æ–¹å‘ï¼Œéš¾ç‚¹æ˜¯ç¡®å®šç»ˆæ­¢æ¡ä»¶ã€‚\nè¿™é‡Œä¸ºäº†ç®€ä¾¿ä½¿ç”¨äº†å¤æ•°è®°å½•çŸ©é˜µçš„åæ ‡ï¼Œ(i,j) è¡¨ç¤ºçŸ©é˜µç¬¬ i è¡Œç¬¬ j åˆ—ã€‚\nclass Solution: def spiralOrder(self , matrix: List[List[int]]) -\u0026gt; List[int]: if not matrix or not matrix[0]: return [] moves = ( 1j, 1, -1j, -1) # å³ ä¸‹ å·¦ ä¸Š bounds = [0, len(matrix[0]) - 1, len(matrix) - 1, 0] # ä¸Š å³ ä¸‹ å·¦ status, cor, result = 0, 0j, [] while True: if bounds[0] \u0026lt;= cor.real \u0026lt;= bounds[2] and bounds[3] \u0026lt;= cor.imag \u0026lt;= bounds[1]: # ä»ç„¶åœ¨è¾¹ç•ŒèŒƒå›´å†… result.append(matrix[int(cor.real)][int(cor.imag)]) cor += moves[status] else: # è¶Šç•Œ if bounds[0] \u0026gt; bounds[2] or bounds[3] \u0026gt; bounds[1]: # ç»ˆæ­¢æ¡ä»¶ break else: #é€€ä¸€æ ¼ï¼Œæ›´æ–°è¾¹ç•Œå€¼ï¼Œå‰è¿› cor -= moves[status] if status in (0, 3): bounds[status] += 1 else: bounds[status] -= 1 status = (status + 1) % 4 cor += moves[status] return result BM99 é¡ºæ—¶é’ˆæ—‹è½¬çŸ©é˜µ å’Œ BM97 ç±»ä¼¼ï¼Œå…ˆè½¬ç½®åç¿»è½¬ï¼š\nclass Solution: def rotateMatrix(self , mat: List[List[int]], n: int) -\u0026gt; List[List[int]]: for i in range(n): # è½¬ç½®çŸ©é˜µ for j in range(i + 1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] for i in range(n): # ç¿»è½¬çŸ©é˜µ for j in range(n // 2): mat[i][j], mat[i][n - 1 - j] = mat[i][n - 1 - j], mat[i][j] return mat BM100 è®¾è®¡LRUç¼“å­˜ç»“æ„ æƒ³äº†å¾ˆä¹…éƒ½æ²¡æœ‰æƒ³æ˜ç™½æ€ä¹ˆæŠŠå“ˆå¸Œè¡¨å’ŒåŒå‘é“¾è¡¨ç»“åˆåœ¨ä¸€èµ·è¿˜èƒ½åšåˆ° O(1)ï¼Œä¸€çœ‹æºç ï¼Œæ˜¯ä½¿ç”¨å“ˆå¸Œè¡¨å­˜æ”¾ key å¯¹åº”çš„åŒå‘é“¾è¡¨ç»“ç‚¹çš„å¼•ç”¨ï¼Œè¿™æ˜¯æ€ä¹ˆæƒ³å‡ºæ¥çš„ğŸ˜­\n get çš„æµç¨‹ï¼šé¦–å…ˆæŸ¥è¯¢å“ˆå¸Œè¡¨ dï¼Œå¦‚æœæ‰¾åˆ° d[key]ï¼Œè®¿é—® d[key] çš„ç»“ç‚¹è·å– valï¼ˆå“ˆå¸Œè¡¨ï¼ŒO(1)ï¼‰ï¼Œå¹¶æŠŠ d[key] çš„ç»“ç‚¹ç§»åˆ°æœ«å°¾ï¼ˆåŒå‘é“¾è¡¨ï¼ŒO(1)ï¼‰ï¼› set çš„æµç¨‹ï¼šå¦‚æœ key å­˜åœ¨ï¼Œè®¿é—® d[key] çš„ç»“ç‚¹ä¿®æ”¹ valï¼ˆå“ˆå¸Œè¡¨ï¼ŒO(1)ï¼‰ï¼Œå¹¶æŠŠ d[key] çš„ç»“ç‚¹ç§»åˆ°æœ«å°¾ï¼ˆåŒå‘é“¾è¡¨ï¼ŒO(1)ï¼‰ï¼›å¦åˆ™æ–°å¢ç»“ç‚¹ï¼Œå¦‚æœå®¹é‡ä¸è¶³ï¼Œéœ€è¦åˆ æ‰åŒå‘é“¾è¡¨å¤´ç»“ç‚¹ï¼ˆåŒå‘é“¾è¡¨ï¼ŒO(1)ï¼‰å¹¶ä¸”åŒæ—¶åˆ æ‰å¯¹åº”çš„ d[key] è®°å½•ï¼ˆå“ˆå¸Œè¡¨ï¼ŒO(1)ï¼‰ï¼Œç„¶ååœ¨åŒå‘é“¾è¡¨æœ«ç«¯æ’å…¥ç»“ç‚¹ï¼ˆåŒå‘é“¾è¡¨ï¼ŒO(1)ï¼‰ï¼Œæœ€åç»™ d[key] å†™å…¥ç»“ç‚¹çš„å¼•ç”¨ï¼ˆå“ˆå¸Œè¡¨ï¼ŒO(1)ï¼‰ã€‚  class Node: # åŒå‘é“¾è¡¨ç»“ç‚¹ï¼Œå­˜å‚¨ val def __init__(self, key, val): self.key = key # ä¸ºäº†èƒ½åˆ é™¤å¤´ç»“ç‚¹ self.val = val self.pre = None self.next = None class Solution: def __init__(self, capacity: int): self.size = capacity self.head = None self.tail = None self.d = dict() def insert_end(self, node): # é“¾è¡¨å°¾æ’å…¥æ–°ç»“ç‚¹ if self.head == None: self.head = self.tail = node else: self.tail.next = node node.pre = self.tail self.tail = node def move_to_end(self, node): # æŠŠç»“ç‚¹ç§»åˆ°é“¾è¡¨å°¾ if node == self.tail: return elif node == self.head: # è„±ç¦» if node.next: node.next.pre = None self.head = node.next else: self.head = self.tail = None else: pre, nxt = node.pre, node.next pre.next, nxt.pre = nxt, pre node.next = None self.insert_end(node) def remove_head(self): # åˆ é™¤å¤´ç»“ç‚¹ node = self.head self.d.pop(node.key) node.next.pre = None self.head = node.next del node def get(self, key: int) -\u0026gt; int: result = -1 if key in self.d: result = self.d[key].val self.move_to_end(self.d[key]) return result def set(self, key: int, value: int) -\u0026gt; None: if key in self.d: # æ›´æ–°å€¼ self.d[key].val = value self.move_to_end(self.d[key]) else: if self.size \u0026lt;= 0: self.remove_head() else: self.size -= 1 node = Node(key, value) self.d[key] = node self.insert_end(node) Python çš„ OrderedDict å°±æ˜¯ ä½¿ç”¨å“ˆå¸Œè¡¨+åŒé“¾è¡¨å®ç°çš„ï¼ŒOrderedDict è¿˜æä¾›äº† å®˜æ–¹é€ƒè¯¾æ•™ç¨‹ï¼š\nfrom collections import OrderedDict class Solution: def __init__(self, capacity: int): self.size = capacity self.cache = OrderedDict() def get(self, key: int) -\u0026gt; int: result = -1 if key in self.cache: result = self.cache[key] self.cache.move_to_end(key) return result def set(self, key: int, value: int) -\u0026gt; None: if key in self.cache: # æ›´æ–°å€¼ self.cache[key] = value self.cache.move_to_end(key) else: if self.size \u0026lt;= 0: self.cache.popitem(last=False) else: self.size -= 1 self.cache[key] = value é™¤æ­¤ä»¥å¤–ï¼ŒLRU ä¹Ÿå¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨+å¹³è¡¡äºŒå‰æ ‘ï¼ˆå°é¡¶å †ï¼‰å®ç°ï¼Œæ¯”å¦‚åˆå§‹åŒ–ä¸€ä¸ªæ—¶é—´è®¡æ•°å™¨ timeï¼Œæ¯æ’å…¥/æ›´æ–°ä¸€æ¬¡å…ƒç´ å°±ä¿®æ”¹ä¸€æ¬¡æ—¶é—´è®¡æ•°å™¨ï¼Œå¹¶ä½œä¸ºå…ƒç´ çš„æ’åºä¾æ®ã€‚ä¸ºäº†ç»´æŠ¤æœ‰åºæ€§ï¼Œæ¯æ¬¡æ’å…¥å’Œæ›´æ–°å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦å°±å˜æˆäº† O(log n)ã€‚\nä¸è¿‡ Python æ²¡æœ‰å†…ç½®å¹³è¡¡äºŒå‰æ ‘ï¼Œå°é¡¶å † heapq æ˜¯ä½¿ç”¨åˆ—è¡¨ï¼ˆæ•°ç»„ï¼‰å­˜å‚¨çš„ï¼Œä¸èƒ½å®ç° O(log n) åˆ é™¤æˆ–æ›´æ–°å…ƒç´ ï¼ˆheapq.heapify æ˜¯ O(n) çš„ï¼Œå¦‚æœçŸ¥é“ä¸‹æ ‡å€’æ˜¯ å¯ä»¥ï¼Œä½†æ˜¯ä¸‹æ ‡ä¼šå˜ï¼‰ï¼Œåªèƒ½ä¸å¤ªä¼˜é›…åœ°å­¦ ä¼˜å…ˆé˜Ÿåˆ—çš„å®ç° æŠŠå…ƒç´ è®¾ç½®ä¸ºç§»é™¤çŠ¶æ€ï¼Œæ›´æ–°æ•°æ®åä½œä¸ºæ–°å…ƒç´ é‡æ–°æ’å…¥ã€‚\nå¦‚æœåªæ˜¯æŠŠå…ƒç´ è®¾ç½®æˆç§»é™¤çŠ¶æ€ï¼ˆè€Œä¸æ˜¯çœŸçš„ç§»é™¤ï¼‰ï¼Œå…¶å®ä¹Ÿå¯ä»¥æŠŠåŒå‘é“¾è¡¨æ¢æˆåŒç«¯é˜Ÿåˆ—ï¼Œä¹Ÿå¯ä»¥å­¦ LFU ä½¿ç”¨å“ˆå¸Œè¡¨ï¼ˆkey ä¸º timeï¼‰ä»£æ›¿åŒå‘é“¾è¡¨ï¼Œéœ€è¦é¢å¤–ç»´æŠ¤ä¸€ä¸ª min_time çŠ¶æ€ï¼Œä¸è¿‡å› ä¸º time çš„è·³è·ƒå¢é•¿ï¼Œæ•ˆç‡ä¼šæœ‰æ‰€ä¸‹é™ã€‚\nBM101 è®¾è®¡LFUç¼“å­˜ç»“æ„ å’Œ LRU ç±»ä¼¼ï¼Œåªæ˜¯è¦æ¯”è¾ƒçš„å¯¹è±¡ä»â€œæœ€è¿‘è®¿é—®æ—¶é—´â€å˜æˆ (è®¿é—®é¢‘ç‡ï¼Œæœ€è¿‘è®¿é—®æ—¶é—´) çš„äºŒå…ƒç»„ã€‚Python å¯ä»¥ç›´æ¥æ¯”è¾ƒå…ƒç»„/åˆ—è¡¨çš„å¤§å°ï¼š\n\u0026gt;\u0026gt;\u0026gt; [1,1] \u0026lt; [1,2] \u0026lt; [2,1] \u0026lt; [2,2] True å› æ­¤å¯ä»¥æŠŠåŒå‘é“¾è¡¨æ¢æˆå°é¡¶å †/å¹³è¡¡äºŒå‰æ ‘æ¥å®ç°ï¼Œä¸è¿‡æ»¡è¶³ä¸äº†æ—¶é—´å¤æ‚åº¦ O(1) çš„è¦æ±‚ã€‚\nå¦ä¸€ç§åšæ³•æ˜¯ç»¼åˆåˆ©ç”¨å‰é¢çš„ä¸‰ç‚¹ç»éªŒï¼š\n ä½¿ç”¨å“ˆå¸Œè¡¨çš„å€¼å­˜æ”¾ç›®æ ‡å¯¹è±¡çš„å¼•ç”¨ï¼Œå¯ä»¥åœ¨ä¸é™ä½æ—¶é—´å¤æ‚åº¦çš„æƒ…å†µä¸‹è¿›è¡Œæ‰©å±•ï¼› ä½¿ç”¨ä¸€ä¸ª min_key çŠ¶æ€å’Œå“ˆå¸Œè¡¨ï¼Œå¯ä»¥å®ç° O(1) æ—¶é—´å¤æ‚åº¦ä¸‹å¯æ›´æ–° key æ•°å€¼çš„é˜Ÿåˆ—ï¼› ä½¿ç”¨åŒå‘é“¾è¡¨åŒæ ·å¯ä»¥å®ç° O(1) æ—¶é—´å¤æ‚åº¦çš„é˜Ÿåˆ—ï¼Œä½†ä¸èƒ½éšæ„æ›´æ–° key çš„æ•°å€¼ã€‚  äºæ˜¯å¯è®¾è®¡ä¸ºï¼š\n ä¾ç„¶æ˜¯ä½¿ç”¨æ€»å“ˆå¸Œè¡¨å­˜æ”¾å€¼ç»“ç‚¹çš„å¼•ç”¨ï¼› å› ä¸ºä½¿ç”¨é¢‘ç‡ freq æ¯æ¬¡æ›´æ–°æ˜¯ +1 çš„ï¼Œå¯ä»¥ä½¿ç”¨ min_freq çŠ¶æ€å’Œå¦ä¸€ä¸ª freq å“ˆå¸Œè¡¨å­˜æ”¾é¢‘ç‡å’Œå€¼ç»“ç‚¹æ‰€åœ¨çš„æ•°æ®ç»“æ„ï¼› æœ€åï¼Œå› ä¸ºæœ€è¿‘è®¿é—®æ—¶é—´ time æ¯æ¬¡æ›´æ–°éƒ½æ˜¯ç§»åˆ°ç»“å°¾ï¼Œå¯ä»¥ä½¿ç”¨åŒå‘é“¾è¡¨æ¥å­˜å‚¨ç»“ç‚¹ï¼Œè¿™æ ·å°±ä¸éœ€è¦å­˜å‚¨è®¿é—®æ—¶é—´çš„å€¼äº†ã€‚  å…·ä½“è€Œè¨€ï¼š\n ä½¿ç”¨åŒå‘é“¾è¡¨çš„ç»“ç‚¹å­˜æ”¾å¯¹åº”çš„å€¼ï¼ˆä»¥åŠè®¿é—®é¢‘ç‡ freqï¼‰ï¼› æ¯ä¸ªç»“ç‚¹æ‰€åœ¨çš„åŒå‘é“¾è¡¨ï¼Œå­˜æ”¾ç›¸åŒè®¿é—®é¢‘ç‡ freq çš„ç»“ç‚¹ï¼ŒåŒå‘é“¾è¡¨çš„å¼•ç”¨ä½œä¸º freq å“ˆå¸Œè¡¨ä¸­è®¿é—®é¢‘ç‡å¯¹åº”çš„å€¼ï¼› è°ƒç”¨ set æ—¶ï¼Œé¦–å…ˆé€šè¿‡æ€»å“ˆå¸Œè¡¨æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼ˆå“ˆå¸Œè¡¨ï¼ŒO(1)ï¼‰ï¼š   å¦‚æœå­˜åœ¨ï¼Œè®¿é—®ç»“ç‚¹ä¿®æ”¹å¯¹åº”çš„å€¼ï¼ˆO(1)ï¼‰ï¼ŒåŒæ—¶å¾—åˆ°å½“å‰è®¿é—®é¢‘ç‡ freqï¼›     ä½¿ç”¨ freq å“ˆå¸Œè¡¨ï¼Œæ‰¾åˆ°ç»“ç‚¹æ‰€åœ¨çš„åŒå‘é“¾è¡¨ï¼ˆO(1)ï¼‰ï¼Œä»åŒå‘é“¾è¡¨ä¸­ç§»é™¤ç»“ç‚¹ï¼ˆO(1)ï¼‰ï¼›     æ›´æ–°ç»“ç‚¹çš„è®¿é—®é¢‘ç‡ freqï¼Œå¹¶æ’å…¥å¯¹åº”é¢‘ç‡åœ¨å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„åŒå‘é“¾è¡¨æœ«ç«¯ï¼ˆO(1)ï¼‰ï¼Œæ­¤æ—¶å¯èƒ½éœ€è¦æ›´æ–° min_freq çš„å€¼ï¼›     å¦‚æœä¸å­˜åœ¨ï¼Œé¦–å…ˆæ£€æŸ¥å¯ç”¨å®¹é‡ capacity æ˜¯å¦å¤§äº 0ï¼Œå¦‚æœå¤§äº 0ï¼Œæ–°å»ºè¿™ä¸ªç»“ç‚¹ï¼Œå¹¶æ’å…¥åˆ°è®¿é—®é¢‘ç‡ä¸º 0 çš„åŒå‘é“¾è¡¨æœ«ç«¯ï¼Œæœ€ååœ¨æ€»å“ˆå¸Œè¡¨ä¸­å¡«å…¥å¼•ç”¨ï¼›     å¦‚æœå°äº 0ï¼Œæ£€æŸ¥ min_freq çš„å€¼ï¼Œåœ¨è®¿é—®é¢‘ç‡ä¸º min_freq çš„åŒå‘é“¾è¡¨ä¸­ç§»é™¤å¤´éƒ¨çš„å€¼å†æ’å…¥ï¼›     å†™å…¥æ–°ç»“ç‚¹å®Œæˆåï¼Œé‡æ–°æŠŠ min_freq çš„å€¼è®¾ä¸º 0ã€‚   è°ƒç”¨ get æ—¶å’Œ set ç±»ä¼¼ï¼Œå¦‚æœå­˜åœ¨ï¼Œæ›´æ–°é¢‘ç‡åè¿”å›å€¼ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œè¿”å› -1ã€‚  å¾ˆç²¾å·§çš„è®¾è®¡ï¼å°±ç®—çœ‹æ‡‚äº†ï¼Œè¦å†™èµ·æ¥ä¹Ÿå¹¶ä¸å®¹æ˜“ã€‚æ€ä¹ˆè¡¨ç¤ºåŒå‘é“¾è¡¨å‘¢ï¼Ÿæ€ä¹ˆæ£€æŸ¥åŒå‘é“¾è¡¨æ˜¯å¦ä¸ºç©ºå‘¢ï¼ˆæ­¤æ—¶ min_freq += 1ï¼‰ï¼Ÿå†™ç€å†™ç€ï¼Œä¸€ä¸ªæ™šä¸Šå°±æ²¡äº†ğŸ˜­\næœ€åè¿˜æ˜¯ç£•ç£•ç¢°ç¢°ç…§ç€é¢˜è§£å†™äº† 100 è¡Œâ€¦â€¦å¦‚æœé¢è¯•é‡åˆ°è¿™é“é¢˜ï¼Œå¿«è·‘ï¼\nfrom collections import defaultdict class Node: # åŒå‘é“¾è¡¨ç»“ç‚¹ï¼Œå­˜å‚¨ key, val, freq def __init__(self, key, val, freq=0): self.key = key self.val = val self.freq = freq self.pre = None self.next = None class DLL: # å®šä¹‰åŒé“¾è¡¨ def __init__(self): self.head = self.tail = None def insert_end(self, node): # æ’å…¥å°¾ç»“ç‚¹ if self.head == None: self.head = self.tail = node else: self.tail.next = node node.pre = self.tail self.tail = node def remove_head(self): # åˆ é™¤å¤´ç»“ç‚¹ if self.head: node = self.head if node.next: node.next.pre = None else: # node == self.tail self.tail = None self.head = node.next return node def pop(self, node): # ç§»é™¤ç‰¹å®šç»“ç‚¹ if node == self.head: self.remove_head() elif node == self.tail: node.pre.next = None self.tail = node.pre else: node.pre.next = node.next node.next.pre = node.pre def __bool__(self): # åˆ¤æ–­æ˜¯å¦ä¸ºç©º return not self.head == self.tail == None class Solution: def __init__(self, capacity=0): self.size = capacity self.cache = dict() self.freq_cache = defaultdict(DLL) self.min_freq = 0 def update(self, node, key, val): # æ›´æ–°ç»“ç‚¹ï¼Œè®¿é—®é¢‘ç‡+1 freq = node.freq self.freq_cache[freq].pop(node) if not self.freq_cache[freq]: # åŒå‘é“¾è¡¨ä¸ºç©º self.freq_cache.pop(freq) if self.min_freq == freq: self.min_freq += 1 node = Node(key, val, freq=freq+1) self.freq_cache[freq + 1].insert_end(node) self.cache[key] = node def set(self, key, val): if key in self.cache: self.update(self.cache[key], key, val) else: if self.size == 0: # ç§»é™¤é¢‘ç‡æœ€ä½çš„ç¼“å­˜ old_node = self.freq_cache[self.min_freq].remove_head() if not self.freq_cache[self.min_freq]: # åŒå‘é“¾è¡¨ä¸ºç©º self.freq_cache.pop(self.min_freq) self.cache.pop(old_node.key) else: self.size -= 1 self.min_freq = 0 node = Node(key, val, freq=0) self.freq_cache[0].insert_end(node) self.cache[key] = node def get(self, key): res = -1 if key in self.cache: node = self.cache[key] res = node.val self.update(node, key, res) return res def LFU(self , operators: List[List[int]], k: int) -\u0026gt; List[int]: res = [] self.size = k for op in operators: if op[0] == 1: # set æ“ä½œ self.set(op[1], op[2]) else: # get æ“ä½œ res.append(self.get(op[1])) return res å¤©å•Šï¼Œæ•´æ•´ 100 è¡Œï¼è°ƒè¯•è°ƒäº†ä¸€ä¸ªå°æ—¶ï¼ç»ˆäºç»“æŸäº†ğŸ˜­\n","date":"2022-04-13T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-07/","title":"åšé¢˜ç¬”è®°07ï¼šå­—ç¬¦ä¸²/åŒæŒ‡é’ˆ/è´ªå¿ƒç®—æ³•/æ¨¡æ‹Ÿ"},{"content":"BM62 æ–æ³¢é‚£å¥‘æ•°åˆ— é¦–å…ˆæƒ³åˆ°çš„è‡ªç„¶æ˜¯é€’æ¨æ³•ï¼š\nclass Solution: def Fibonacci(self , n: int) -\u0026gt; int: F_n_pre, F_n = 0, 1 # F_0, F_1 for _ in range(n - 1): F_n, F_n_pre = F_n + F_n_pre, F_n return F_n ä¸è¿‡ï¼Œä½¿ç”¨ä¸€ç‚¹çº¿æ€§ä»£æ•°çš„çŸ¥è¯†ï¼š\n$$ \\left[\\begin{array}{c} F_2\\newline F_1 \\end{array}\\right] = \\left[\\begin{array}{c} F_1 + F_0\\newline F_1 \\end{array}\\right] = \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right]^{} \\left[\\begin{array}{c} F_1\\newline F_0 \\end{array}\\right] \\Rightarrow \\left[\\begin{array}{c} F_n\\newline F_{n - 1} \\end{array}\\right] = \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right]^{n} \\left[\\begin{array}{c} F_0\\newline F_{-1} \\end{array}\\right] $$\nå°±å¯ä»¥æ›´å¿«åœ°ç®—å‡ºç»“æœï¼Œæ²¡é”™ï¼Œå°±æ˜¯å¿«é€Ÿå¹‚ç®—æ³•ï¼ä»æœ€é«˜ä½å¼€å§‹å¾€ä¸‹èµ°ï¼ˆå·¦ç§»ï¼‰ï¼Œé‡åˆ° 0 å¹³æ–¹ï¼ˆä¹˜2ï¼‰ï¼Œé‡åˆ° 1 å¹³æ–¹å¹¶ä¹˜è‡ªèº«ï¼ˆä¹˜2åŠ 1ï¼‰ï¼š\n$$6 = 0110_2 = ((0 \\cdot 2 + 1) \\cdot 2 + 1) \\cdot 2 \\Rightarrow a^6 = (((a^0)^2 \\cdot a)^2 \\cdot a)^2 = a^{((0 \\cdot 2 + 1) \\cdot 2 + 1) \\cdot 2}$$\nä¹Ÿè®¸ä½ å·²ç»è¿«ä¸åŠå¾…å¼€å§‹å†™ä»£ç äº†ï¼Œä½†è¿˜å¯ä»¥æ›´å¿«ä¸€ç‚¹ï¼Œæ³¨æ„åˆ°ï¼š\n$$ \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right] = \\left[\\begin{array}{cc} F_2 \u0026amp; F_1\\newline F_1 \u0026amp; F_0 \\end{array}\\right] \\Rightarrow \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right]^n = \\left[\\begin{array}{cc} F_{n + 1} \u0026amp; F_n\\newline F_n \u0026amp; F_{n - 1} \\end{array}\\right] $$\näºæ˜¯å¿«é€Ÿå¹‚è¿˜å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ï¼š\n$$ \\left[\\begin{array}{cc} F_{2 n + 1} \u0026amp; F_{2 n}\\newline F_{2 n} \u0026amp; F_{2 n - 1} \\end{array}\\right] = \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right]^{2 n} = \\left[\\begin{array}{cc} F_{n + 1} \u0026amp; F_n\\newline F_n \u0026amp; F_{n - 1} \\end{array}\\right]^2 = \\left[\\begin{array}{cc} F_{n + 1}^2 + F_n^2 \u0026amp; \\ast\\newline (F_{n + 1} + F_{n - 1}) F_n \u0026amp; \\ast \\end{array}\\right] $$\nå¾—åˆ°æœ€ç»ˆç»“æœï¼š\n$$ F_{2 n + 1} = F_{n + 1}^2 + F_n^2, F_{2 n} = (F_{n + 1} + F_{n - 1}) F_n = (2 F_{n + 1} - F_n) F_n, F_{2 n + 2} = F_{n + 1}(2 F_n + F_{n + 1}) $$\nclass Solution: def Fibonacci(self , n: int) -\u0026gt; int: F_n, F_n_next = 0, 1 # F_0, F_1 highbit = 1 \u0026lt;\u0026lt; (n.bit_length() - 1) while highbit: if highbit \u0026amp; n: # n, n + 1 -\u0026gt; 2n + 1, 2n + 2 F_n, F_n_next = F_n * F_n + F_n_next * F_n_next, F_n_next * (2 * F_n + F_n_next) else: # n, n + 1 -\u0026gt; 2n, 2n + 1 F_n_next, F_n = F_n * F_n + F_n_next * F_n_next, F_n * (2 * F_n_next - F_n) highbit \u0026gt;\u0026gt;= 1 return F_n BM63 è·³å°é˜¶ ä¸éš¾æ³¨æ„åˆ° $F_0 = F_1 = 1, F_n = F_{n-1} + F_{n-2}$ï¼Œå³æ±‚ Fib(n+1)ï¼ŒæŠŠæœ€åä¸€è¡Œçš„ F_n æ”¹æˆ F_n_next å³å¯ã€‚\nBM64 æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ åŠ¨æ€è§„åˆ’ç¬¬ä¸€é¢˜ï¼Œå‡è®¾çˆ¬ä¸Šç¬¬ $i$ çº§å°é˜¶çš„æˆæœ¬æ˜¯ $C_i$ï¼Œåˆ™ $C_0=0,C_1=\\min(0,C_0+\\text{cost}[0])=0,C_n=\\min(C_{n-2}+\\text{cost}[n-2], C_{n-1}+\\text{cost}[n-1])$ã€‚\nclass Solution: def minCostClimbingStairs(self , cost: List[int]) -\u0026gt; int: C_n_pre, C_n = 0, 0 # C_0, C_1 for idx in range(len(cost) - 1): # idx: 0 -\u0026gt; C_2, n-2 -\u0026gt; C_n C_n_pre, C_n = C_n, min(C_n_pre + cost[idx], C_n + cost[idx+1]) return C_n BM65 æœ€é•¿å…¬å…±å­åºåˆ—(äºŒ) çœ‹æ‡‚é¢˜ç›®å¾ˆé‡è¦ğŸ˜‚\nå­åºåˆ—æ˜¯æŒ‡åºåˆ—çš„æŸä¸ªå­é›†ï¼ˆæŒ‰é¡ºåºï¼Œä¸è€ƒè™‘é‡å¤ï¼‰ï¼Œæ¯”å¦‚å¯¹å­—ç¬¦ä¸² \u0026quot;abcbda\u0026quot; è€Œè¨€ï¼Œä»»ä½•ä¸€ä½å­—ç¬¦éƒ½æ˜¯å­åºåˆ—ï¼Œä»»æ„æŠ½å– $0 \\le n \\le 6$ ä¸ªå­—ç¬¦ä¹Ÿæ˜¯å­åºåˆ—ï¼Œå¦‚å­—ç¬¦ 1,3,6 æ„æˆçš„å­åºåˆ—ä¸º \u0026quot;aca\u0026quot;ã€‚å¦‚æœæ‰€æœ‰å­—ç¬¦éƒ½ä¸ç›¸åŒï¼Œåˆ™å­åºåˆ—çš„ä¸ªæ•°ä¸º $2^n$ï¼ˆæ‰€æœ‰å­é›†çš„ä¸ªæ•°ï¼‰ã€‚å‡è®¾ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦åˆ†åˆ«ä¸º $m,n$ï¼Œåˆ™ç©·ä¸¾éœ€è¦æ¯”è¾ƒ $2^m \\cdot 2^n=2^{m+n}$ æ¬¡ã€‚\næœ€é•¿å…¬å…±å­åºåˆ—å¯ä»¥è¡¡é‡ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ç›¸ä¼¼ç¨‹åº¦ã€‚åœ¨ç”Ÿç‰©ä¿¡æ¯å­¦ä¸­ï¼Œå¸¸å¸¸éœ€è¦æ¯”å¯¹ä¸åŒçš„ DNAï¼ˆç”± ATCG å››ä¸ªå­—æ¯ç»„æˆï¼‰ã€RNAï¼ˆAUCGï¼‰ã€è›‹ç™½è´¨ï¼ˆ20 ç§æ°¨åŸºé…¸ï¼‰çš„è¶…é•¿ï¼ˆå­—ç¬¦ä¸²ï¼‰åºåˆ—ã€‚ç©·ä¸¾çš„æŒ‡æ•°çº§æ—¶é—´å¤æ‚åº¦ï¼Œæ˜¾ç„¶æ˜¯ä¸å¯è¢«æ¥å—çš„ã€‚\nå‡è®¾å­—ç¬¦ä¸² $X_m=[x_1,\\dots,x_m],Y_n=[y_1,\\dots,y_n]$ çš„æœ€é•¿å…¬å…±å­åºåˆ—ä¸º $Z_k=[z_1,\\dots,z_k]$ï¼š\n å¦‚æœ $x_m=y_n$ï¼Œåˆ™ $z_k=x_m=y_n$ï¼ˆå¦åˆ™å¯ä»¥æŠŠ $x_m$ åŠ å…¥ $Z_k$ ä¸­å¾—åˆ°æ›´é•¿çš„å…¬å…±å­åºåˆ—ï¼‰ï¼Œæ­¤æ—¶ $Z_{k-1}$ æ˜¯ $X_{m-1},Y_{n-1}$ çš„æœ€é•¿å…¬å…±å­åºåˆ—ï¼› å¦‚æœ $x_m \\neq y_n$ï¼Œåˆ™ $z_k \\neq x_m$ æ„å‘³ç€ $Z_k$ æ˜¯ $X_{m-1}$ å’Œ $Y_n$ çš„æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆæ˜¾ç„¶æ˜¯å…¬å…±å­åºåˆ—ï¼Œå¦‚æœå­˜åœ¨æ¯”å®ƒé•¿çš„ $X_{m-1}, Y_n$ å…¬å…±å­åºåˆ— $Z'$ï¼Œåˆ™ $Z'$ ä¹Ÿæ˜¯ $X_m, Y_n$ çš„å…¬å…±å­åºåˆ—ï¼ŒçŸ›ç›¾ï¼‰ï¼ŒåŒç† $z_k \\neq y_n$ æ„å‘³ç€ $Z_k$ æ˜¯ $X_m$ å’Œ $Y_{n-1}$ çš„æœ€é•¿å…¬å…±å­åºåˆ—ã€‚  æˆ‘ä»¬è¦æ±‚çš„æ˜¯ $Z_k$ï¼Œç”± (1)ï¼Œå¦‚æœ $x_m=y_n$ï¼Œåˆ™å¯ä»¥å¾—åˆ° $z_k$ï¼Œé—®é¢˜è½¬åŒ–ä¸ºæ±‚ $X_{m-1},Y_{n-1}$ çš„æœ€é•¿å…¬å…±å­åºåˆ— $Z_{k-1}$ï¼›å¦‚æœ $x_m \\neq y_n$ï¼Œ$z_k$ æœ‰ä¸‰ç§å¯èƒ½ï¼Œ$z_k = x_m \\neq y_n$ï¼Œ$z_k = y_n \\neq x_m$ ä»¥åŠ $z_k \\neq x_m, z_k \\neq y_n$ï¼Œè€Œè¿™ä¸‰ç§å¯èƒ½éƒ½æ»¡è¶³ (2)ï¼Œæ•…æ— è®ºå“ªä¸€ç§å¯èƒ½ï¼Œåªéœ€è¦æ±‚ $X_{m-1}$ å’Œ $Y_n$ çš„æœ€é•¿å…¬å…±å­åºåˆ— $Z$ ä»¥åŠ $X_m$ å’Œ $Y_{n-1}$ çš„æœ€é•¿å…¬å…±å­åºåˆ— $Z'$ï¼Œ$Z_k$ å¿…ä¸º $Z,Z'$ ä¹‹ä¸€ï¼Œä¸” $Z,Z'$ éƒ½æ˜¯ $Z_k$ çš„å­åºåˆ—ï¼Œæ•…å– $Z,Z'$ ä¸­è¾ƒé•¿è€…å³ä¸º $Z_k$ã€‚\nå‡è®¾ $c[i][j]$ è¡¨ç¤º $X_i,Y_j$ çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ï¼Œåˆ™ï¼š\n$$ c[i][j] = \\left\\{ \\begin{array}{ll} 0 \u0026amp; i = 0 \\hspace{0.5em} \\text{or} \\hspace{0.5em} j = 0\\newline c[i - 1][j - 1] + 1 \u0026amp; i, j \u0026gt; 0, x_i = y_j\\newline \\max (c[i - 1][j], c [i][j - 1]) \u0026amp; i, j \u0026gt; 0, x_i \\neq y_j \\end{array} \\right. $$\næ˜¾ç„¶å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ï¼Œé¦–å…ˆåšå‡ºè¡¨æ ¼ï¼Œç„¶åä»å·¦åˆ°å³ä»ä¸Šåˆ°ä¸‹æ±‚è§£ï¼Œä¸è¿‡ç»“æœå¯èƒ½ä¸å”¯ä¸€ï¼ˆæ¯”å¦‚ \u0026quot;a\u0026quot; å’Œ \u0026quot;b\u0026quot; éƒ½æ˜¯ \u0026quot;ab\u0026quot; å’Œ \u0026quot;ba\u0026quot; çš„æœ€é•¿å…¬å…±å­åºåˆ—ï¼‰ã€‚åŠ¨æ‰‹ç®—ä¸€ä¸‹å°±èƒ½å‘ç°ï¼Œå…¶å®åªéœ€è¦ä¿ç•™ä¸Šä¸€è¡Œçš„ç»“æœã€‚\nclass Solution: def LCS(self , s1: str, s2: str) -\u0026gt; str: m, n = len(s1), len(s2) result = [(0, \u0026#34;\u0026#34;)] * (n + 1) # ç¬¬ 0 è¡Œï¼Œå…±æœ‰ n ä¸ªå…ƒç´  for i in range(m): tmp = result.copy() # ä¿ç•™ä¸Šä¸€è¡Œçš„ç»“æœ for j in range(n): if s1[i] == s2[j]: # c[i-1][j-1] + 1 count, seq = tmp[j] result[j+1] = (count + 1, seq + s2[j]) else: # max(c[i-1][j], c[i][j-1]) result[j+1] = max(tmp[j+1], result[j]) return result[n][1] if result[n][1] else -1 æ‰©å±•é˜…è¯»ï¼šã€Šç®—æ³•å¯¼è®ºã€‹ã€ã€Šç”Ÿç‰©ä¿¡æ¯å­¦ç®—æ³•å¯¼è®ºã€‹ã€‚\nBM66 æœ€é•¿å…¬å…±å­ä¸² æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’ï¼ˆä¸ç»™è¿‡ï¼‰ å¾ˆè‡ªç„¶æƒ³æŠŠä¸Šä¸€é¢˜å¥—è¿›æ¥ï¼Œå¦‚æœ $x_i = y_j$ï¼Œå°±æœ‰ $c[i][j] = c[i - 1][j - 1] + 1$ï¼Œä½†æ˜¯ $x_i \\neq y_j$ æ€ä¹ˆåŠå‘¢ï¼Ÿæ˜¾ç„¶è¿™é‡Œçš„ $c[i][j]$ ä¸èƒ½ä½œä¸ºå…¨å±€çš„çŠ¶æ€ï¼Œåªèƒ½ä½œä¸ºå±€éƒ¨çš„çŠ¶æ€ï¼Œå› æ­¤å¯ä»¥ç›´æ¥ç½®é›¶ï¼š\n$$ c[i][j] = \\left\\{ \\begin{array}{ll} 0 \u0026amp; i = 0 \\hspace{0.5em} \\text{or} \\hspace{0.5em} j = 0 \\hspace{0.5em} \\text{or} \\hspace{0.5em} x_i \\neq y_j \\newline c[i - 1][j - 1] + 1 \u0026amp; i, j \u0026gt; 0, x_i = y_j\\newline \\end{array} \\right. $$\næ­¤æ—¶ $c[i][j]$ è¡¨ç¤ºä» $x[i]$ å¼€å§‹è®¡æ•°ï¼Œå¾€å‰æ•° $c[i][j]$ ä¸ªå…ƒç´ ï¼Œæ˜¯ä¸€ä¸ªå…¬å…±å­ä¸²ã€‚å¦‚ $c[i][j] = 1 \\Rightarrow x[i]=y[j],c[i][j] = 2 \\Rightarrow x[i]=y[j], x[i-1]=y[j-1],\\dots$\nclass Solution: def LCS(self , str1: str, str2: str) -\u0026gt; str: m, n = len(str1), len(str2), longest, res = (0, -1), [0] * (n + 1) for i in range(m): tmp = res.copy() for j in range(n): if str1[i] == str2[j]: res[j+1] = tmp[j] + 1 else: res[j+1] = 0 if res[j+1] \u0026gt; longest[0]: longest = (res[j+1], j + 1) return str2[longest[1] - longest[0]:longest[1]] æ–¹æ³•äºŒï¼šæ»‘åŠ¨çª—å£ è¿™ä¸ªç®—æ³•å¯èƒ½ä¸æ˜¯å¾ˆå¥½æ‡‚ï¼Œè¿™é‡Œä»¥ \u0026quot;1AB2345CD\u0026quot;,\u0026quot;12345EF\u0026quot; ä¸ºä¾‹ï¼Œå¦‚æœè¿˜æ˜¯çœ‹ä¸æ‡‚ï¼Œå»ºè®®ä½¿ç”¨ PythonTutorï¼š\n é¦–å…ˆçª—å£å¤§å°ä¸º 1ï¼Œä»å·¦è¾¹å­—ç¬¦ä¸² str1 çš„ç¬¬ä¸€ä¸ªå­—æ¯ \u0026quot;1\u0026quot; å¼€å§‹ï¼› è¿™ä¸ªçª—å£ \u0026quot;1\u0026quot; åœ¨å³è¾¹å­—ç¬¦ä¸² str2 ä¸­ï¼Œè®°å½•ç»“æœï¼ŒæŠŠçª—å£å˜å¤§ï¼Œæ­¤æ—¶çª—å£å˜æˆ 2ï¼› æ­¤æ—¶çª—å£ä»ç„¶æ˜¯ä» str1 çš„ç¬¬ä¸€ä¸ªå­—æ¯å¼€å§‹ï¼Œå¤§å°ä¸º 2ï¼Œå³ \u0026quot;1A\u0026quot;ï¼› çª—å£ \u0026quot;1A\u0026quot; ä¸åœ¨ str2 ä¸­ï¼Œå‘å³æ»‘åŠ¨çª—å£ï¼Œå˜æˆ \u0026quot;AB\u0026quot;ï¼› åŒç†ï¼Œå› ä¸º \u0026quot;AB\u0026quot; ä¸åœ¨ str2 ä¸­ï¼Œä¼šä¸€ç›´æ»‘åŠ¨ï¼ˆ\u0026quot;AB\u0026quot;-\u0026gt;\u0026quot;B2\u0026quot;-\u0026gt;\u0026quot;23\u0026quot;ï¼‰ï¼› çª—å£ \u0026quot;23\u0026quot; åœ¨ str2 ä¸­ï¼Œè®°å½•ä¸‹ç»“æœï¼ŒæŠŠçª—å£å˜å¤§ï¼Œæ­¤æ—¶çª—å£å˜æˆ \u0026quot;234\u0026quot;ï¼› åŒç†ï¼Œå› ä¸º \u0026quot;234\u0026quot; åœ¨ str2 ä¸­ï¼Œè®°å½•åçª—å£å˜æˆ \u0026quot;2345\u0026quot;ï¼Œè®°å½•ä¸‹ \u0026quot;2345\u0026quot; åï¼Œçª—å£æ‰©å¤§æˆ \u0026quot;2345C\u0026quot;ï¼› å› ä¸º \u0026quot;2345C\u0026quot; ä¸åœ¨ str2 ä¸­ï¼Œå‘å³æ»‘åŠ¨çª—å£ï¼Œå˜æˆ \u0026quot;345CD\u0026quot;ï¼› åŒæ · \u0026quot;345CD\u0026quot; ä¹Ÿä¸åœ¨ str2 ä¸­ï¼Œæ— æ³•å†æ»‘åŠ¨çª—å£ï¼Œæ•…è¿”å›æœ€åä¸€æ¬¡è®°å½• \u0026quot;2345\u0026quot;ã€‚  class Solution: def LCS(self , str1: str, str2: str) -\u0026gt; str: res, left = \u0026#34;\u0026#34;, 0 for i in range(len(str1)): if str1[left:i + 1] in str2: # è®°å½•ç»“æœï¼Œæ‰©å¤§çª—å£ res = str1[left:i + 1] else: # æ»‘åŠ¨çª—å£ left = left + 1 return res ç®—æ³•æ˜¾ç„¶æ˜¯æ­£ç¡®çš„ï¼Œå› ä¸ºæœ€é•¿çš„å…¬å…±å­ä¸²çš„é¦–å­—æ¯ï¼Œä¸€å®šä¼šè¢«æ»‘åŠ¨çª—å£æ»‘åˆ°ï¼ˆçª—å£æ˜¯ä¸€æ­¥ä¸€æ­¥å¾€å³æ»‘çš„ï¼‰ï¼Œç„¶åçª—å£ä¸æ–­å˜å¤§ï¼Œç›´åˆ°è¶…å‡ºèŒƒå›´ï¼ˆæˆ–åˆ°è¾¾æœ«ç«¯ï¼‰ä¸ºæ­¢ï¼Œå› ä¸ºæ˜¯æœ€é•¿çš„å­ä¸²ï¼Œåé¢ä¸€å®šä¸ä¼šå­˜åœ¨èƒ½æ‰©å¤§çª—å£çš„å­ä¸²ï¼Œæ•…ä¸€å®šè¿”å›æ­£ç¡®çš„ç»“æœã€‚\nå½“ç„¶ï¼Œæ£€æŸ¥çª—å£æ˜¯å¦åœ¨å­—ç¬¦ä¸²ä¸­éœ€è¦é«˜æ•ˆçš„åŒ¹é…ç®—æ³•ï¼Œå¦‚ Rabin-Karpï¼ŒKMP ç®—æ³•ç­‰ï¼ŒPython ç»“åˆä½¿ç”¨äº† Boyer-Moore ç®—æ³•å’Œ Boyer-Moore-Horspool ç®—æ³•ã€‚\nBM67 ä¸åŒè·¯å¾„çš„æ•°ç›®(ä¸€) æ˜¾ç„¶ $dp[i][j]=dp[i-1][j]+dp[i][j-1]$ï¼Œä¸è¿‡ä¸ºä»€ä¹ˆä¸ä½œå¼Šå‘¢ï¼Ÿä»»æ„ä¸€æ¡è·¯å¾„éƒ½éœ€è¦å¾€å³èµ° $m-1$ æ­¥ã€‚å¾€ä¸‹èµ° $n-1$ æ­¥ï¼Œä¸€å…± $m+n-2$ æ­¥ã€‚åè¿‡æ¥ï¼Œç¡®å®šäº†è¿™ $m+n-2$ æ­¥ä¸­å¾€å³èµ°æˆ–å¾€ä¸‹èµ°çš„ä½ç½®ï¼Œå°±ç¡®å®šäº†ä¸€æ¡è·¯å¾„ï¼Œæ•…è·¯å¾„çš„æ•°ç›®ä¸ºï¼š\n$$ \\binom{m + n - 2}{m - 1} = \\binom{m + n - 2}{n - 1} = \\frac{(m + n - 2) !}{(m - 1) ! (n - 1) !} = \\frac{m + n - 2}{1} \\frac{m + n - 3}{2} \\cdots \\frac{m}{n - 1} $$\nclass Solution: def uniquePaths(self , m: int, n: int) -\u0026gt; int: result = 1 for i in range(1, min(m, n)): result *= m + n - 1 - i result //= i # 2 / 1 = 2.0 return result # return math.comb(m + n - 2, m - 1) BM68 çŸ©é˜µçš„æœ€å°è·¯å¾„å’Œ $dp[i][j]=\\min(dp[i-1][j],dp[i][j-1])+a[i][j]$ï¼Œè¿˜è¦å¤„ç†ä¸€ä¸‹ $i=0$ å’Œ $j=0$ çš„æƒ…å½¢ï¼š\nclass Solution: def minPathSum(self , matrix: List[List[int]]) -\u0026gt; int: m, n = len(matrix), len(matrix[0]) for i in range(m): for j in range(n): if i == 0 and j == 0: pass elif i == 0: # ç¬¬ä¸€è¡Œ matrix[i][j] += matrix[i][j-1] elif j == 0: # ç¬¬ä¸€åˆ— matrix[i][j] += matrix[i-1][j] else: matrix[i][j] += min(matrix[i-1][j], matrix[i][j-1]) return matrix[m-1][n-1] BM69 æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸² ä¸€å¼€å§‹æ„Ÿè§‰æ— ä»ä¸‹æ‰‹ï¼Œåæ¥æ‰æƒ³æ˜ç™½ï¼Œå°±æ˜¯å¸¦æ¡ä»¶çš„è·³å°é˜¶ã€‚å‡è®¾ $s[i-1]s[i]$ è¿™ä¸¤ä½ä¸º $x$ï¼Œåˆ™ $x$ å­˜åœ¨äºŒä¹‰æ€§æ—¶ï¼Œ$dp[i]=dp[i-1]+dp[i-2]$ï¼Œå¦åˆ™ $dp[i]=dp[i-1]$ æˆ–è€… $dp[i]=dp[i-2]$ã€‚\nå‰‘æŒ‡ Offer ç¬¬46é¢˜ 0-\u0026gt;A, 25-\u0026gt;Zï¼Œå› æ­¤å­˜åœ¨äºŒä¹‰æ€§å½“ä¸”ä»…å½“ $x$ ä¸ä»¥ 0 å¼€å¤´ï¼Œå³ $x \\in [10,25]$ï¼Œå¦åˆ™ä»ä¸­é—´åˆ†å¼€è¯‘ç ï¼Œ$dp[i]=dp[i-1]$ã€‚ç„¶è€Œè¿™é¢˜æ²¡æœ‰è¿™ä¹ˆç®€å•ï¼Œéœ€è¦ä»”ç»†åˆ¤æ–­å„ç§æƒ…å†µï¼š\n $x \\in [11,19] \\cup [21,26]$ æ—¶ï¼Œæ˜¾ç„¶å­˜åœ¨äºŒä¹‰æ€§ï¼Œæ•… $dp[i]=dp[i-1]+dp[i-2]$ï¼› $x \\in \\{10,20\\}$ æ—¶ï¼Œä¸å­˜åœ¨äºŒä¹‰æ€§ï¼Œä¸éœ€è¦åˆ†å¼€è¯‘ç ï¼Œæ­¤æ—¶ $dp[i]=dp[i-2]$ï¼› å¦‚æœ $x$ ä»¥ 0 ç»“å°¾ï¼ˆ00,30,...,90ï¼‰ï¼Œåˆ™æ²¡æœ‰è¯‘ç ç»“æœï¼Œæ­¤æ—¶ç›´æ¥è¿”å› 0ï¼› å¦åˆ™ï¼ˆ01-09,27-29,...,91-99ï¼‰æ²¡æœ‰äºŒä¹‰æ€§ï¼Œæ­¤æ—¶è¦ä»ä¸­é—´åˆ†å¼€è¯‘ç ï¼Œ$dp[i]=dp[i-1]$ã€‚  æ­¤å¤–ï¼Œä»¥ 0 å¼€å¤´çš„å­—ç¬¦ä¸²ä¹Ÿæ²¡æœ‰è¯‘ç ç»“æœã€‚\nclass Solution: def solve(self , nums: str) -\u0026gt; int: tmp, n = 1, len(nums) for i in range(n): if i == 0: if nums[i] != 0: result = tmp # tmp ç¼“å­˜ dp[i-1] çš„ç»“æœ else: # ç¬¬ä¸€ä½ä¸º 0ï¼Œ æ²¡æœ‰è¯‘ç ç»“æœ result = 0 break else: # n \u0026gt;= 2 if 11 \u0026lt;= int(nums[i-1:i+1]) \u0026lt;= 19 or 21 \u0026lt;= int(nums[i-1:i+1]) \u0026lt;= 26 : tmp, result = result, result + tmp # dp[i]=dp[i-1]+dp[i-2] elif int(nums[i-1:i+1]) in (10, 20): tmp, result = result, tmp # dp[i]=dp[i-2] elif nums[i] != \u0026#34;0\u0026#34;: tmp = result # dp[i]=dp[i-1] else: result = 0 break return result BM70 å…‘æ¢é›¶é’±(ä¸€) å‡å¦‚çº¸å¸é¢å€¼ä¸º [2,3,5]ï¼Œæ˜¾ç„¶ $dp[i] = \\min(dp[i-2], dp[i-3], dp[i-5]) + 1$ï¼Œåªè¦æ³¨æ„ï¼š\n å¯èƒ½ä¼šå‡ºç°æ— æ³•å…‘æ¢çš„æƒ…å½¢ï¼Œè¿™æ—¶å°±éœ€è¦æŠŠ $dp[i]$ è®¾ç½®æˆä¸€ä¸ªä¸å¯èƒ½å–åˆ°çš„ç‰¹æ®Šå€¼ï¼Œæ¯”å¦‚ aim+1ï¼ˆaim è¡¨ç¤ºè¦å…‘æ¢çš„æ€»é¢ï¼‰ï¼Œå¦‚æœæœ€ç»ˆç»“æœå¤§äºç­‰äºè¿™ä¸ªæ•°ï¼Œè¯´æ˜æ— æ³•å…‘æ¢ï¼› å¦‚ä½•åˆå§‹åŒ–ï¼Ÿç±»ä¼¼ä¸Šé¢çš„åšæ³•ï¼ŒæŠŠé¢„ç•™çš„ä½ç½®åˆå§‹åŒ–ä¸º aim+1 å³å¯ï¼Œæ­¤å¤–è¿˜è¦æ³¨æ„ $dp[0]=0$ã€‚  class Solution: def minMoney(self , arr: List[int], aim: int) -\u0026gt; int: if not arr: return -1 from collections import deque arr = sorted(arr) dp = deque([aim + 1] * (arr[-1] - 1) + [0]) # dp[0] = 0 for i in range(aim): dp.append(min(dp[-j] for j in arr) + 1) dp.popleft() return dp[-1] if dp[-1] \u0026lt; (aim + 1) else -1 BM71 æœ€é•¿ä¸Šå‡å­åºåˆ—(ä¸€) æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’ è™½ç„¶å·²ç»åšäº†å¾ˆå¤šåŠ¨æ€è§„åˆ’é¢˜ï¼Œä½†è¿˜æ˜¯æ— ä»ä¸‹æ‰‹ğŸ˜‚\né¦–å…ˆè‡ªç„¶æ˜¯æ€è€ƒ $dp$ æ˜¯è®°å½•ä»€ä¹ˆçŠ¶æ€çš„æ•°ç»„ï¼Œç”±é¢˜æ„ä¸å¦¨å‡è®¾ $dp[i]$ æ˜¯ä»å¼€å¤´åˆ°ç¬¬ i ä¸ªå­—ç¬¦çš„æœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦ã€‚é‚£ä¹ˆå¦‚ä½•ä» $dp[i]$ åˆ° $dp[i+1]$ å‘¢ï¼Ÿéœ€è¦ç­›é€‰å‡º $arr[i+1]$ å‰é¢æ‰€æœ‰ä¸¥æ ¼æ¯” $arr[i+1]$ å°çš„å…ƒç´ ï¼Œå¹¶è®°å½•ä¸‹æ ‡ $k_1,k_2,...$ï¼Œäºæ˜¯ $dp[i+1]=\\max(dp[k_1], dp[k_2],...) + 1$ï¼›å¦‚æœä¸å­˜åœ¨ä¸¥æ ¼å°çš„å…ƒç´ ï¼Œ$dp[i+1]=1$ã€‚\nä¸¤ç§æƒ…å†µåˆèµ·æ¥å°±æ˜¯ $dp[i+1]=\\max(dp[k_1] + 1, dp[k_2] + 1,...,1)$ï¼Œæœ€åè¿”å› $dp$ æ•°ç»„çš„æœ€å¤§å€¼ã€‚\nclass Solution: def LIS(self , arr: List[int]) -\u0026gt; int: dp = [1] * len(arr) for i in range(len(arr)): for j in range(i): if arr[j] \u0026lt; arr[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) if dp else 0 æ–¹æ³•äºŒï¼šè´ªå¿ƒäºŒåˆ†æŸ¥æ‰¾ å¦‚æœ $a[k_1], a[k_2], \\dots, a[k_n]$ æ˜¯æœ€é•¿çš„ä¸Šå‡å­åºåˆ—ï¼Œé‚£ä¹ˆ $a[k_1], a[k_2], \\dots, a[k_{n-1}]$ çš„å€¼åº”è¯¥å°½å¯èƒ½çš„å°ã€‚äºæ˜¯å¯ä»¥ç»´æŠ¤ä¸€ä¸ªæ•°ç»„ $d[i]$ï¼Œåœ¨éå† arr æ—¶è®°å½•é•¿åº¦ä¸º $i$ çš„ä¸Šå‡å­åºåˆ—ä¸­ï¼Œæœ«ä½æ•°å­—çš„æœ€å°å€¼ï¼Œå¦‚ [1,5,3,2,4] å¯¹åº”çš„ $d[i]$ ä¸º [1] -\u0026gt; [1,5] -\u0026gt; [1,3] -\u0026gt; [1,2] -\u0026gt; [1,2,4]ã€‚æ›´è¯¦ç»†åœ°è¯´ï¼š\n $d[i]$ ä¸€ç›´æ˜¯é€’å¢çš„ï¼Œå› ä¸ºå¦‚æœå­˜åœ¨åé¢çš„å…ƒç´ æ¯”å‰é¢çš„å°ï¼Œè¯´æ˜å­˜åœ¨æ›´é•¿çš„æœ«ä½æ•°å­—æ›´å°çš„ä¸Šå‡å­åºåˆ—ï¼Œåˆ æ‰è¯¥åºåˆ—ä¸€éƒ¨åˆ†å…ƒç´ å°±å¼•å‡ºäº†çŸ›ç›¾ï¼› å½“ $arr[i]$ å¤§äº $d[i]$ æœ€åä¸€ä½æ—¶ï¼Œè¯´æ˜å­˜åœ¨æ›´é•¿çš„ä¸Šå‡å­åºåˆ—ï¼ŒæŠŠ $arr[i]$ åŠ å…¥ $d[i]$ æœ«å°¾ï¼› å½“ $arr[i]$ å°äº $d[i]$ æŸä¸ªå…ƒç´ ï¼Œæ¯”å¦‚ $d[i]=[1,2,4,6,7],arr[i]=3$ï¼Œæ˜¾ç„¶ [1,2,3] æ˜¯æœ«å°¾æ•°å­—æ›´å°çš„é•¿åº¦ä¸º 3 çš„ä¸Šå‡å­åºåˆ—ï¼Œä»¤ $d[3]=arr[i] \\Rightarrow d[i]=[1,2,3,6,7]$ã€‚  ç¬¬ä¸‰æ­¥éœ€è¦ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œæœ€åè¿”å›æ•°ç»„ $d[i]$ çš„é•¿åº¦å³å¯ã€‚å¥½ä¹…æ²¡å†™äºŒåˆ†æŸ¥æ‰¾äº†ï¼Œå¿ƒæƒŠèƒ†æˆ˜å†™å®Œæ²¡æƒ³åˆ°ä¸€éè¿‡ğŸ˜‚\nclass Solution: def LIS(self , arr: List[int]) -\u0026gt; int: d = [] for i in range(len(arr)): if not d or arr[i] \u0026gt; d[-1]: d.append(arr[i]) elif arr[i] \u0026lt; d[-1]: left, right = 0, len(d) - 1 while left \u0026lt; right: mid = (left + right) // 2 if arr[i] \u0026lt; d[mid]: right = mid elif arr[i] \u0026gt; d[mid]: left = mid + 1 else: left = right = mid d[left] = arr[i] return len(d) BM72 è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ ç®€å•å¾—éš¾ä»¥ç½®ä¿¡ï¼å‡è®¾ $dp[i]$ è¡¨ç¤ºä»¥ç¬¬ i ä¸ªå…ƒç´ ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œï¼Œå³\n$$dp[i] = \\max(arr[i], arr[i]+arr[i-1],\\dots,\\sum_{j=1}^{i}arr[j])$$\næ˜¾ç„¶ï¼š\n$$ \\begin{array}{lll} d p [i + 1] \u0026amp; = \u0026amp; \\max (a r r [i + 1], a r r [i + 1] + a r r [i], \\ldots, \\sum_{j = 1}^{i + 1} a r r [j])\\newline \u0026amp; = \u0026amp; \\max \\left( a r r [i + 1], \\max \\left( a r r [i + 1] + a r r [i], \\ldots, \\sum_{j = 1}^{i + 1} a r r [j] \\right) \\right)\\newline \u0026amp; = \u0026amp; \\max \\left( a r r [i + 1], a r r [i + 1] + \\max \\left( a r r [i], \\ldots, \\sum_{j = 1}^i a r r [j] \\right) \\right)\\newline \u0026amp; = \u0026amp; \\max (a r r [i + 1], a r r [i + 1] + d p [i]) \\end{array} $$\nclass Solution: def FindGreatestSumOfSubArray(self , arr: List[int]) -\u0026gt; int: dp, result = 0, arr[0] for num in arr: dp = max(num, dp + num) result = max(dp, result) return result BM73 æœ€é•¿å›æ–‡å­ä¸² æ–¹æ³•ä¸€ï¼šä¸­å¿ƒæ‰©æ•£ ä»å·¦åˆ°å³éå†å­—ç¬¦ä¸²ï¼ŒæŠŠæ¯ä¸ªå­—ç¬¦å½“ä½œå›æ–‡å­ä¸²çš„ä¸­å¿ƒï¼Œå°è¯•å‘å·¦å³æ‰©æ•£ï¼Œæ³¨æ„è¦åŒºåˆ†å­ä¸²é•¿åº¦ä¸ºå¥‡æ•°å’Œå¶æ•°ä¸¤ç§æƒ…å†µã€‚\nclass Solution: def getLongestPalindrome(self , A: str) -\u0026gt; int: def expand(A, left, right): while 0 \u0026lt;= left and right \u0026lt; len(A) and A[left] == A[right]: left, right = left - 1, right + 1 return right - left - 1 result = 1 for i in range(len(A) - 1): result = max(result, expand(A, i, i), expand(A, i, i + 1)) return result æ–¹æ³•äºŒï¼šåŠ¨æ€è§„åˆ’ å¦‚æœ $dp[i][j]$ è¡¨ç¤ºç¬¬ i ä¸ªå­—ç¬¦åˆ°ç¬¬ j ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºå›æ–‡å­ä¸²ï¼š\n$$ d p [i] [j] = \\left\\{ \\begin{array}{ll} \\text{False} \u0026amp; i \u0026gt; j\\newline \\text{True} \u0026amp; i = j\\newline (A_i = = A_j) \u0026amp; i + 1 = j\\newline d p [i + 1] [j - 1] \\wedge (A_i = = A_j) \u0026amp; i + 1 \u0026lt; j \\end{array} \\right. $$\nåœ¨å®ç°ä¸Šï¼Œå¯ä»¥æŠŠ False è®°ä¸º 0ï¼ŒTrue è®°ä¸ºå›æ–‡å­ä¸²çš„é•¿åº¦ï¼Œå³ï¼š\n$$ d p [i] [j] = \\left\\{ \\begin{array}{ll} 0 \u0026amp; i \u0026gt; j \\vee (A_i \\neq A_j)\\newline 1 \u0026amp; i = j\\newline 2 \u0026amp; i + 1 = j \\wedge (A_i = = A_j) \\newline d p [i + 1] [j - 1] + 2 \u0026amp; i + 1 \u0026lt; j \\wedge (A_i = = A_j) \\wedge d p [i + 1] [j - 1] \u0026gt; 0 \\newline 0 \u0026amp; i + 1 \u0026lt; j \\wedge (A_i = = A_j) \\wedge d p [i + 1] [j - 1] = 0 \\end{array} \\right. $$\nç„¶åä»æœ€ä¸‹é¢ä¸€è¡Œå¼€å§‹å¾€ä¸Šéå†ï¼š\nclass Solution: def getLongestPalindrome(self , A: str) -\u0026gt; int: result, dp = 0, [0] * len(A) for i in range(len(A) - 1, -1, -1): # åè¿‡æ¥éå† for j in range(len(A) - 1, -1, -1): # ä¹Ÿæ˜¯åè¿‡æ¥ if i \u0026gt; j or A[i] != A[j]: dp[j] = 0 elif i == j: dp[j] = 1 elif (i + 1) == j: dp[j] = 2 elif dp[j-1] \u0026gt; 0: dp[j] = dp[j-1] + 2 else: dp[j] = 0 result = max(dp[j], result) if i == j: break # å‰é¢éƒ½æ˜¯ 0ï¼Œä¸ç”¨ç®—äº† return result æ–¹æ³•ä¸‰ï¼šManacher ç®—æ³• Manacher ç®—æ³•å…¶å®å¹¶ä¸å¤æ‚ï¼Œå¯æ˜¯å°±æ˜¯çœ‹äº†å¥½ä¹…â€¦â€¦ä¹Ÿä¸ç¡®å®šèƒ½ä¸èƒ½è®²æ¸…æ¥šğŸ˜‚\nManacher ç®—æ³•æ˜¯ä¸­å¿ƒæ‰©æ•£æ³•çš„æ”¹è¿›ç‰ˆï¼š\n é€šè¿‡æ·»åŠ æ— æ„ä¹‰ç¬¦åˆ \u0026quot;#\u0026quot; æŠŠå¥‡æ•°å’Œå¶æ•°çš„æƒ…å†µç»Ÿä¸€å¤„ç†ï¼› åœ¨éå†è®¡ç®—ä»¥ i ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²é•¿åº¦æ—¶ï¼Œä½¿ç”¨ i ä¹‹å‰çš„ç»“æœåŠ é€Ÿæ‰©æ•£ã€‚  ç¬¬ä¸€ç‚¹æ¯”è¾ƒå®¹æ˜“ï¼Œæˆ‘ä»¬å¯ä»¥åˆ†åˆ«è€ƒå¯Ÿå¥‡æ•°å›æ–‡ \u0026quot;aba\u0026quot; -\u0026gt; \u0026quot;#a#b#a#\u0026quot; å’Œå¶æ•°å›æ–‡ \u0026quot;abba\u0026quot; -\u0026gt; \u0026quot;#a#b#b#a#\u0026quot;ï¼Œå¯ä»¥çœ‹åˆ°å…¨éƒ¨éƒ½å˜æˆäº†å¥‡æ•°å›æ–‡ï¼Œä¸”è‹¥åŸå›æ–‡é•¿åº¦ä¸º nï¼Œæ–°çš„å›æ–‡é•¿åº¦å°±æ˜¯ 2n+1ã€‚\nç¬¬äºŒç‚¹å¯èƒ½æœ‰ç‚¹éš¾ï¼Œä¸ºæ­¤å¼•å…¥äº†â€œè‡‚å±•â€çš„æ¦‚å¿µï¼Œåœ¨éå†æ¯ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œè®°å½•ä¸‹å…¶ï¼ˆæ–°ï¼‰å›æ–‡å­ä¸²çš„è‡‚å±•é•¿åº¦ï¼ˆæ°å¥½å’ŒåŸæ¥çš„å­ä¸²é•¿åº¦ç›¸ç­‰ï¼‰ã€‚å¦‚æœ i åœ¨ä¹‹å‰æŸä¸ªå…ƒç´  j çš„è‡‚å±•å†…ï¼Œåˆ™ä¸ i å¯¹ç§°çš„å…ƒç´  i_sym = 2 * j - i ä¹Ÿåœ¨ j çš„è‡‚å±•å†…ã€‚å‡è®¾ä»¥ j ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²ä¸º [left, right]ï¼Œåˆ™ï¼š\n å¦‚æœ j å’Œ left éƒ½ä¸åœ¨ i_sym çš„è‡‚å±•é•¿åº¦ä»¥å†…ï¼Œåˆ™ç”±å¯¹ç§°æ€§ï¼Œi çš„è‡‚å±•è‡³å°‘ä¸º armlen[i_sym]ï¼Œå¯ä»¥ä» i - armlen[i_sym], i + armlen[i_sym] å¼€å§‹æ‰©æ•£ï¼› å¦‚æœ j åœ¨ i_sym çš„è‡‚å±•é•¿åº¦ä»¥å†…è€Œ left ä¸åœ¨ï¼Œåˆ™ç”±å¯¹ç§°æ€§ï¼Œi çš„è‡‚å±•è‡³å°‘ä¸º armlen[i_sym]ï¼Œå¯ä»¥ä» i - armlen[i_sym], i + armlen[i_sym] å¼€å§‹æ‰©æ•£ï¼› å¦‚æœ left åœ¨ i_sym çš„è‡‚å±•é•¿åº¦ä»¥å†…è€Œ j ä¸åœ¨ï¼Œåˆ™ç”±å¯¹ç§°æ€§ï¼Œi çš„è‡‚å±•è‡³å°‘ä¸º right - iï¼Œå¯ä»¥ä» i - (right - i), i + (right - i) å¼€å§‹æ‰©æ•£ï¼› å¦‚æœ j å’Œ left éƒ½åœ¨ i_sym çš„è‡‚å±•é•¿åº¦ä»¥å†…ï¼Œåˆ™ç”±å¯¹ç§°æ€§ï¼Œi çš„è‡‚å±•è‡³å°‘ä¸º right - iï¼Œå¯ä»¥ä» i - (right - i), i + (right - i) å¼€å§‹æ‰©æ•£ã€‚  æ— è®ºæ˜¯å“ªä¸€ç§æƒ…å†µï¼Œåªè¦å– min_arm_len = min(arm_len[i_sym], right - i)ï¼Œå†ä» i - min_arm_len, i + min_arm_len å¼€å§‹æ‰©å±•å³å¯ã€‚\næœ€åå°±æ˜¯ j çš„é€‰æ‹©ï¼Œä¸ºäº†å‡å°‘æ‰©æ•£åŒ¹é…çš„æ¬¡æ•°ï¼ˆæœ€å¤§åŒ– right - iï¼‰ï¼Œåº”é€‰æ‹©ä½¿å½“å‰ right è¾¾åˆ°æœ€å¤§çš„ jã€‚\nclass Solution: def getLongestPalindrome(self , A: str) -\u0026gt; int: def expand(A, left, right): while 0 \u0026lt;= left and right \u0026lt; len(A) and A[left] == A[right]: left, right = left - 1, right + 1 return (right - left - 1 - 1) // 2 A = \u0026#34;#{}#\u0026#34;.format(\u0026#34;#\u0026#34;.join(A)) arm_len = [] result = 0 right = -1 j = -1 for i in range(len(A)): if right \u0026gt;= i: # æ˜¯å›æ–‡ä¸²ä¸­å¿ƒ i_sym = 2 * j - i # i å…³äº j çš„å¯¹ç§°ç‚¹ min_arm_len = min(arm_len[i_sym], right - i) cur_arm_len = expand(A, i - min_arm_len, i + min_arm_len) else: cur_arm_len = expand(A,i,i) arm_len.append(cur_arm_len) if i + cur_arm_len \u0026gt; right: j = i right = i + cur_arm_len result = max(result, cur_arm_len) return result BM74 æ•°å­—å­—ç¬¦ä¸²è½¬åŒ–æˆIPåœ°å€ ç™½æƒ³äº†åŠå°æ—¶åŠ¨æ€è§„åˆ’åè¢«ä¸Šäº†ä¸€è¯¾ï¼Œå…¶å®æ ¹æœ¬ä¸éœ€è¦ç®—æ³•ï¼ˆå› ä¸ºæ•°æ®é‡æœ‰é™ï¼‰ï¼Œç”¨ç©·ä¸¾å°±å¯ä»¥åšğŸ˜‚\nå…¶å®å°±æ˜¯é€‰æ‹© 3 ä¸ªå°æ•°ç‚¹çš„ä½ç½®ï¼Œç¬¬ä¸€ä¸ªå°æ•°ç‚¹åªèƒ½åœ¨ 2,3,4 ä½ï¼Œåä¸¤ä¸ªåªèƒ½åœ¨å‰ä¸€ä¸ªçš„å 1,2,3 ä½ä¸Šï¼Œåªè¦å†™ä¸‰å±‚ for å¾ªç¯å³å¯ï¼š\nclass Solution: def restoreIpAddresses(self , s: str) -\u0026gt; List[str]: if len(s) \u0026lt; 4 or len(s) \u0026gt; 12 or (not s.isdigit()): return [] result = [] def valid(num): return (len(num) == 1) or (2 \u0026lt;= len(num) \u0026lt;= 3 and num[0] != \u0026#34;0\u0026#34; and int(num) \u0026lt; 256) for i in range(1, min(4, len(s) - 2)): if valid(s[:i]): for j in range(i + 1, min(i + 4,len(s) - 1)): if valid(s[i:j]): for k in range(j + 1, min(j + 4, len(s))): if valid(s[j:k]) and valid(s[k:]): result.append(s[:i] + \u0026#34;.\u0026#34; + s[i:j] + \u0026#34;.\u0026#34; + s[j:k] + \u0026#34;.\u0026#34; + s[k:]) return result BM75 ç¼–è¾‘è·ç¦»(ä¸€) å‡è®¾ $dp[i][j]$ è¡¨ç¤ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å‰ i ä½ä¸ç¬¬äºŒä¸ªå­—ç¬¦ä¸²å‰ j ä½çš„ç¼–è¾‘è·ç¦»ï¼Œåˆ™ï¼š\n å¦‚æœ i=0 æˆ– j=0ï¼Œè¯´æ˜å…¶ä¸­ä¸€ä¸ªï¼ˆå­ä¸²ï¼‰æ˜¯ç©ºå­—ç¬¦ä¸²ï¼Œç¼–è¾‘è·ç¦»ç­‰äºå¦ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆå­ä¸²ï¼‰çš„é•¿åº¦ï¼› å¦åˆ™ï¼Œå¦‚æœ s1[i]=s2[j]ï¼Œåˆ™ $dp[i][j]=dp[i-1][j-1]$ï¼› æœ€åï¼Œå¦‚æœ s1[i]!=s2[j]ï¼Œç”±ç¼–è¾‘è·ç¦»çš„å®šä¹‰ï¼Œå‡è®¾è¦æŠŠå­ä¸² s1[0:i] å˜æˆ s2[0:j]ï¼Œs1[0:i] çš„æœ€åä¸€ä½å¿…ç„¶ä¼šå—åˆ°å½±å“ï¼Œå¯ä»¥æƒ³åƒä¸€ä¸‹æŒ‰ç…§æœ€ä¼˜çš„ç¼–è¾‘è¿‡ç¨‹æŠŠä¸¤ä¸ªå­—ç¬¦ä¸²è¿›è¡Œå¯¹é½ï¼ˆä¸å”¯ä¸€ï¼‰ï¼š  å› æ­¤ä»¥ä¸‹çš„æƒ…å†µå¿…ç„¶ä¼šå‡ºç°ä¸€ç§ï¼Œè€Œä¸”ä¸å¯¹å…¶ä»–ä½ç½®çš„ç¼–è¾‘ç›¸äº’ç‹¬ç«‹ï¼š\n s2[j] ä½äºæœ€å³ï¼Œæ²¡æœ‰åŒ¹é…åˆ°ä»»ä½•å­—æ¯ï¼Œæ­¤æ—¶æŠŠ s2[j] æ·»åŠ åˆ°æœ€åä¸€ä½ï¼Œä»è€Œ s1[i+1]=s2[j]ï¼Œå¯¹åº”çš„ç¼–è¾‘è·ç¦»ä¸º $dp[i][j-1]+1$ï¼› s1[i] ä½äºæœ€å³ï¼Œæ²¡æœ‰åŒ¹é…åˆ°ä»»ä½•å­—æ¯ï¼Œæ­¤æ—¶åˆ é™¤ s1[i]ï¼Œç¼–è¾‘è·ç¦»ä¸º $dp[i-1][j]+1$ï¼› s1[i] ä¸ s2[j] é…å¯¹æˆåŠŸï¼Œæ­¤æ—¶æ›¿æ¢ s1[i] ä¸º s2[j]ï¼Œç¼–è¾‘è·ç¦»ä¸º $dp[i-1][j-1]+1$ã€‚  å¯ä»¥å¡«è¡¨åŠ æ·±ç†è§£ï¼š\nclass Solution: def editDistance(self , str1: str, str2: str) -\u0026gt; int: dp = list(range(len(str2) + 1)) for i in range(len(str1)): tmp = dp.copy() # dp åœ¨ç¬¬ i-1 è¡Œçš„ç»“æœ dp[0] = i + 1 for j in range(len(str2)): if str1[i] == str2[j]: dp[j + 1] = tmp[j] else: dp[j + 1] = 1 + min(tmp[j + 1], tmp[j], dp[j]) return dp[-1] BM76 æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… å—¯å—¯ï¼Œå°±æ˜¯ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¿›è¡ŒåŒ¹é…å˜›ï¼š\nclass Solution: def match(self , s: str, p: str) -\u0026gt; bool: from re import search return bool(search(r\u0026#34;^\u0026#34; + p + r\u0026#34;$\u0026#34;, s)) çœ‹ä¸Šå»ä¸éš¾ï¼Œä½†åŠ¨æ‰‹å°±ä¼šå‘ç°å¹¶ä¸å¥½å†™ğŸ˜‚å› ä¸º * å¯ä»¥åŒ¹é… 0 æ¬¡æˆ–æ— ç©·æ¬¡ï¼Œè¿™å°±æ„å‘³ç€ ba*s å¯ä»¥åŒ¹é… bas, baas, baaas, ... ä¹Ÿå¯ä»¥ç›´æ¥ä¸¢å¼ƒï¼Œå³åŒ¹é… bs, bsa, ...ï¼Œé™¤æ­¤ä¹‹å¤–è¿˜è¦å¤„ç† .*ã€a*a è¿™äº›æ£˜æ‰‹çš„æƒ…å½¢â€¦â€¦\nä¸€èˆ¬çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å®ç°éå¸¸å¤æ‚ï¼Œä¸èƒ½ä½¿ç”¨åŠ¨æ€è§„åˆ’1ï¼Œæ‰€ä»¥è¿˜æ˜¯ç›´æ¥æŠ„é¢˜è§£å§ğŸ˜‚\nå‡è®¾ $dp[i][j]$ è¡¨ç¤ºå­—ç¬¦ä¸² s å‰ i ä¸ªå­—ç¬¦æ˜¯å¦åŒ¹é…æ¨¡å¼ p å‰ j ä¸ªå­—ç¬¦ï¼Œè¿™é‡ŒåŒ¹é…çš„æ„æ€æ˜¯é…å¯¹ï¼Œå³å­—ç¬¦ä¸²å®Œç¾ç¬¦åˆæ•´ä¸ªæ¨¡å¼ï¼Œåˆ™ï¼š\n å¦‚æœ $p[j]$ æ˜¯å°å†™å­—æ¯ï¼ˆæˆ– .ï¼‰ï¼Œæ˜¾ç„¶ï¼š  $$ d p [i] [j] = \\left\\{ \\begin{array}{ll} d p [i - 1] [j - 1] \u0026amp; s [i] = p [j]\\newline \\text{False} \u0026amp; s [i] \\neq p [j] \\end{array} \\right. $$\n å¦‚æœ $p[j]$ æ˜¯ *ï¼Œåˆ™æ„å‘³ç€ $p[j-1]$ å¯ä»¥å‡ºç° 0 æ¬¡æˆ–ä»»æ„æ¬¡ï¼Œæ­¤æ—¶æŠŠ $p[j-1]p[j]$ çœ‹æˆä¸€ä¸ªæ•´ä½“ã€‚å¦‚æœ $s[i]=p[j-1]$ï¼ˆæˆ–è€… $p[j-1]$ æ˜¯ .ï¼‰ï¼Œå’Œä¸Šé¢ç±»ä¼¼ï¼Œè¯´æ˜æ¨¡å¼ $p[j-1]p[j]$ åŒ¹é…åˆ°äº† $s[i]$ï¼Œè¿™æ—¶æœ‰ä¸‰ç§å¯èƒ½ï¼š   å‰é¢ä¾ç„¶æœ‰æ¨¡å¼ $p[j-1]p[j]$ å¯ä»¥åŒ¹é…åˆ°çš„å­—ç¬¦ï¼Œæ­¤æ—¶ç»“æœä¸º $dp[i-1][j]$ï¼› å‰é¢æ²¡æœ‰æ¨¡å¼ $p[j-1]p[j]$ å¯ä»¥åŒ¹é…åˆ°çš„å­—ç¬¦ï¼Œå¯¹åº”çš„ç»“æœä¸º $dp[i-1][j-2]$ï¼› æˆ–è€…å¹¶ä¸éœ€è¦è¿›è¡ŒåŒ¹é…ï¼ˆå³ $p[j-1]$ å‡ºç° 0 æ¬¡ï¼‰ï¼Œå¯¹åº”çš„ç»“æœæ˜¯ $dp[i][j-2]$ã€‚  å¦‚æœ $s[i] \\neq p[j-1]$ï¼Œæ˜¾ç„¶å”¯ä¸€çš„å¯èƒ½æ˜¯ $p[j-1]$ å‡ºç° 0 æ¬¡ï¼Œå¯¹åº”çš„ç»“æœæ˜¯ $dp[i-2][j]$ã€‚\nå¦‚æœå†ä»”ç»†æƒ³æƒ³å°±ä¼šå‘ç°ï¼Œä¸Šé¢ç¬¬ 2 ç§æƒ…å†µå…¶å®å·²ç»è¢«ç¬¬ 1 ç§æƒ…å†µè¦†ç›–ï¼ˆåŒ¹é… 0 æ¬¡ä¹Ÿæ˜¯ç¬¦åˆæ¨¡å¼ï¼‰ï¼Œå› æ­¤çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š\n$$ d p [i] [j] = \\left\\{ \\begin{array}{ll} d p [i - 1] [j] \\hspace{0.5em} \\text{or} \\hspace{0.5em} d p [i] [j - 2] \u0026amp; s [i] = p [j - 1]\\newline d p [i] [j - 2] \u0026amp; s [i] \\neq p [j - 1] \\end{array} \\right. $$\næœ€åè¿˜è¦å¤„ç†å¥½åˆå§‹åŒ–çš„æƒ…å½¢ï¼Œä½¿ç”¨ç©ºå­—ç¬¦ä¸²å¯¹æ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼š\n ç©ºå­—ç¬¦ä¸²åŒ¹é…ç©ºæ¨¡å¼ï¼Œå› æ­¤ $dp[0][0] = \\text{True}$ï¼› å¦‚æœ p[j]==\u0026quot;*\u0026quot;ï¼Œå°±æœ‰ $dp[0][j] = dp[0][j-2]$ï¼Œå¦åˆ™ $dp[0][j]=\\text{False}$ã€‚  class Solution: def match(self , s: str, p: str) -\u0026gt; bool: m, n = len(s), len(p) dp = [True] + [False] * n for j in range(n): dp[j + 1] = dp[j - 1] if p[j] == \u0026#34;*\u0026#34; else False for i in range(m): tmp = dp.copy() # dp åœ¨ i - 1 è¡Œçš„ç»“æœ dp[0] = False for j in range(n): if not p[j] == \u0026#34;*\u0026#34;: if p[j] == \u0026#34;.\u0026#34; or s[i] == p[j]: dp[j + 1] = tmp[j] #dp[i][j]=dp[i-1][j-1] else: dp[j + 1] = False else: if p[j-1] == \u0026#34;.\u0026#34; or s[i] == p[j - 1]: dp[j + 1] |= dp[j - 1] #dp[i][j]=dp[i-1][j] or dp[i][j-2] else: dp[j + 1] = dp[j - 1] return dp[n] BM77 æœ€é•¿çš„æ‹¬å·å­ä¸² æ–¹æ³•ä¸€ï¼šæ ˆ ç†æ¸…é€»è¾‘ä¹‹åå…¶å®ä¸éš¾å†™ï¼š\n ä½¿ç”¨æ ˆè®°å½•å·¦æ‹¬å·ä¸‹æ ‡ï¼› éå†å­—ç¬¦ä¸²ï¼Œé‡åˆ°å·¦æ‹¬å·å…¥æ ˆï¼› å¦‚æœé‡åˆ°å³æ‹¬å·ï¼Œä¸”æ ˆä¸ä¸ºç©ºï¼Œåˆ™å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œå¦‚æœæ­¤æ—¶æ ˆä»ä¸ä¸ºç©ºï¼Œå­ä¸²çš„é•¿åº¦ä¸º i - æ­¤æ—¶çš„æ ˆé¡¶åæ ‡ï¼› å¦‚æœä¸Šä¸€æ­¥å¼¹å‡ºåæ ˆä¸ºç©ºä¼šæ— æ³•è®¡ç®—å­ä¸²é•¿åº¦ï¼Œå› æ­¤è¿˜éœ€è¦è®°å½•å…¥æ ˆå‰æœ€åä¸€ä¸ªå³æ‹¬å·çš„ä¸‹æ ‡ startã€‚å¦‚æœæ ˆä¸ºç©ºä¸”å­—ç¬¦ä¸ºå³æ‹¬å·ï¼Œæ›´æ–° start çš„å€¼ã€‚  class Solution: def longestValidParentheses(self , s: str) -\u0026gt; int: stack, start, result = [], -1, 0 for i in range(len(s)): if s[i] == \u0026#34;(\u0026#34;: stack.append(i) else: if stack: stack.pop() if stack: result = max(result, i - stack[-1]) else: result = max(result, i - start) else: start = i return result æ–¹æ³•äºŒï¼šåŠ¨æ€è§„åˆ’ æœ‰ç§ä¸º DP è€Œ DP çš„æ„Ÿè§‰ğŸ˜‚ $dp[i]$ è®°å½•çš„æ˜¯ä»¥ s[i] ä½œä¸ºç»“å°¾çš„æœ€é•¿æœ‰æ•ˆå­ä¸²é•¿åº¦ï¼Œæ˜¾ç„¶ï¼š\n å¦‚æœ s[i] æ˜¯å·¦æ‹¬å·ï¼Œå› ä¸ºæ²¡æœ‰æœ‰æ•ˆå­ä¸²ä»¥å·¦æ‹¬å·ç»“å°¾ï¼Œ$dp[i]=0$ï¼› å¦‚æœ s[i] æ˜¯å³æ‹¬å·ï¼Œéœ€è¦åˆ†æƒ…å†µè®¨è®ºï¼š å¦‚æœ s[i-1] æ˜¯å·¦æ‹¬å·ï¼Œåˆ™æ˜¾ç„¶ $dp[i] = dp[i-2] + 2$ï¼› å¦‚æœ s[i-1] æ˜¯å³æ‹¬å·ï¼Œå°±éœ€è¦æ£€æŸ¥ä»¥ s[i-1] ä¸ºç»“å°¾çš„æœ€é•¿æœ‰æ•ˆå­ä¸²å‰é¢çš„å…ƒç´  s[i-1-dp[i-1]] æ˜¯ä¸æ˜¯å·¦æ‹¬å·ï¼Œå¦‚æœæ˜¯å°±æœ‰ $dp[i] = dp[i-1] + 1 + dp[i-2-dp[i-1]]$ï¼Œå¦åˆ™ $dp[i] = 0$ã€‚  class Solution: def longestValidParentheses(self , s: str) -\u0026gt; int: dp, result = [0] * (len(s) + 1), 0 for i in range(len(s)): if i \u0026gt; 0 and s[i - 1: i + 1] == \u0026#34;()\u0026#34;: dp[i + 1] = dp[i - 1] + 2 result = max(result, dp[i + 1]) elif i \u0026gt; 0 and s[i - 1: i + 1] == \u0026#34;))\u0026#34;: if i - 1 - dp[i] \u0026gt;= 0 and s[i - 1 - dp[i]] == \u0026#34;(\u0026#34;: dp[i + 1] = dp[i] + 2 + dp[i - 1 - dp[i]] result = max(result, dp[i + 1]) return result æ–¹æ³•ä¸‰ï¼šæ­£å‘é€†å‘ç»“åˆ ä»é¢˜è§£å­¦åˆ°çš„é™¤äº†èŠ‚çº¦ç©ºé—´å¤–å¯èƒ½æ²¡ä»€ä¹ˆç”¨çš„åšé¢˜æŠ€å·§ğŸ˜‚\nå…ˆæ­£å‘æ‰«æä¸€éï¼Œå†åå‘æ‰«æä¸€éï¼Œæ­£å‘æ‰«æçš„æ—¶å€™ï¼š\n å¦‚æœé‡åˆ°å·¦æ‹¬å·ï¼Œleft+1ï¼› å¦‚æœé‡åˆ°å³æ‹¬å·ï¼Œright+1ï¼› å¦‚æœ left = rightï¼Œè®°å½• left+rightï¼ˆå¯¹åº”æ–¹æ³•ä¸€æ ˆç©ºçš„æƒ…å½¢ï¼‰ï¼› å¦‚æœ left \u0026lt; rightï¼Œleft, right æ¸…é›¶ã€‚  ä¹‹æ‰€ä»¥è¦åå‘æ‰«ææ˜¯å› ä¸ºè¿™ç§æ–¹æ³•ä¸èƒ½å¤„ç†æœ€åæ ˆé‡Œè¿˜æœ‰å·¦æ‹¬å·çš„æƒ…å½¢ã€‚\nclass Solution: def longestValidParentheses(self , s: str) -\u0026gt; int: left, right, result = 0, 0, 0 for i in s: if i == \u0026#34;(\u0026#34;: left += 1 else: right += 1 if left == right: result = max(result, left * 2) elif left \u0026lt; right: left, right = 0, 0 left, right = 0, 0 for i in reversed(s): if i == \u0026#34;)\u0026#34;: right += 1 else: left += 1 if left == right: result = max(result, left * 2) elif left \u0026gt; right: left, right = 0, 0 return result BM78 æ‰“å®¶åŠ«èˆï¼ˆä¸€ï¼‰ æ˜¾è€Œæ˜“è§ï¼Œ$dp[i]=\\max(dp[i-1], nums[i]+dp[i-2])$ã€‚\nclass Solution: def rob(self , nums: List[int]) -\u0026gt; int: dp_prev, dp = 0, 0 for i in nums: dp_prev, dp = dp, max(dp, i + dp_prev) return dp BM79 æ‰“å®¶åŠ«èˆï¼ˆäºŒï¼‰ å’Œä¸Šä¸€é¢˜çš„å”¯ä¸€åŒºåˆ«æ˜¯å·äº†ç¬¬ä¸€å®¶å°±ä¸èƒ½å·æœ€åä¸€å®¶ï¼Œå› æ­¤åˆ†ä¸¤ç§æƒ…å†µå¤„ç†ï¼šåˆ†åˆ«è®¡ç®— [0, n-2] ä¸ [1, n-1] çš„æœ€å¤§å€¼ï¼š\nclass Solution: def rob(self , nums: List[int]) -\u0026gt; int: def robb(nums): dp_prev, dp = 0, 0 for i in nums: dp_prev, dp = dp, max(dp, i + dp_prev) return dp return max(robb(nums[:-1]), robb(nums[1:])) BM80 ä¹°å–è‚¡ç¥¨çš„æœ€å¥½æ—¶æœºï¼ˆä¸€ï¼‰ ä½ä¹°é«˜å–ï¼Œéå†æ¯ä¸€å¤©ï¼Œè®¡ç®—åœ¨è¿™ä¸€å¤©ä¹‹å‰çš„æœ€ä½ä»·ä¹°å…¥åå–å‡ºçš„åˆ©æ¶¦ï¼Œæ±‚æœ€å¤§å€¼å³å¯ã€‚\nclass Solution: def maxProfit(self , prices: List[int]) -\u0026gt; int: lowest, profit = prices[0], 0 for i in prices: lowest = min(lowest, i) # ç¬¬ i å¤©å‰çš„æœ€ä½ä»·æ ¼ profit = max(profit, i-lowest) # åœ¨ç¬¬ i å¤©å‰ä¹°å…¥åå–å‡ºçš„æœ€å¤§åˆ©æ¶¦ return profit BM81 ä¹°å–è‚¡ç¥¨çš„æœ€å¥½æ—¶æœºï¼ˆäºŒï¼‰ ä¾ç„¶æ˜¯ä½ä¹°é«˜å–ï¼Œç´¯è®¡æ‰€æœ‰â€œä¸Šå¡â€ï¼Œæ‰“æ­»ä¸å†™ DPğŸ˜‚\nclass Solution: def maxProfit(self , prices: List[int]) -\u0026gt; int: return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, len(prices))) BM82 ä¹°å–è‚¡ç¥¨çš„æœ€å¥½æ—¶æœºï¼ˆä¸‰ï¼‰ ä¾ç„¶æ˜¯é€ƒè¯¾ğŸ˜‚\nå›é¡¾ BM80 çš„åšæ³•ï¼Œæˆ‘ä»¬å®é™…ä¸Šä»¥çº¿æ€§æ—¶é—´å¤æ‚åº¦æ±‚å‡ºäº†åœ¨ç¬¬ i å¤©å‰ä»¥æœ€ä½ä»·ä¹°å…¥å¹¶åœ¨ç¬¬ i å¤©ä¹‹å‰ï¼ˆå«ï¼‰å–å‡ºçš„æœ€å¤§åˆ©æ¶¦ï¼Œå¯ä»¥æŠŠå®ƒç”¨ä¸€ä¸ªæ•°ç»„ dp1 è®°å½•ä¸‹æ¥ã€‚\nåªè¦æŠŠç¨‹åºå€’è¿‡æ¥ï¼Œå°±å¯ä»¥ä»¥çº¿æ€§æ—¶é—´å¤æ‚åº¦æ±‚å‡ºåœ¨ç¬¬ i å¤©åä»¥æœ€é«˜ä»·å–å‡ºå¹¶åœ¨ç¬¬ i å¤©ä¹‹åï¼ˆå«ï¼‰ä¹°å…¥çš„æœ€å¤§åˆ©æ¶¦ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„ dp2 è®°å½•ä¸‹æ¥ã€‚å› ä¸ºåªèƒ½ä¹°å–ä¸¤æ¬¡ï¼Œæœ€åè¿”å› max(dp1+dp2) å³å¯ã€‚\nclass Solution: def maxProfit(self , prices: List[int]) -\u0026gt; int: lowest, profit, dp, result = prices[0], 0, [], 0 for i in prices: lowest = min(lowest, i) # ç¬¬ i å¤©å‰çš„æœ€ä½ä»·æ ¼ profit = max(profit, i - lowest) # åœ¨ç¬¬ i å¤©å‰ä¹°å…¥åå–å‡ºçš„æœ€å¤§åˆ©æ¶¦ dp.append(profit) highest, profit = prices[-1], 0 for j in reversed(prices): highest = max(highest, j) profit = max(profit, highest - j) result = max(result, dp.pop() + profit) return result å½“ç„¶è¿™ç§é€ƒè¯¾åšæ³•ä¸èƒ½æ¨å¹¿åˆ°æ›´ä¸€èˆ¬çš„æƒ…å½¢ã€‚æ ‡å‡†çš„é¢˜è§£éœ€è¦åˆ‡åˆ†ä¸º 5 ä¸ªçŠ¶æ€ï¼š\n æœªè¿›è¡Œä»»ä½•æ“ä½œï¼Œæ­¤æ—¶ç°é‡‘åˆ©æ¶¦æ’ä¸º 0ï¼š$start[i] = dp[i][0] = 0$ï¼› åœ¨ç¬¬ i å¤©ç»“æŸå‰ï¼Œåªè¿›è¡Œä¸€æ¬¡ä¹°æ“ä½œï¼Œæ­¤æ—¶ç°é‡‘åˆ©æ¶¦ä¸ºè´Ÿï¼š$buy_1[i] = dp[i][1] = \\max(buy_1[i - 1], start[i] - prices[i]) = \\max(buy_1[i - 1], - prices[i])$ï¼› åœ¨ç¬¬ i å¤©ç»“æŸå‰ï¼Œè¿›è¡Œäº†ä¸€æ¬¡ä¹°å’Œå–æ“ä½œï¼š$sell_1[i] = dp[i][2] = \\max(sell_1[i - 1], prices[i] + buy_1[i])$ï¼› åœ¨ç¬¬ i å¤©ç»“æŸå‰ï¼Œå®Œæˆäº†ä¸€ç¬”äº¤æ˜“å’Œå¦å¤–ä¸€æ¬¡ä¹°æ“ä½œï¼š$buy_2[i] = dp[i][3] = \\max(buy_2[i-1], sell_1[i] - prices[i])$ï¼› åœ¨ç¬¬ i å¤©ç»“æŸå‰ï¼Œå®Œæˆäº†ä¸¤ç¬”äº¤æ˜“ï¼š$sell_2[i] = dp[i][4] = \\max(sell_2[i-1], buy_2[i] + prices[i])$ã€‚  æœ€åè¿”å› $sell_2$ æœ€åä¸€æ¬¡çš„ç»“æœã€‚æ­¤æ—¶å°±èƒ½ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£äº†ï¼š\nclass Solution: def maxProfit(self , prices: List[int]) -\u0026gt; int: buy1, sell1, buy2, sell2 = -prices[0], 0, -prices[0], 0 for i in prices: buy1 = max(buy1, -i) sell1 = max(sell1, i + buy1) buy2 = max(buy2, sell1 - i) sell2 = max(sell2, buy2 + i) return sell2   æ­£åˆ™è¡¨è¾¾å¼çš„å®ç°ä¸»è¦åˆ†ä¸º DFA å’Œ NFAï¼ŒDFA è®°å½•ä¸‹æ‰€æœ‰å¯èƒ½çš„åŒ¹é…ï¼Œç„¶åéå†å­—ç¬¦ä¸²è¿›è¡Œæ£€æŸ¥ï¼›NFA åˆ™æ˜¯å°è¯•ä¸€ç§å¯èƒ½çš„æ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼ŒåŒ¹é…å¤±è´¥åè¿›è¡Œå›æº¯ã€‚æ˜¾ç„¶æ­£åˆ™è¡¨è¾¾å¼çš„éƒ¨åˆ†è¯­æ³•æ˜¯ä¸é€‚åˆ DFA çš„ï¼Œç›®å‰ç»å¤§éƒ¨åˆ†å®ç°éƒ½æ˜¯ NFAï¼Œä½†æ˜¯ DFA æ‰§è¡Œæ›´å¿«ã€‚æœ‰å…´è¶£å¯ä»¥é˜…è¯»ã€Šç²¾é€šæ­£åˆ™è¡¨è¾¾å¼ã€‹æˆ–è€…ç¼–è¯‘åŸç†çš„æ•™æã€‚\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-04-10T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-06/","title":"åšé¢˜ç¬”è®°06ï¼šåŠ¨æ€è§„åˆ’"},{"content":"BM50 ä¸¤æ•°ä¹‹å’Œ LeetCode ç¬¬ä¸€é¢˜ï¼Œæ¢¦å¼€å§‹çš„åœ°æ–¹ï¼Œä½¿ç”¨å­—å…¸ä½œä¸ºç¼“å­˜ï¼š\nclass Solution: def twoSum(self , numbers: List[int], target: int) -\u0026gt; List[int]: cache = {} for i in range(len(numbers)): if target - numbers[i] in cache: return [cache[target - numbers[i]] + 1, i + 1] else: cache[numbers[i]] = i return [] ä¸è¿‡æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚ï¼Œå¤§æ¦‚æ˜¯å¸Œæœ›æŠŠæ•°ç»„æ’åºåä½¿ç”¨åŒæŒ‡é’ˆï¼ˆä»¥æ—¶é—´æ¢ç©ºé—´ï¼‰ï¼š\nclass Solution: def twoSum(self , numbers: List[int], target: int) -\u0026gt; List[int]: lo, hi, numbers = 0, len(numbers) - 1, sorted((num, index) for index, num in enumerate(numbers)) while lo \u0026lt;= hi: total = numbers[lo][0] + numbers[hi][0] if total \u0026lt; target: lo = lo + 1 elif total \u0026gt; target: hi = hi - 1 else: return sorted([numbers[lo][1] + 1, numbers[hi][1] + 1]) return [] BM51 æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­— è¿™æ˜¯å‰‘æŒ‡ Offer é¢è¯•é¢˜ 39ï¼Œæ–¹æ³•éå¸¸å¤šï¼Œæ¯”å¦‚ä½¿ç”¨å­—å…¸ä¿å­˜æ¯ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°ï¼Œåˆæ¯”å¦‚ä½¿ç”¨ç±»ä¼¼å¿«é€Ÿæ’åºçš„åˆ†æ²»æ³•ï¼Œå¦å¤–æ³¨æ„åˆ°æ•°ç»„ä¸­å‡ºç°è¶…è¿‡ä¸€åŠçš„æ•°å­—ï¼Œä¸€å®šæ˜¯æ•°ç»„çš„ä¸­ä½æ•°ï¼Œè¿˜å¯ä»¥ä½¿ç”¨äºŒå‰å †ã€çº¢é»‘æ ‘ç­‰é«˜çº§æ•°æ®ç»“æ„ï¼Œä¸è¿‡éƒ½æ— æ³•æ»¡è¶³é¢˜ç›®æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(1) çš„è¦æ±‚ã€‚\næœ‰æ²¡æœ‰åŠæ³•å†ç®€åŒ–ä¸€ä¸‹å‘¢ï¼Œæ¯”å¦‚ä¸ä½¿ç”¨å­—å…¸ï¼Ÿå‡å¦‚åªä¿å­˜ä¸€ä¸ªæ•°å’Œå¯¹åº”çš„å‡ºç°æ¬¡æ•°ï¼Œä»ç„¶æœ‰åŠæ³•æ‰¾å‡ºå‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å—ï¼Ÿå…¶å®ä¹Ÿæ˜¯å¯ä»¥çš„ï¼š\n è®°å½•ä¸‹å½“å‰çš„æ•°å­—ï¼Œå‡ºç°æ¬¡æ•°è®¾ç½®ä¸º 1ï¼› å¦‚æœä¸‹ä¸€ä¸ªæ•°å­—ç›¸ç­‰ï¼Œå‡ºç°æ¬¡æ•°+1ï¼Œå¦åˆ™ -1ï¼› å‡ºç°æ¬¡æ•°ä¸º 0 æ—¶ï¼Œæ›´æ¢ä¸‹ä¸€ä¸ªæ•°å­—ã€‚  class Solution: def MoreThanHalfNum_Solution(self , numbers: List[int]) -\u0026gt; int: num, times = None, 0 for i in numbers: if not times: num, times = i, 1 elif i == num: times = times + 1 else: times = times - 1 return num ç†è§£è¿™ä¸ªç®—æ³•æ¯”è¾ƒå¿«çš„æ–¹æ³•å¤§æ¦‚æ˜¯å°è¯•æ„é€ ä¸€ä¸ªåä¾‹ï¼Œä¸ºäº†è®©å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­— num ä¸”ä¸è¢«è®°å½•ä¸‹æ¥ï¼Œåªèƒ½æ˜¯è¿™ç§å½¢å¼ [a, num, b, num, c, num, ..., y, num(, z)]ï¼Œä½†ä¸ num å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçŸ›ç›¾ã€‚\nBM52 æ•°ç»„ä¸­åªå‡ºç°ä¸€æ¬¡çš„ä¸¤ä¸ªæ•°å­— éœ€è¦ä½¿ç”¨å¼‚æˆ–çš„æŠ€å·§ï¼š\n 0 xor a = a, a xor a = 0 a xor b = b xor a a xor b = c, c xor a = b, c xor b = a  å¯ä»¥çœ‹åˆ°å¼‚æˆ–ä¸åŒæ•°çš„æ—¶å€™åƒåšåŠ æ³•ï¼Œå¼‚æˆ–ç›¸åŒæ•°åƒåœ¨åšå‡æ³•ã€‚å¦‚æœæ•°ç»„ä¸­åªæœ‰ä¸€ä¸ªæ•°å­—åªå‡ºç°ä¸€æ¬¡ï¼Œåªè¦æŠŠæ•°ç»„å…¨éƒ¨æ•°å¼‚æˆ–ä¸€æ¬¡å°±èƒ½å¾—åˆ°ç»“æœã€‚\næœ¬é¢˜ä¸­å› ä¸ºæœ‰ä¸¤ä¸ªæ•° a,bï¼ŒæŠŠå…¨éƒ¨æ•°å¼‚æˆ–åªèƒ½å¾—åˆ° a xor bã€‚å¦‚æœèƒ½æŠŠæ‰€æœ‰æ•°åˆ†æˆä¸¤ç»„ï¼Œè®© a,b å„è‡ªå’Œç»„å†…å…¶ä»–æ•°è¿›è¡Œå¼‚æˆ–ï¼Œé—®é¢˜å°±è§£å†³äº†ã€‚æ³¨æ„åˆ°å¼‚æˆ–åä¸º 1 çš„ä½æ˜¯ä¸¤ä¸ªæ•°ä¸åŒçš„ä½ï¼Œä¸éš¾å†™å‡ºä»£ç ï¼š\nclass Solution: def FindNumsAppearOnce(self , array: List[int]) -\u0026gt; List[int]: # 1. è®¡ç®—æ‰€æœ‰æ•°çš„å¼‚æˆ–å’Œ from functools import reduce axorb = reduce(lambda a,b: a^b, array) # 2. å¯»æ‰¾ä»æœ€å³è¾¹å¼€å§‹ç¬¬ä¸€ä½ä¸º1å¯¹åº”çš„æ•°å­—ï¼Œå¦‚ 6-\u0026gt;110-\u0026gt;10-\u0026gt;2ï¼Œè¿™é‡Œä½¿ç”¨äº†ä½è¿ç®—æŠ€å·§ lowbit = axorb \u0026amp; -axorb # 3. åˆ†ç»„å†æ¬¡æ±‚å¼‚æˆ–å’Œ a, b = 0, 0 for num in array: if num \u0026amp; lowbit: # å¯¹åº”ä½ä¸º 1 a = a ^ num else: # å¯¹åº”ä½ä¸º 0 b = b ^ num return sorted([a,b]) BM53 ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•´æ•° å¾ˆè‡ªç„¶æƒ³åˆ°ä½¿ç”¨å­—å…¸ï¼Œç„¶è€Œé¢˜ç›®ä¸å…è®¸ï¼Œæ€ä¹ˆåŠå‘¢ï¼Ÿèƒ½ä¸èƒ½ç›´æ¥åœ¨æ•°ç»„ä¸­è®°å½•æŸä¸ªæ­£æ•°æ˜¯å¦å‡ºç°çš„ä¿¡æ¯ï¼Ÿäºæ˜¯å­¦ä¼šäº†æ–°æŠ€å·§â€”â€”åŸåœ°å“ˆå¸Œï¼š\n é¦–å…ˆæŠŠæ‰€æœ‰è´Ÿæ•°å’Œ 0 è®¾ç½®ä¸º n+1ï¼› é¡ºåºéå†æ•°ç»„ï¼Œå¦‚æœ 1-n ä¸­æŸä¸ªæ•°å­— k å‡ºç°è¿‡ï¼Œå°±æŠŠæ•°ç»„ç¬¬ k ä¸ªå…ƒç´ è®¾ç½®ä¸ºè´Ÿæ•°ï¼ˆè®°å¾—è¦-1ï¼Œkä¹Ÿæœ‰å¯èƒ½æ˜¯è´Ÿæ•°ï¼Œè®°å¾—å–ç»å¯¹å€¼ï¼‰ï¼› é¡ºåºéå†æ•°ç»„ï¼Œç¬¬ä¸€ä¸ªæ­£æ•°å¯¹åº”çš„ç´¢å¼•å°±æ˜¯æ‰€æ±‚çš„æ•°ï¼ˆè®°å¾—è¦+1ï¼‰ï¼› å¦‚æœæ²¡æ‰¾åˆ°æ­£æ•°ï¼Œè¯´æ˜æ•°ç»„ä¸­çš„æ•°æ°å¥½ä¸º 1-nï¼Œè¿”å› n+1ã€‚  class Solution: def minNumberDisappeared(self , nums: List[int]) -\u0026gt; int: n = len(nums) # 1. æŠŠæ‰€æœ‰è´Ÿæ•°å’Œ 0 æ›¿æ¢æˆ n+1ï¼Œæ­¤æ—¶æ•°åˆ—å…¨æ˜¯æ­£æ•° for i in range(n): if nums[i] \u0026lt;= 0: nums[i] = n + 1 # 2. æŠŠå‡ºç°è¿‡çš„æ•°ä½œä¸ºä¸‹æ ‡å¯¹åº”çš„æ•°å˜æˆè´Ÿæ•°ï¼Œæ­¤æ—¶æ•°ç»„çš„æ•°ä¸º [1, ...] å¯¹åº”çš„ä¸‹æ ‡åˆ™æ˜¯ [0, n-1] for i in range(n): if abs(nums[i]) \u0026lt;= n: nums[abs(nums[i]) - 1] = - abs(nums[abs(nums[i]) - 1]) # 3. æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ­£æ•°å¯¹åº”çš„æ•°ç»„ä¸‹æ ‡ for i in range(n): if nums[i] \u0026gt; 0: return i + 1 return n + 1 BM54 ä¸‰æ•°ä¹‹å’Œ æ—¢ç„¶æ˜¯ä¸‰ä¸ªæ•°ï¼Œéå†æ‰€æœ‰äºŒå…ƒç»„å°±éœ€è¦ O(n^2)ï¼Œè‡ªç„¶ä¼šæƒ³åˆ°å…ˆæ’ä¸ªåºå†å¤„ç†ã€‚åªè¦å†™å‡ºä¸¤æ•°ä¹‹å’Œçš„åŒæŒ‡é’ˆç‰ˆæœ¬ï¼Œå†åŠ ä¸€ä¸ªæŒ‡é’ˆå°±æ˜¯ä¸‰æ•°ä¹‹å’Œäº†ï¼ŒåŒç†å¯ä»¥æ¨å¹¿è‡³ nSumï¼Œåªéœ€è¦æ³¨æ„è·³è½¬çš„æ—¶å€™è¦è·³åˆ°ä¸‹ä¸€ä¸ªä¸åŒçš„æ•°ã€‚\nclass Solution: def threeSum(self , nums: List[int]) -\u0026gt; List[List[int]]: nums, n = sorted(nums), len(nums) if n \u0026lt; 3: return [] low, mid, high = 0, 1, n-1 result = [] while low \u0026lt; n-2: while mid \u0026lt; high: if nums[mid] + nums[high] \u0026lt; 0 - nums[low]: # mid è·³åˆ°ä¸‹ä¸€ä¸ªæ•°ï¼Œ0 å¯ä»¥æ¢æˆ target tmp = nums[mid] while nums[mid] == tmp and mid \u0026lt; high: mid = mid + 1 elif nums[mid] + nums[high] \u0026gt; 0 - nums[low]: # high è·³åˆ°ä¸Šä¸€ä¸ªæ•° tmp = nums[high] while nums[high] == tmp and mid \u0026lt; high: high = high - 1 else: result.append([nums[low], nums[mid], nums[high]]) tmp = nums[mid] while nums[mid] == tmp and mid \u0026lt; high: mid = mid + 1 high = n - 1 tmp = nums[low] # low è·³åˆ°ä¸‹ä¸€ä¸ªæ•° while nums[low] == tmp and low \u0026lt; n-2: low = low + 1 mid, high = low + 1, n - 1 return result BM55 æ²¡æœ‰é‡å¤é¡¹æ•°å­—çš„å…¨æ’åˆ— ä¹…è¿çš„è½»æ¾æ—¶åˆ»ï½\nclass Solution: def permute(self , nums: List[int]) -\u0026gt; List[List[int]]: from itertools import permutations return list(permutations(sorted(nums))) å…¶å®æ–¹æ³•éå¸¸å¤šï¼ŒDonald E. Knuth åœ¨ The Art of Computer Programming ä¸­ç”¨ ä¸€æ•´å†Œä¹¦ çš„ç¯‡å¹…è®¨è®ºäº†å„ç§æ’åˆ—å’Œå…ƒç»„çš„ç”Ÿæˆæ–¹æ³•ã€‚åœ¨æ–‡æ¡£é‡Œå¯ä»¥çœ‹åˆ° itertools.permutations çš„ å®ç°åŸç†ï¼Œä¸è¿‡ å¹¶ä¸å¥½æ‡‚ï¼Œä¼¼ä¹æ˜¯ä½¿ç”¨äº† Knuth ä¹¦ä¸­ä¸€ç§åŸºäºç½®æ¢çš„ç®—æ³•ã€‚\nå°±ç®—åªè€ƒè™‘å­—å…¸åºéå†ï¼Œç›¸å¯¹ç®€å•çš„ç®—æ³•ä¹Ÿæœ‰å¾ˆå¤šï¼Œæ¯”å¦‚æ³¨æ„åˆ° 1 2 3 çš„æ‰€æœ‰æ’åˆ—ä¸ºï¼š\n1 23 1 32 2 13 2 31 3 12 3 21 å³å¯åˆ†è§£ä¸ºå­é—®é¢˜ï¼Œä¸éš¾å†™å‡ºé€’å½’ä»£ç ï¼š\nclass Solution: def permute(self , nums: List[int]) -\u0026gt; List[List[int]]: def perm(nums): if len(nums) \u0026lt;= 1: yield nums else: for i in range(len(nums)): for j in perm(nums[:i] + nums[i+1:]): # Slice æ²¡æœ‰è¾¹ç•Œé—®é¢˜ yield [nums[i]] + j return list(perm(sorted(nums))) ä»å¦ä¸€ä¸ªè§’åº¦çœ‹ï¼Œå…¶å®æ˜¯æ ‘çš„éå†é—®é¢˜ï¼ˆå±‚åºï¼‰ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥å­˜å‚¨ä¸Šä¸€å±‚çš„ç»“æœï¼š\nclass Solution: def permute(self , nums: List[int]) -\u0026gt; List[List[int]]: from collections import deque queue = deque([[[], sorted(nums)]]) while queue[0][1]: for _ in range(len(queue)): prefix, suffix = queue.popleft() for i in range(len(suffix)): queue.append([prefix + [suffix[i]], suffix[:i] + suffix[i+1:]]) return [i[0] for i in queue] BM56 æœ‰é‡å¤é¡¹æ•°å­—çš„å…¨æ’åˆ— ä»ç”Ÿæˆå™¨çš„è§’åº¦æ€è€ƒï¼šå¦‚æœå½“å‰çš„æ’åˆ—ä¸º (1,2,4,5,3)ï¼Œä¸‹ä¸€ä¸ªæ’åˆ—æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå›é¡¾ä¸­åºéå†çš„è¿‡ç¨‹ï¼Œé¦–å…ˆè¦ä»åå¾€å‰æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœ‰å³å­ç»“ç‚¹çš„ç»“ç‚¹ï¼Œç„¶åæ²¿ç€è¿™æ¡è·¯å¾„å¾€å·¦ä¸‹èµ°ï¼Œè½¬æ¢æˆæ•°å­¦çš„è¯­è¨€ï¼š\n ä»æœ€åä¸€ä¸ªæ•°å­—å¼€å§‹å¾€å›èµ°ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸‹é™çš„æ•°å­—ï¼Œä½œä¸ºä¸»å…ƒã€‚ï¼ˆä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºä¸»å…ƒåœ¨â€œè¿›ä½â€å‰ï¼Œåé¢çš„æ•°å¿…ç„¶è¾¾åˆ°æœ€å¤§å€¼ï¼Œæ•…ä¸€å®šæ˜¯éå¢åºåˆ—ï¼Œç»“åˆæ ‘çš„å›¾å½¢ä¼šæ›´å¥½ç†è§£ã€‚ï¼‰è¿™é‡Œ 3\u0026lt;5ï¼Œ5\u0026gt;4ï¼Œæ‰€ä»¥ä¸»å…ƒæ˜¯4ï¼› ä¸»å…ƒåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³ 4-\u0026gt;5ï¼Œæ­¤æ—¶å‰ä¸‰ä¸ªæ•°å­—ä¸º {1,2,5}ï¼› æŠŠå‰©ä¸‹çš„æ•°å­—ç”±å°åˆ°å¤§æ’åºï¼Œå³ {4,3} -\u0026gt; {3,4}ï¼Œå†æ¥åˆ°åé¢ï¼Œå³ä¸‹ä¸€ä¸ªæ’åˆ—ä¸º {1,2,5,3,4}ã€‚å…¶å®åªéœ€äº¤æ¢ä¸Šé¢ä¸¤ä¸ªæ•°å­—åï¼ŒæŠŠååŠæˆªåè¿‡æ¥ï¼ˆå› ä¸ºäº¤æ¢ä¸æ”¹å˜å¤§å°æ¬¡åºï¼‰ã€‚  class Solution: def permuteUnique(self , nums: List[int]) -\u0026gt; List[List[int]]: nums, n, res = sorted(nums), len(nums), [] res.append(nums.copy()) while True: pivot = n - 1 while pivot \u0026gt; 0 and nums[pivot - 1] \u0026gt;= nums[pivot]: pivot = pivot - 1 pivot = pivot - 1 # å¾ªç¯åœ¨ pivot - 1 æ˜¯ä¸»å…ƒæ—¶åœæ­¢ if pivot \u0026lt; 0: # åˆ°è¾¾æœ€åä¸€ä¸ªæ’åˆ—ï¼Œé€€å‡ºå¾ªç¯ break else: exchange = n - 1 # å¯»æ‰¾ç¬¬ä¸€ä¸ªå¤§äº pivot çš„å…ƒç´ ï¼Œæ­¤æ—¶åé¢å…ƒç´ éå¢ while nums[exchange] \u0026lt;= nums[pivot]: exchange = exchange - 1 nums[pivot], nums[exchange] = nums[exchange], nums[pivot] nums[pivot+1:] = nums[n-1:pivot:-1] # æŠŠååŠæˆªåè¿‡æ¥ res.append(nums.copy()) return res è¿™ä¸ªç®—æ³•å†å²æ‚ ä¹…ï¼Œæ® Knuth è€ƒè¯ä¼¼ä¹æœ€æ—©å‡ºç°äº 14 ä¸–çºªã€‚è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„ç®—æ³•ï¼Œæ¯”å¦‚ Knuth çš„ Algorithm L â€¦â€¦\nBM57 å²›å±¿æ•°é‡ æŒ‰æŸç§æ¬¡åºï¼ˆæ¯”å¦‚ä»å·¦åˆ°å³ä»ä¸Šåˆ°ä¸‹ï¼‰è®¿é—®æ‰€æœ‰æ ¼å­ï¼š\n å¦‚æœæ ¼å­é‡Œæ˜¯ '1'ï¼Œè®¡æ•°å™¨åŠ 1ï¼Œæ ¼å­å…ƒç´ è®¾æˆ '0'ï¼› æ­¤æ—¶è®¿é—®æ ¼å­ä¸Šä¸‹å·¦å³ï¼Œå¦‚æœé‡åˆ° '1'ï¼Œè®¾ç½®æˆ '0'ï¼Œå¹¶ä¸”ç»§ç»­è®¿é—®è¯¥æ ¼å­ä¸Šä¸‹å·¦å³ï¼› å¦‚æœæ ¼å­æ˜¯ '0' å°±è·³è¿‡ï¼› æœ€åè¿”å›è®¡æ•°å™¨çš„ç»“æœã€‚  class Solution: def solve(self , grid: List[List[str]]) -\u0026gt; int: if not grid: return 0 row, col = len(grid), len(grid[0]) count, queue = 0, [] inArea = lambda e: (e[0] \u0026gt;= 0 and e[0] \u0026lt; row and e[1] \u0026gt;= 0 and e[1] \u0026lt; col) for i in range(row): for j in range(col): if grid[i][j] == \u0026#39;1\u0026#39;: count = count + 1 grid[i][j] = \u0026#39;0\u0026#39; queue.extend(e for e in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)] if inArea(e)) while queue: e_i, e_j = queue.pop() if grid[e_i][e_j] == \u0026#39;1\u0026#39;: grid[e_i][e_j] = \u0026#39;0\u0026#39; queue.extend(e for e in [(e_i - 1, e_j), (e_i + 1, e_j), (e_i, e_j - 1), (e_i, e_j + 1)] if inArea(e)) return count BM58 å­—ç¬¦ä¸²çš„æ’åˆ— å’Œ BM56 åŸºæœ¬ä¸€è‡´ï¼Œåªè¦ç¨å¾®æ”¹åŠ¨ä¸€ä¸‹â€¦â€¦æ„Ÿè°¢ PythonğŸ™ğŸ™\nclass Solution: def Permutation(self , string: str) -\u0026gt; List[str]: alps, n, res = sorted(string), len(string), [] res.append(\u0026#39;\u0026#39;.join(alps)) while True: pivot = n - 1 while pivot \u0026gt; 0 and alps[pivot - 1] \u0026gt;= alps[pivot]: pivot = pivot - 1 pivot = pivot - 1 # å¾ªç¯åœ¨ pivot - 1 æ˜¯ä¸»å…ƒæ—¶åœæ­¢ if pivot \u0026lt; 0: # åˆ°è¾¾æœ€åä¸€ä¸ªæ’åˆ—ï¼Œé€€å‡ºå¾ªç¯ break else: exchange = n - 1 # å¯»æ‰¾ç¬¬ä¸€ä¸ªå¤§äº pivot çš„å…ƒç´ ï¼Œæ­¤æ—¶åé¢å…ƒç´ éå¢ while alps[exchange] \u0026lt;= alps[pivot]: exchange = exchange - 1 alps[pivot], alps[exchange] = alps[exchange], alps[pivot] alps[pivot+1:] = alps[n-1:pivot:-1] # æŠŠååŠæˆªåè¿‡æ¥ res.append(\u0026#39;\u0026#39;.join(alps)) return res BM59 Nçš‡åé—®é¢˜ å·ä¸ªæ‡’ï¼Œæ³¨æ„åˆ°å¦‚æœæŠŠå…¨æ’åˆ—ç¬¬ i ä¸ªå…ƒç´  j çš„ (i,j) çœ‹æˆåæ ‡ï¼Œæ˜¾ç„¶æ˜¯ä¸åŒè¡Œä¸åŒåˆ—çš„ï¼Œåªéœ€è¦æ£€æŸ¥æ˜¯å¦åœ¨ç›¸åŒçš„å¯¹è§’çº¿ä¸Šï¼Œå³æ£€æŸ¥æœ‰æ²¡æœ‰ç›¸åŒçš„ i+j å’Œ i-jã€‚è™½ç„¶è¿‡äº†ï¼Œä½†æ—¶é—´å¾ˆæ…¢ï¼ˆO(n * n!)ï¼‰â€¦â€¦\nclass Solution: def Nqueen(self , n: int) -\u0026gt; int: from itertools import permutations count = 0 for e in permutations(range(n)): left, right, reg = {}, {}, 0 for i,j in enumerate(e): if (not i+j in left) and (not i-j in right): left[i+j], right[i-j], reg = True, True, reg + 1 else: break if reg == n: count = count + 1 return count æ¯”è¾ƒè‘—åçš„æ–¹æ³•æ˜¯ä½¿ç”¨ ä½è¿ç®—+é€’å½’ï¼š\nclass Solution: def Nqueen(self , n: int) -\u0026gt; int: count = 0 def DFS(row, shu, pie, na): # æ¨ªç«–æ’‡æº nonlocal count available = ((1 \u0026lt;\u0026lt; n) - 1) \u0026amp; ~(shu | pie | na) # æˆªæ–­ \u0026amp; å–åå¾—åˆ°å¯ç”¨ä½ while available: p = available \u0026amp; -available # lowbit ä¸º 1 çš„æœ€ä½ä½ available ^= p # æŠŠ lowbit ä½ç½® 0 if row == n - 1: count += 1 else: DFS(row + 1, shu | p, (pie | p) \u0026gt;\u0026gt; 1, (na | p) \u0026lt;\u0026lt; 1) DFS(0, 0, 0, 0) return count BM60 æ‹¬å·ç”Ÿæˆ ä¹Ÿæ˜¯æ ‘çš„éå†ã€‚\nclass Solution: def generateParenthesis(self , n: int) -\u0026gt; List[str]: from collections import deque queue = deque([(\u0026#39;\u0026#39;, 2 * n, 0, 0)]) # (å‰ç¼€, å‰©ä¸‹çš„å­—ç¬¦æ•°ï¼Œå·¦æ‹¬å·æ•°, å³æ‹¬å·æ•°) while queue[0][1] \u0026gt; 0: prefix, char_left, count_left, count_right = queue.popleft() if count_left \u0026lt; n: queue.append((prefix + \u0026#39;(\u0026#39;, char_left - 1, count_left + 1, count_right)) if count_right \u0026lt; count_left: queue.append((prefix + \u0026#39;)\u0026#39;, char_left - 1, count_left, count_right + 1)) return [i[0] for i in queue] BM61 çŸ©é˜µæœ€é•¿é€’å¢è·¯å¾„ æœ€å®¹æ˜“æƒ³åˆ°çš„æ˜¯é€’å½’ï¼Œdfs(x, y) = max(dfs(i, j) for i, j in jobs) + 1ï¼š\nclass Solution: def solve(self , matrix: List[List[int]]) -\u0026gt; int: row, col = len(matrix), len(matrix[0]) lengths, dirs = [[0] * row for _ in range(col)], [(-1, 0), (0, 1), (1, 0), (0, -1)] inArea = lambda x,y: (0 \u0026lt;= x \u0026lt; row and 0 \u0026lt;= y \u0026lt; col) def DFS(x,y): nonlocal lengths if lengths[x][y] == 0: jobs = [(x + i, y + j) for i, j in dirs if inArea(x + i, y + j) and matrix[x + i][y + j] \u0026gt; matrix[x][y] ] lengths[x][y] = (max(DFS(i, j) for i, j in jobs) + 1) if jobs else 1 return lengths[x][y] result = 0 for i in range(row): for j in range(col): result = max(result, DFS(i, j)) return result åˆè¸©åˆ°äº† Python ä¸€ä¸ªå‘ï¼Œdebug äº†è¶³è¶³ä¸€ä¸ªå°æ—¶ï¼š\n\u0026gt;\u0026gt;\u0026gt; [[0]*5]*3 [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] \u0026gt;\u0026gt;\u0026gt; x = [[0]*5]*3 \u0026gt;\u0026gt;\u0026gt; x[0][1] = 1 \u0026gt;\u0026gt;\u0026gt; x [[0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 0, 0]] ä¹Ÿå¯ä»¥çœ‹æˆåŠ¨æ€è§„åˆ’æˆ–è€…æ ‘çš„éå†ï¼Œä»æœ€å¤§çš„æ•°å¼€å§‹ä¸€æ­¥ä¸€æ­¥å¾€å››å‘¨å€’ç€èµ°ï¼š\nclass Solution: def solve(self , matrix: List[List[int]]) -\u0026gt; int: row, col = len(matrix), len(matrix[0]) lengths, dirs = [[0] * row for _ in range(col)], [(-1, 0), (0, 1), (1, 0), (0, -1)] inArea = lambda x,y: (0 \u0026lt;= x \u0026lt; row and 0 \u0026lt;= y \u0026lt; col) from collections import deque queue = deque() for x in range(row): for y in range(col): for i, j in dirs: if inArea(x + i, y + j) and matrix[x + i][y + j] \u0026gt; matrix[x][y]: lengths[x][y] += 1 if lengths[x][y] == 0: # å››å‘¨æ²¡æœ‰æ¯”å®ƒå¤§çš„æ ¼å­ queue.append((x, y)) result = 0 while queue: result += 1 for _ in range(len(queue)): x, y = queue.popleft() for i,j in dirs: if inArea(x + i, y + j) and matrix[x + i][y + j] \u0026lt; matrix[x][y]: lengths[x + i][y + j] -= 1 if lengths[x + i][y + j] == 0: # æ¬¡å¤§çš„æ ¼å­ queue.append((x + i, y + j)) return result ä¸å†™ += -= è¿‡ä¸äº†æµ‹è¯•ï¼Œå¥‡æ€ªçš„æ˜¯å·®è·åº”è¯¥å¹¶ä¸æ˜æ˜¾ğŸ˜‚\n","date":"2022-04-07T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-05/","title":"åšé¢˜ç¬”è®°05ï¼šå“ˆå¸Œ/é€’å½’/å›æº¯"},{"content":"BM42 ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ— æ ˆç›¸å½“äºæŠŠé˜Ÿåˆ—çš„ä¸€éƒ¨åˆ†å…ƒç´ ä»¥ç›¸åçš„æ–¹å‘å­˜å‚¨ï¼Œå†ä½¿ç”¨ä¸€ä¸ªæ ˆæŠŠæ‰€æœ‰å…ƒç´ çš„é¡ºåºåè¿‡æ¥å°±æ˜¯é˜Ÿåˆ—ã€‚ç­‰é˜Ÿåˆ—æ ˆç©ºäº†ï¼Œå°±å†åšä¸€æ¬¡ç›¸åŒçš„äº‹æƒ…ã€‚\nclass Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): self.stack1.append(node) def pop(self): if not self.stack1 and not self.stack2: # é˜Ÿåˆ—ä¸ºç©º return None if not self.stack2: # æ ˆ2ä¸ºç©ºï¼ŒæŠŠæ ˆ1æ‰€æœ‰å…ƒç´ å…¥æ ˆ while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() BM43 åŒ…å«minå‡½æ•°çš„æ ˆ ç©ºé—´æ¢æ—¶é—´ï¼Œå†å‡†å¤‡ä¸€ä¸ªæ ˆç¼“å­˜å½“å‰çš„minå°±å¥½ï¼š\nclass Solution: def __init__(self): self.stack = [] self.stack_min = [] def push(self, node): self.stack.append(node) if not self.stack_min: self.stack_min.append(node) else: self.stack_min.append(min(node, self.stack_min[-1])) def pop(self): self.stack_min.pop() return self.stack.pop() def top(self): return self.stack[-1] def min(self): return self.stack_min[-1] BM44 æœ‰æ•ˆæ‹¬å·åºåˆ— ä½¿ç”¨ä¸€ä¸ªæ ˆå­˜å‚¨å·²ç»å‡ºç°çš„å·¦æ‹¬å·ï¼š\nclass Solution: def isValid(self , s: str) -\u0026gt; bool: stack, pairs = [], {\u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;} for char in s: if char in \u0026#39;([{\u0026#39;: stack.append(char) elif char in \u0026#39;)]}\u0026#39;: if not stack or pairs[char] != stack[-1]: return False else: stack.pop() return not stack BM45 æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼ åˆæ˜¯ä¸€é“éš¾é¢˜ï¼Œé¦–å…ˆæƒ³åˆ°çš„è‡ªç„¶æ˜¯ä¼˜å…ˆé˜Ÿåˆ—ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦ O(nlog(n)) ä¸èƒ½æ»¡è¶³è¦æ±‚ï¼Œåªèƒ½è·‘å»çœ‹é¢˜è§£â€¦â€¦\né¢˜è§£çš„åŸç†å…¶å®å¾ˆç®€å•ï¼šå¸Œæœ›åœ¨ä¸‹ä¸€ä¸ªæ»‘åŠ¨çª—å£ä¸­åˆ©ç”¨å‰é¢æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼ä¿¡æ¯ï¼Œå³ç»´æŠ¤ä¸€ä¸ªçª—å£å¤§å°çš„åŒå‘é˜Ÿåˆ—ã€‚å…·ä½“è€Œè¨€ï¼Œå› ä¸ºå½“å‰çª—å£æœ€å¤§å€¼å‰é¢çš„å…ƒç´ ï¼Œå¯¹ä¸‹ä¸€ä¸ªçª—å£çš„æœ€å¤§å€¼æ¯«æ— å½±å“ï¼Œå› æ­¤ä¸éœ€è¦å­˜å‚¨ï¼Œé˜Ÿåˆ—é‡Œå­˜å‚¨çš„å€¼å³ä¸º [å½“å‰çª—å£çš„æœ€å¤§å€¼, å‰ä¸€ä¸ªæ•°åˆ°æ»‘åŠ¨çª—å£æœ«çš„æœ€å¤§å€¼, å‰ä¸€ä¸ªæ•°åˆ°æ»‘åŠ¨çª—å£æœ«çš„æœ€å¤§å€¼, ...]ã€‚\nå¦‚ä½•å½¢æˆè¿™æ ·çš„é˜Ÿåˆ—ï¼Ÿåªè¦æ¯ä¸ªæ–°å…ƒç´ åœ¨å…¥åˆ—ä¹‹å‰ï¼ŒæŠŠæ ˆä¸­æ¯”å®ƒå°çš„å…ƒç´ ä»å³è¾¹å‡ºåˆ—å³å¯ã€‚çª—å£å¼€å§‹æ»‘åŠ¨æ—¶ï¼Œå¦‚æœé˜Ÿåˆ—ç¬¬ä¸€ä¸ªå…ƒç´ æ»‘å‡ºçª—å£å°±å‡ºåˆ—ï¼Œç„¶åæŠŠå½“å‰å…ƒç´ å…¥åˆ—ã€‚\nè¿™ä¸ªæ€è·¯æœ‰ç‚¹åƒåŠ¨æ€è§„åˆ’ï¼Œä¹Ÿæœ‰ç‚¹åƒäºŒå‰æœç´¢æ ‘çš„å‰åºéå†â€¦â€¦\nclass Solution: def maxInWindows(self , num: List[int], size: int) -\u0026gt; List[int]: from collections import deque if not num or size == 0 or size \u0026gt; len(num): return [] window = deque([]) for i in range(size): # å¾—åˆ°ç¬¬ä¸€ä¸ªçª—å£çš„çŠ¶æ€ while window and num[window[-1]] \u0026lt; num[i]: window.pop() window.append(i) result = [num[window[0]]] for i in range(size, len(num)): if window[0] \u0026lt;= i - size: window.popleft() while window and num[window[-1]] \u0026lt; num[i]: window.pop() window.append(i) result.append(num[window[0]]) return result BM46 æœ€å°çš„Kä¸ªæ•° æœ€ç®€å•çš„ä¸€é¢˜ï¼ˆx\nclass Solution: def GetLeastNumbers_Solution(self , input: List[int], k: int) -\u0026gt; List[int]: import heapq return heapq.nsmallest(k, input) å…¶å®å’Œ sorted(input)[:k] æ²¡ä»€ä¹ˆåŒºåˆ«ğŸ˜‚\nBM47 å¯»æ‰¾ç¬¬Kå¤§ ä¸Šé¢æé”™äº†ï¼Œè¿™æ‰æ˜¯æœ€ç®€å•çš„ä¸€é¢˜ï¼ˆx\nclass Solution: def findKth(self , a: List[int], n: int, K: int) -\u0026gt; int: return sorted(a)[-K] è¯•ç€å†™äº†ä¸€ä¸‹é¢˜è§£å¿«é€Ÿæ’åºçš„ä»£ç ï¼Œç»“æœç¬¬8ä¸ªæµ‹è¯•ç”¨ä¾‹è¶…å‡ºé™åˆ¶äº†â€¦â€¦æ‰€ä»¥ä¸è¦æµªè´¹ç”Ÿå‘½ï¼Œless is moreï¼\nBM48 æ•°æ®æµä¸­çš„ä¸­ä½æ•° ä¾ç„¶æ˜¯è€ƒå¯Ÿå †æ’åºã€‚å‡†å¤‡ä¸€ä¸ªå¤§é¡¶å †å­˜æ”¾å°å…ƒç´ ï¼Œä¸€ä¸ªå°é¡¶å †å­˜æ”¾å¤§å…ƒç´ ï¼Œå¹¶ä¸”ä¿æŒå¤§é¡¶å †æ‰€æœ‰å…ƒç´ éƒ½å°äºå°é¡¶å †æ‰€æœ‰å…ƒç´ ã€‚æ˜¾ç„¶ä¸­ä½æ•°å¿…ç„¶åœ¨è¿™ä¸¤ä¸ªé˜Ÿçš„é˜Ÿé¡¶å…ƒç´ ä¹‹é—´ã€‚æ·»åŠ å…ƒç´ æ—¶ï¼Œå¯ä»¥å…ˆåŠ å…¥å¤§å †ï¼Œå†ä»å¤§å †å–å‡ºæœ€å¤§å€¼åŠ å…¥å°å †ï¼ˆä¸ºäº†ç»´æŒç›¸å¯¹å¤§å°å…³ç³»ï¼‰ï¼Œä¹Ÿå¯ä»¥åè¿‡æ¥ã€‚\næ³¨æ„ Python é‡Œæ²¡æœ‰æœ€å¤§å †ï¼Œæ‰€ä»¥æ”¾å…¥å’Œå–å‡ºæœ€å¤§å †å…ƒç´ çš„æ—¶å€™éƒ½åŠ äº†è´Ÿå·ã€‚\nimport heapq class Solution: def __init__(self): self.max_h, self.min_h = [], [] def Insert(self, num): if len(self.min_h) == len(self.max_h): # ä¸¤å †ç›¸ç­‰ï¼Œä¼˜å…ˆåŠ å…¥å°å † heapq.heappush(self.min_h, -heapq.heappushpop(self.max_h, -num)) else: # åŠ å…¥å¤§å † heapq.heappush(self.max_h, -heapq.heappushpop(self.min_h, num)) def GetMedian(self): if len(self.min_h) == len(self.max_h): return (self.min_h[0] - self.max_h[0]) / 2.0 else: return self.min_h[0] BM49 è¡¨è¾¾å¼æ±‚å€¼ åˆ·æ–°äº†ä¸­ç­‰é¢˜çš„éš¾åº¦ä¸‹é™ï¼ˆx\nclass Solution: def solve(self , s: str) -\u0026gt; int: return eval(s) è¿˜æ˜¯è®¤çœŸåšä¸€ä¸‹å§ï¼Œé¢˜è§£çš„æ–¹æ³•åƒåœ¨å†™æœ‰é™çŠ¶æ€æœºï¼š\n å‡†å¤‡ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªæ”¾æ“ä½œæ•°ï¼Œä¸€ä¸ªæ”¾è¿ç®—ç¬¦ã€‚ä¸ºäº†å…¼é¡¾ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸º +- çš„æƒ…å½¢ï¼Œæ“ä½œæ•°çš„æ ˆä¸­å…ˆæ”¾ä¸ª 0ï¼› é¡ºåºæ‰«æå­—ç¬¦ä¸²ï¼Œå¦‚æœæ˜¯æ•°å­—ï¼Œç»§ç»­è¯»å–ï¼Œç›´åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯æ•°å­—çš„å­—ç¬¦ä¸ºæ­¢ï¼ŒæŠŠæ•°å­—å‹å…¥æ“ä½œæ•°æ ˆï¼› å¦‚æœæ˜¯å·¦æ‹¬å·ï¼Œå‹å…¥è¿ç®—ç¬¦æ ˆï¼› å¦‚æœæ˜¯å³æ‹¬å·ï¼Œå¯¹æ“ä½œæ•°å’Œè¿ç®—ç¬¦è¿›è¡Œå‡ºæ ˆè®¡ç®—ï¼Œç„¶åæŠŠç»“æœå‹å…¥æ“ä½œæ•°æ ˆï¼Œè¿™ä¸ªåŠ¨ä½œä¸€ç›´æŒç»­åˆ°æ“ä½œæ•°æ ˆæ ˆé¡¶å…ƒç´ ä¸ºå·¦æ‹¬å·ä¸ºæ­¢ï¼Œå·¦æ‹¬å·å‡ºæ ˆï¼› å¦‚æœæ˜¯æ“ä½œç¬¦ï¼Œåˆ™å’Œå‰ä¸€ä¸ªæ“ä½œç¬¦çš„è¿ç®—ä¼˜å…ˆçº§è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå°äºç­‰äºå‰ä¸€ä¸ªæ“ä½œç¬¦çš„ä¼˜å…ˆçº§ï¼Œåˆ™å‡ºæ ˆè¿›è¡Œè®¡ç®—ï¼Œä¸€ç›´æŒç»­åˆ°å‰ä¸€ä¸ªæ“ä½œç¬¦ä¼˜å…ˆçº§å°äºå½“å‰æ“ä½œç¬¦ä¼˜å…ˆçº§ä¸ºæ­¢ï¼Œæˆ–è€…è¿ç®—ç¬¦æ ˆä¸ºç©ºï¼› æ“ä½œç¬¦è¿˜æœ‰å¦ä¸€ç§æƒ…å†µï¼š(+,+- è¿™ç§ä¸¤ä¸ªè¿ç®—ç¬¦ç›¸è¿çš„æƒ…å½¢ï¼ˆå‰ä¸€ä¸ªå¯ä»¥æ˜¯æ‹¬å·ï¼‰ï¼Œæ­¤æ—¶ä¸ºäº†å¤„ç†æ–¹ä¾¿ï¼Œéœ€è¦ç»™æ“ä½œæ•°æ ˆæ’å…¥ä¸€ä¸ª 0ï¼› å¯¹äºå…¶ä»–çš„æƒ…å½¢ï¼ˆæ¯”å¦‚ç©ºæ ¼ï¼‰ï¼Œç›´æ¥è·³è¿‡ï¼Œéå†å®Œæˆåè®¡ç®—å¹¶è¿”å›ç»“æœã€‚  class Solution: def solve(self , s: str) -\u0026gt; int: nums, ops, i, s_len, last_is_ops = [], [], 0, len(s), True prior, allnum = {\u0026#39;+\u0026#39;:1, \u0026#39;-\u0026#39;: 1, \u0026#39;*\u0026#39;: 2}, set(str(i) for i in range(10)) func = {\u0026#39;+\u0026#39;: lambda x,y: x+y, \u0026#39;-\u0026#39;: lambda x,y: y-x, \u0026#39;*\u0026#39;: lambda x,y: x*y} while i \u0026lt; s_len: if s[i] in allnum: # å¯èƒ½æœ‰å¤šä½æ•°å­— num = 0 while i \u0026lt; s_len and s[i] in allnum: num, i = num * 10 + int(s[i]), i + 1 nums.append(num) i, last_is_ops = i - 1, False elif s[i] == \u0026#39;(\u0026#39;: # å‡ºç°å·¦æ‹¬å· ops.append(s[i]) last_is_ops = True elif s[i] == \u0026#39;)\u0026#39;: # å‡ºç°å³æ‹¬å·ï¼Œå‡ºæ ˆå¹¶è®¡ç®—ç»“æœï¼Œlast_is_ops==False ä¿æŒä¸å˜ while ops and ops[-1] != \u0026#39;(\u0026#39;: nums.append(func[ops.pop()](nums.pop(), nums.pop())) ops.pop() elif s[i] in prior: # å‡ºç°è¿ç®—ç¬¦ï¼Œå¦‚æœä¼˜å…ˆçº§\u0026lt;=ä¸Šä¸€ä¸ªï¼Œå¯¹ä¸Šä¸€ä¸ªè¿ç®—ç¬¦è¿›è¡Œè®¡ç®— if last_is_ops: # å¤„ç† (+, +- è¿™ç§ç‰¹æ®Šæƒ…å½¢ nums.append(0) while ops and ops[-1] != \u0026#39;(\u0026#39; and prior[ops[-1]] \u0026gt;= prior[s[i]]: nums.append(func[ops.pop()](nums.pop(), nums.pop())) ops.append(s[i]) last_is_ops = True i = i + 1 while ops: # æŠŠå‰©ä½™çš„è®¡ç®—å®Œï¼Œä¸€èˆ¬åªå‰©ä¸‹ a+b*c,a-b*c nums.append(func[ops.pop()](nums.pop(), nums.pop())) return nums[-1] å†™äº† 30 è¡Œä»£ç ï¼Œæ„Ÿè§‰åƒè¿‡äº†åŠä¸ªä¸–çºªğŸ˜‚\n","date":"2022-04-06T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-04/","title":"åšé¢˜ç¬”è®°04ï¼šå †/æ ˆ/é˜Ÿåˆ—"},{"content":"BM23 äºŒå‰æ ‘çš„å‰åºéå† ç»§ç»­è®°æ¨¡æ¿ï¼\nclass Solution: def preorderTraversal(self , root: TreeNode) -\u0026gt; List[int]: result = [] self.preOrder(root, result) return result def preOrder(self, root, result): if not root: return None else: result.append(root.val) self.preOrder(root.left, result) self.preOrder(root.right, result) BM24 äºŒå‰æ ‘çš„ä¸­åºéå† ç›´æ¥ä½¿ç”¨é€’å½’è¶…å‡ºç³»ç»Ÿé™åˆ¶äº†ï¼Œè™½ç„¶å¯ä»¥ä½¿ç”¨ä½œå¼Šå™¨ï¼š\nimport sys sys.setrecursionlimit(100000) ä½†è¿˜æ˜¯å­¦ä¹ ä¸€ä¸‹éé€’å½’çš„å†™æ³•å§ï¼š\nclass Solution: def inorderTraversal(self , root: TreeNode) -\u0026gt; List[int]: result = [] self.inOrder(root, result) return result def preOrder(self, root, result): # å‰åºï¼Œâ€œæ ¹å·¦å³â€ if not root: return None stack = [root] while stack: top = stack.pop() result.append(top.val) if top.right: # ä¼˜å…ˆåŠ å…¥å³ç»“ç‚¹ï¼Œå› ä¸ºæ˜¯æ ˆï¼Œå·¦ç»“ç‚¹ä¼šå…ˆå‡ºæ¥ stack.append(top.right) if top.left: stack.append(top.left) def inOrder(self, root, result): # ä¸­åºï¼Œâ€œå·¦æ ¹å³â€ if not root: return None stack = [] while root: # å·¦ stack.append(root) root = root.left while stack: # root æ˜¯å½“å‰è®¿é—®çš„ç»“ç‚¹ node = stack.pop() # æ ¹ result.append(node.val) root = node.right # å³ while root: stack.append(root) root = root.left BM25 äºŒå‰æ ‘çš„ååºéå† ååºçš„éé€’å½’ç‰ˆæœ¬å¹¶ä¸å¥½å†™ï¼Œæœ€ç®€å•çš„åšæ³•ä¼¼ä¹æ˜¯æŠŠå‰åºéå†åè½¬ä¸€ä¸‹ï¼š\nclass Solution: def postorderTraversal(self , root: TreeNode) -\u0026gt; List[int]: result = [] self.postOrder(root, result) return result[::-1] def postOrder(self, root, result): # ååº1ï¼Œå‰åºâ€œæ ¹å³å·¦â€ï¼Œåè½¬åœ¨ä¸Šé¢ if not root: return None stack = [root] while stack: top = stack.pop() result.append(top.val) if top.left: stack.append(top.left) if top.right: stack.append(top.right) def postOrder2(self, root, result): # ååº2ï¼Œâ€œå·¦å³æ ¹â€ if not root: return None stack = [root] while stack: top = stack.pop() # æ ¹ if top: stack.append(top) stack.append(None) # æ ‡è®°æ­¤ç»“ç‚¹å·²ç»è®¿é—®è¿‡ if top.right: # å³ stack.append(top.right) if top.left: # å·¦ stack.append(top.left) else: result.append(stack.pop().val) BM26 æ±‚äºŒå‰æ ‘çš„å±‚åºéå† ç›¸å¯¹ç®€å•ï¼Œä½¿ç”¨é˜Ÿåˆ—ä¸€å±‚ä¸€å±‚æ‰«æå³å¯ï¼š\nclass Solution: def levelOrder(self , root: TreeNode) -\u0026gt; List[List[int]]: if not root: return from collections import deque result, queue = [], deque([root]) while queue: tmp = [] for _ in range(len(queue)): node = queue.popleft() tmp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(tmp) return result æ¯”è¾ƒæœ‰è¶£çš„æ˜¯é€’å½’çš„å†™æ³•ï¼Œç„¶è€Œç›´æ¥ Stack Overflowâ€¦â€¦\nBM27 æŒ‰ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘ å±‚åºéå†+åˆ¤æ–­æ­£è´Ÿï¼Œä¹Ÿå¾ˆç®€å•ã€‚\nclass Solution: def Print(self , root: TreeNode) -\u0026gt; List[List[int]]: if not root: return from collections import deque result, queue, tik = [], deque([root]), True while queue: tmp = [] for _ in range(len(queue)): node = queue.popleft() tmp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if tik: result.append(tmp) else: result.append(tmp[::-1]) tik = (not tik) return result BM28 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ ä¾ç„¶æ˜¯å±‚åºéå†ã€‚\nclass Solution: def maxDepth(self , root: TreeNode) -\u0026gt; int: if not root: return 0 from collections import deque queue, depth = deque([root]), 0 while queue: for _ in range(len(queue)): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) depth = depth + 1 return depth BM29 äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„(ä¸€) æœ¬æ¥ä»¥ä¸ºå¾ˆç®€å•ï¼Œä½†å†™èµ·æ¥æ„å¤–ä¸é¡ºæ‰‹ï¼Œæœ€åè¿˜æ˜¯åŸºäºååºéå†çš„ä»£ç ä¿®æ”¹ã€‚åªè¦å†åŠ ä¸€ä¸ªæ ˆï¼Œå°±å¯ä»¥è·å¾—å®Œæ•´çš„è·¯å¾„ã€‚\nclass Solution: def hasPathSum(self , root: TreeNode, sumup: int) -\u0026gt; bool: if not root: return False stack, count = [root], 0 while stack: node = stack.pop() if node: stack.extend([node, None]) count += node.val if node.right: stack.append(node.right) if node.left: stack.append(node.left) else: node = stack.pop() if (not node.left) and (not node.right) and count == sumup: # å¶å­ç»“ç‚¹ return True else: count -= node.val return False BM30 äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨ ä¸­åºéå†ï¼ŒäºŒå‰æ ‘çš„é¢˜ç›®å†™èµ·æ¥æ„å¤–æ£˜æ‰‹â€¦â€¦\nclass Solution: def Convert(self , root ): if not root: return None stack, pre = [], None # ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆè®°å½•çŠ¶æ€ while root: # å·¦ stack.append(root) root = root.left while stack: # root æ˜¯å½“å‰è®¿é—®çš„ç»“ç‚¹ node = stack.pop() # æ ¹ root = node.right # å³ node.left = pre if pre: pre.right = node else: head = node pre = node while root: stack.append(root) root = root.left return head BM31 å¯¹ç§°çš„äºŒå‰æ ‘ ä»”ç»†æƒ³æƒ³ï¼Œå¥½åƒä»»ä½•ä¸€ç§éå†æ–¹å¼éƒ½å¯ä»¥ï¼Œåªè¦æŠŠå·¦å³é¢ å€’è¿‡æ¥éå†ï¼Œå†æ¯”è¾ƒå³å¯ã€‚\nè¿™é‡Œä½¿ç”¨å±‚åºéå†ï¼Œä¸è¿‡è¦æ³¨æ„ï¼Œå…ƒç´ ä¸ºç©ºä¹Ÿæ˜¯ä¸€ç§éœ€è¦æ¯”è¾ƒçš„çŠ¶æ€â€¦â€¦\nclass Solution: def isSymmetrical(self , root: TreeNode) -\u0026gt; bool: if not root: return True queue_left, queue_right = [root], [root] while queue_left and queue_right: node_left = queue_left.pop() node_right = queue_right.pop() if node_left and node_right: # åŒæ—¶å­˜åœ¨ if node_left.val != node_right.val: return False else: queue_left.append(node_left.left) # ç©ºçŠ¶æ€ä¹Ÿè¦è®°å½• queue_left.append(node_left.right) queue_right.append(node_right.right) queue_right.append(node_right.left) elif (not node_left) and (not node_right): # åŒæ—¶ä¸ºç©º pass else: return False return (not queue_left) and (not queue_right) BM32 åˆå¹¶äºŒå‰æ ‘ åŒæ ·æ˜¯ä»»ä½•ä¸€ç§éå†æ–¹å¼éƒ½å¯ä»¥ï¼Œä¾ç„¶æ˜¯å±‚åºï¼š\nclass Solution: def mergeTrees(self , t1: TreeNode, t2: TreeNode) -\u0026gt; TreeNode: if not t1: return t2 if not t2: return t1 head = TreeNode(t1.val + t2.val) queue1, queue2, queue = [t1], [t2], [head] while queue1 and queue2: node1, node2, node = queue1.pop(), queue2.pop(), queue.pop() if node1.left and node2.left: node.left = TreeNode(node1.left.val + node2.left.val) queue.append(node.left) queue1.append(node1.left) queue2.append(node2.left) elif node1.left: node.left = node1.left elif node2.left: node.left = node2.left else: pass if node1.right and node2.right: node.right = TreeNode(node1.right.val + node2.right.val) queue.append(node.right) queue1.append(node1.right) queue2.append(node2.right) elif node1.right: node.right = node1.right elif node2.right: node.right = node2.right else: pass return head BM33 äºŒå‰æ ‘çš„é•œåƒ çˆ±ä¸Šäº†å±‚åºâ€¦â€¦\nclass Solution: def Mirror(self , root: TreeNode) -\u0026gt; TreeNode: if not root: return root queue = [root] while queue: node = queue.pop() node.left, node.right = node.right, node.left # åŸåœ°é•œåƒ if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root BM34 åˆ¤æ–­æ˜¯ä¸æ˜¯äºŒå‰æœç´¢æ ‘ åˆæ˜¯ä¸­åºéå†â€¦â€¦\nclass Solution: def isValidBST(self , root: TreeNode) -\u0026gt; bool: if not root: return False stack, pre = [], -2**32-1 while root: stack.append(root) root = root.left while stack: node = stack.pop() if not node.val \u0026gt; pre: return False else: pre = node.val root = node.right while root: stack.append(root) root = root.left return True BM35 åˆ¤æ–­æ˜¯ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘ åˆæ˜¯å±‚åºéå†ã€‚\nclass Solution: def isCompleteTree(self , root: TreeNode) -\u0026gt; bool: if not root: return True from collections import deque queue, flag = deque([root]), False # æ ‡è®°æ˜¯å¦å‡ºç°å¶å­ç»“ç‚¹ while queue: for _ in range(len(queue)): node = queue.popleft() if node: if flag: # ä¹‹å‰æœ‰ç©ºç»“ç‚¹ return False else: queue.extend([node.left, node.right]) else: # å‡ºç°ç©ºç»“ç‚¹ flag = True return True # éå†å®Œæˆï¼Œæ²¡æœ‰ä¸­é€”é€€å‡ºï¼Œæ˜¯å®Œå…¨äºŒå‰æ ‘ BM36 åˆ¤æ–­æ˜¯ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘ ç¾å¥½çš„ä¸€å¤©ä»ä¸€é“â€œç®€å•â€é¢˜å¼€å§‹ğŸ˜­\næ–¹æ³•ä¸€ï¼šé€’å½’ï¼ˆCreditï¼šå®˜æ–¹è§£ç­”ï¼‰ å…¶å®å°±æ˜¯è¦å†™ä¸€ä¸ªé€’å½’è®¡ç®—äºŒå‰æ ‘æ·±åº¦çš„å‡½æ•°ï¼Œå‘ç°ä¸å¹³è¡¡ç«‹åˆ»è¿”å› Falseï¼š\nclass Solution: def IsBalanced_Solution(self , root: TreeNode) -\u0026gt; bool: return self.height(root) \u0026gt;= 0 # èƒ½æ±‚å‡ºé«˜åº¦å°±æ˜¯å¹³è¡¡äºŒå‰æ ‘ def height(self, root: TreeNode) -\u0026gt; int: if not root: # ç©ºç»“ç‚¹ï¼Œé«˜åº¦è‡ªç„¶æ˜¯ 0 return 0 else: leftHeight = self.height(root.left) rightHeight = self.height(root.right) if leftHeight == -1 or rightHeight == -1 or abs(leftHeight - rightHeight) \u0026gt; 1: return -1 else: return max(leftHeight, rightHeight) + 1 æ–¹æ³•äºŒï¼šååºéå† ç±»ä¼¼ BM29ï¼Œä½¿ç”¨ä¸€ä¸ªå­—å…¸å­˜å‚¨æ¯ä¸ªç»“ç‚¹çš„æ·±åº¦ï¼š\nclass Solution: def IsBalanced_Solution(self , root: TreeNode) -\u0026gt; bool: if not root: return True stack, height = [root], {None: 0} while stack: root = stack.pop() if root: stack.extend([root, None]) if root.left: # ä¸å°å¿ƒå†™åäº†ï¼ stack.append(root.left) if root.right: stack.append(root.right) else: node = stack.pop() if abs(height[node.left] - height[node.right]) \u0026gt; 1: return False else: height[node] = max(height[node.left], height[node.right]) + 1 return True BM37 äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ å·æ‡’äº†ï¼Œæ€ä¹ˆç®€å•æ€ä¹ˆå†™ã€‚\nclass Solution: def lowestCommonAncestor(self , root: TreeNode, p: int, q: int) -\u0026gt; int: while root: if p \u0026lt; root.val and q \u0026lt; root.val: root = root.left elif p \u0026gt; root.val and q \u0026gt; root.val: root = root.right else: return root.val BM38 åœ¨äºŒå‰æ ‘ä¸­æ‰¾åˆ°ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ å°±å¾ˆæœ´ç´ ï¼š\n ååºéå†äºŒå‰æ ‘ï¼Œæ‰¾åˆ°å‰å¾€ä¸¤ä¸ªç»“ç‚¹çš„è·¯å¾„ï¼› æŒ‰é¡ºåºé€ä¸ªæ¯”è¾ƒè·¯å¾„ä¸­çš„æ¯ä¸ªç»“ç‚¹ï¼Œæ‰¾åˆ°æœ€åä¸€ä¸ªç›¸åŒçš„å¹¶è¿”å›ã€‚  å¥‡æ€ªçš„æ˜¯ï¼Œå¦‚æœç”¨æ•°ç»„ä¿å­˜ TreeNode çš„è¯ï¼Œåœ¨æ¯”è¾ƒç›¸ç­‰çš„æ—¶å€™ä¼šå‡ºé—®é¢˜â€¦â€¦\nclass Solution: def lowestCommonAncestor(self , root: TreeNode, o1: int, o2: int) -\u0026gt; int: from os.path import commonprefix if not root: return None stack, path, path1, path2 = [root], [], [], [] while stack: node = stack.pop() if node: stack.extend([node, None]) path.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) else: node = stack.pop() if node.val == o1: path1 = path.copy() # æµ…å¤åˆ¶ if node.val == o2: path2 = path.copy() path.pop() return commonprefix([path1, path2])[-1] BM39 åºåˆ—åŒ–äºŒå‰æ ‘ æ ‡å‡†ç­”æ¡ˆæ˜¯æŒ‰å‰åºå’Œä¸­åºéå†åšçš„ï¼Œè¿˜æ˜¯å–œæ¬¢å±‚åºï¼ˆå› ä¸ºå®˜æ–¹ä½¿ç”¨çš„å°±æ˜¯å±‚åºï¼‰ï¼Œè™½ç„¶ä¸éš¾ï¼Œä½†æ˜¯å¾ˆé•¿â€¦â€¦\nclass Solution: def Serialize(self, root): if not root: return \u0026#39;{}\u0026#39; from collections import deque result, queue = \u0026#39;\u0026#39;, deque([root]) while any(queue): for _ in range(len(queue)): node = queue.popleft() if node: queue.extend([node.left, node.right]) if result: result += \u0026#34;,\u0026#34; + str(node.val) else: result += \u0026#34;{\u0026#34; + str(node.val) else: queue.extend([None, None]) result += \u0026#34;,#\u0026#34; return result + \u0026#34;}\u0026#34; def Deserialize(self, s): if s == \u0026#34;{}\u0026#34;: return None from collections import deque data = s[1:-1].split(\u0026#39;,\u0026#39;) root = TreeNode(0) queue = deque([root]) for s in range(len(data)): if data[s] != \u0026#39;#\u0026#39;: head = queue.popleft() head.val = int(data[s]) if 2 * (s + 1) \u0026lt; len(data): # ç¼–å·ä¸º N çš„ç»“ç‚¹å­ç»“ç‚¹ç¼–å·ä¸º 2N, 2N+1ï¼Œå¯¹åº”çš„æ•°ç»„åæ ‡ä¸º N-1 if data[2 * (s + 1) - 1] != \u0026#39;#\u0026#39;: head.left = TreeNode(0) queue.append(head.left) if data[2 * (s + 1)] != \u0026#39;#\u0026#39;: head.right = TreeNode(0) queue.append(head.right) else: # åˆ°è¾¾æœ€åº•å±‚ pass else: # ç©ºç»“ç‚¹ pass return root BM40 é‡å»ºäºŒå‰æ ‘ æ˜æ˜è¿™é¢˜æ›´éš¾ä¸€ç‚¹ğŸ˜­é¢˜è§£çš„åšæ³•æ˜¯é€’å½’ï¼š\n æ‰¾åˆ°å‰åºéå†çš„ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œå³ä¸ºæ ¹ç»“ç‚¹ï¼› æ‰¾åˆ°ä¸­åºéå†ä¸­æ ¹ç»“ç‚¹æ‰€åœ¨çš„ä½ç½®ï¼Œæ ¹ç»“ç‚¹å·¦è¾¹çš„ç»“ç‚¹å³ä¸ºå·¦å­æ ‘ï¼Œå³è¾¹çš„ç»“ç‚¹å³ä¸ºå³å­æ ‘ï¼› åŒæ ·å¯¹å‰åºéå†çš„ç»“ç‚¹è¿›è¡Œå·¦å³å­æ ‘çš„åˆ‡åˆ†ï¼Œé€’å½’åšä¸‹å»å³å¯ã€‚  class Solution: def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -\u0026gt; TreeNode: if not len(pre) or not len(vin): return None root = TreeNode(pre[0]) root_index = vin.index(pre[0]) root.left = self.reConstructBinaryTree(pre[1:root_index+1], vin[0:root_index]) root.right = self.reConstructBinaryTree(pre[root_index+1:], vin[root_index+1:]) return root å¦‚æœä¸ä½¿ç”¨é€’å½’ï¼Œè€ƒè™‘ä½¿ç”¨æ ˆä½œä¸ºè¾…åŠ©å­˜å‚¨ï¼š\n ä»å‰åºéå†è¯»å–ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œæ ˆä¸ºç©ºï¼Œæ–°å»ºç»“ç‚¹åæ”¾å…¥æ ˆä¸­ï¼› ä»å‰åºéå†ä¸­è¯»å–ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè®¡ç®—ä¸­åºç´¢å¼•ï¼Œå¹¶ä¸æ ˆä¸­çš„ç»“ç‚¹åœ¨ä¸­åºä¸­çš„ç´¢å¼•å¤§å°è¿›è¡Œæ¯”è¾ƒï¼› å¦‚æœå°äºæ ˆæœ€åä¸€ä¸ªç»“ç‚¹çš„ç´¢å¼•ï¼Œè¯´æ˜æ˜¯æ ˆæœ€åä¸€ä¸ªç»“ç‚¹çš„å·¦å­ç»“ç‚¹ï¼Œå…¥æ ˆï¼› å¦‚æœå¤§äºæ ˆæœ€åä¸€ä¸ªç»“ç‚¹çš„ç´¢å¼•ï¼Œè¯´æ˜è¿™ä¸ªç»“ç‚¹ä¸€å®šæ˜¯æ ˆä¸­æŸä¸ªå…ƒç´ çš„å³ç»“ç‚¹ï¼Œä»¥åæ–¹å‘éå†æ ˆï¼Œæ‰¾åˆ°æ ˆä¸­ä¸­åºç´¢å¼•æ¯”ç»“ç‚¹ç´¢å¼•å°ä¸”è·ç¦»æœ€å°çš„ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œå°±æ˜¯æ‰€æ±‚çš„ç¥–å…ˆã€‚  ç»ˆäºå†™å‡ºæ¥äº†ï¼Œç„¶è€Œæ•ˆç‡å¹¶ä¸å¦‚é€’å½’â€¦â€¦\nclass Solution: def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -\u0026gt; TreeNode: if not len(pre) or not len(vin): return None stack, vin_index, tmp = [], dict((j,i) for i,j in enumerate(vin)), [] for val in pre: if not stack: # åˆšå¼€å§‹ æ ˆä¸ºç©º stack.append(TreeNode(val)) tmp.append(val) else: # æ ˆä¸ä¸ºç©ºï¼Œå¼€å§‹æ¯”è¾ƒç»“ç‚¹ while stack[-1].val != val: # ç»“ç‚¹æœªå…¥æ ˆ if vin_index[val] \u0026lt; vin_index[stack[-1].val]: # å°äºæœ€åä¸€ä¸ªç»“ç‚¹ï¼Œä¸ºå·¦å­ç»“ç‚¹ stack[-1].left = TreeNode(val) stack.append(stack[-1].left) tmp.append(val) else: # æ˜¯æŸä¸ªç¥–å…ˆçš„å³ç»“ç‚¹ closest_index = -1 # ä¸­åºéå†æ ˆä¸­ç¦»ç»“ç‚¹æœ€è¿‘çš„å·¦è¾¹ç»“ç‚¹åæ ‡ for node in reversed(stack): if vin_index[node.val] \u0026lt; vin_index[val]: if vin_index[node.val] \u0026gt; closest_index: closest_index = vin_index[node.val] if closest_index == vin_index[val] - 1: break else: # ä¼¼ä¹å¯ä»¥å†ä¼˜åŒ–ä¸€ä¸‹â€¦â€¦ pass else: # é‡åˆ°å³è¾¹çš„ç»“ç‚¹ï¼Œåœæ­¢ break while vin_index[stack[-1].val] != closest_index: stack.pop() tmp.pop() stack[-1].right = TreeNode(val) stack.append(stack[-1].right) tmp.append(val) return stack[0] BM41 è¾“å‡ºäºŒå‰æ ‘çš„å³è§†å›¾ åˆæ˜¯å±‚åºéå†ï¼æ”¶å·¥ğŸ‘\nclass Solution: def solve(self , pre: List[int], vin: List[int]) -\u0026gt; List[int]: tree = self.reConstructBinaryTree(pre, vin) if not tree: return [] from collections import deque queue, result = deque([tree]), [] while queue: for _ in range(len(queue)): node = queue.popleft() val = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(val) return result ","date":"2022-04-03T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-03/","title":"åšé¢˜ç¬”è®°03ï¼šäºŒå‰æ ‘"},{"content":"BM17 äºŒåˆ†æŸ¥æ‰¾-I å­¦ä¹ å¥—æ¨¡ç‰ˆï¼ˆé—­åŒºé—´æœç´¢ï¼‰ï¼Œè¿™ä¸ªæ¨¡ç‰ˆè¿˜å¯ä»¥ç”¨äºæœ‰é‡å¤æ•°å­—æ—¶æœç´¢å·¦ä¾§å’Œå³ä¾§è¾¹ç•Œï¼ˆåªè¦ä¿®æ”¹ target == nums[mid] å³å¯ï¼‰ã€‚\nclass Solution: def search(self , nums: List[int], target: int) -\u0026gt; int: left, right = 0, len(nums) - 1 # ä½¿ç”¨é—­åŒºé—´ [0, length-1] åšäºŒåˆ†æŸ¥æ‰¾ while left \u0026lt;= right: # å› ä¸ºæ˜¯é—­åŒºé—´ï¼Œç»ˆæ­¢æ¡ä»¶ä¸º left\u0026gt;right å³ [left, right] ä¸ºç©º mid = left + (right - left) // 2 # æ¨¡ç‰ˆçš„é˜²æº¢å‡ºï¼Œè™½ç„¶ Python ä¸ç”¨ç®¡ if target == nums[mid]: return mid elif target \u0026gt; nums[mid]: # æœç´¢åŒºé—´æ”¹ä¸º [mid+1, length-1] left = mid + 1 elif target \u0026lt; nums[mid]: # æœç´¢åŒºé—´æ”¹ä¸º [0, mid-1] right = mid - 1 return -1 # æ²¡æ‰¾åˆ°ç»“æœ BM18 äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾ å·¦ä¸Šè§’æ˜¯æœ€å°çš„æ•°ï¼Œå³ä¸‹è§’æ˜¯æœ€å¤§çš„æ•°ï¼Œå‡å¦‚ä»å·¦ä¸Šè§’å¼€å§‹ï¼Œå¦‚æœ target æ¯”å·¦ä¸Šè§’çš„æ•°å¤§ï¼Œå°±æœ‰ä¸¤æ¡å¯èƒ½çš„è·¯å¾„ã€‚è™½ç„¶ä¸æ˜¯ä¸èƒ½åšï¼Œä½†æœ‰æ²¡æœ‰æ›´ç®€å•çš„åšæ³•ï¼Ÿ\næ•°ç»„ä¸­æœ‰ä¸¤ä¸ªç‰¹æ®Šçš„ä½ç½®åªæœ‰ä¸€æ¡è·¯å¾„ï¼šå³ä¸Šè§’å’Œå·¦ä¸‹è§’ã€‚å¦‚æœä»¥å³ä¸Šè§’ä½œä¸ºé¡¶ç‚¹ï¼Œæ¯ä¸ªå…ƒç´ çš„å·¦å…ƒç´ å’Œä¸‹å…ƒç´ ä½œä¸ºå­ç»“ç‚¹ï¼Œä¸éš¾çœ‹åˆ°è¿™æ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘ã€‚\nclass Solution: def Find(self , target: int, array: List[List[int]]) -\u0026gt; bool: i, j = 0, len(array[0]) - 1 # i æ˜¯çºµåæ ‡ï¼Œ j æ˜¯æ¨ªåæ ‡ï¼Œä»å³ä¸Šè§’å¼€å§‹ while j \u0026gt;= 0 and i \u0026lt; len(array) and target != array[i][j]: if target \u0026lt; array[i][j]: j = j - 1 elif target \u0026gt; array[i][j]: i = i + 1 return (j \u0026gt;= 0 and i \u0026lt; len(array)) BM19 å¯»æ‰¾å³°å€¼ å¾ˆæ— èŠçš„ä¸€é“é¢˜ï¼Œä¸ºäº†ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ç”Ÿé€ å‡ºæ¥çš„æ„Ÿè§‰â€¦â€¦\nå‡ºå‘ç‚¹å¤§æ¦‚æ˜¯ï¼Œæ³¨æ„åˆ°å¦‚æœä¸­é—´å…ƒç´ æ¯”å³è¾¹å…ƒç´ å¤§ï¼Œåˆ™ä¸­é—´å…ƒç´ å¯èƒ½æ˜¯å³°å€¼ï¼Œå¦‚æœä¸æ˜¯ï¼Œä¸­é—´å…ƒç´ çš„å·¦è¾¹ä¸€å®šæ¯”ä¸­é—´å…ƒç´ å¤§ï¼Œä¹Ÿå¯èƒ½æ˜¯å³°å€¼â€¦â€¦å¦‚æœæœ€å·¦è¾¹å…ƒç´ æ˜¯æœ€å¤§å€¼ç„¶åä¸€ç›´é€’å‡ï¼ŒæŒ‰ç…§é¢˜ç›®çš„æ¡ä»¶ï¼Œæœ€å·¦è¾¹å…ƒç´ ä¹Ÿç®—æ˜¯å³°å€¼ï¼Œå› æ­¤ä¸€å®šæœ‰å³°å€¼åœ¨ [0, mid] ä¹‹é—´ã€‚åŒç†ï¼Œå¦‚æœä¸­é—´å…ƒç´ æ¯”å³è¾¹å…ƒç´ å°ï¼Œä¸€å®šæœ‰å³°å€¼åœ¨ [mid+1, length-1]ï¼š\nclass Solution: def findPeakElement(self , nums: List[int]) -\u0026gt; int: left, right = 0, len(nums) - 1 while left \u0026lt; right: mid = left + (right - left) // 2 if nums[mid] \u0026gt; nums[mid+1]: # æœç´¢åŒºé—´å˜æˆ [0, mid] right = mid else: # æœç´¢åŒºé—´å˜æˆ [mid + 1, length-1] left = mid + 1 return right # åŒºé—´ä¸€ç›´åœ¨æ”¶ç¼©ï¼Œç›´åˆ° left == right BM20 æ•°ç»„ä¸­çš„é€†åºå¯¹ ç»ˆäºé‡åˆ°ç¬¬ä¸€é“çœŸæ­£æ„ä¹‰ä¸Šçš„éš¾é¢˜ğŸ˜­\næ–¹æ³•ä¸€ï¼šå½’å¹¶æ’åºï¼ˆCreditï¼šã€Šå‰‘æŒ‡Offerã€‹ï¼‰ æœ€å®¹æ˜“æƒ³åˆ°çš„è®¡ç®—æ–¹å¼æ˜¯æŒ‰å®šä¹‰è®¡ç®—ï¼Œå¦‚ {7,5,6,4} çš„æ­¥éª¤å¦‚ä¸‹ï¼š\n æŠŠ 7 å’Œç»“æœä¸­çš„æ•°æ¯”è¾ƒï¼ˆ{}ï¼‰ï¼Œé€†åºæ•°ä¸º 0ï¼Œæ”¾å…¥ç»“æœä¸­ï¼› æŠŠ 5 å’Œç»“æœä¸­çš„æ•°æ¯”è¾ƒï¼ˆ{7}ï¼‰ï¼Œé€†åºæ•°ä¸º 1ï¼Œæ”¾å…¥ç»“æœä¸­ï¼› æŠŠ 6 å’Œç»“æœä¸­çš„æ•°æ¯”è¾ƒï¼ˆ{7,5}ï¼‰ï¼Œé€†åºæ•°ä¸º 1ï¼Œæ”¾å…¥ç»“æœä¸­ï¼› æŠŠ 4 å’Œç»“æœä¸­çš„æ•°æ¯”è¾ƒï¼ˆ{7,5,6}ï¼‰ï¼Œé€†åºæ•°ä¸º 3ï¼Œæ”¾å…¥ç»“æœä¸­ï¼› ç»“æŸï¼Œæ€»çš„é€†åºæ•°ä¸º 0+1+1+3=5ã€‚  æ˜¾ç„¶ç›´æ¥è®¡ç®—æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n^2)ï¼Œä¸èƒ½æ»¡è¶³é¢˜ç›®è¦æ±‚ï¼Œæœ‰æ²¡æœ‰åˆ«çš„æ–¹æ³•å‘¢ï¼Ÿè¯•è¯•é‡‡ç”¨åˆ†æ²»æ³•ï¼Œæ¯”å¦‚å½’å¹¶æ’åºï¼š\n æŠŠ {7,5,6,4} ä¾æ¬¡åˆ’åˆ†æˆæœ€å°çš„éƒ¨åˆ†ï¼Œå³ {7},{5},{6},{4}ï¼› å°è¯•åˆå¹¶ï¼š{7}{5} æ¯”è¾ƒæœ€åä¸€ä½çš„å¤§å°ï¼Œå› ä¸º 7\u0026gt;5ï¼Œé€†åºæ•°ä¸º 1ï¼ŒæŒ‰é¡ºåºåˆæˆ {5,7}ï¼›{6}{4} æ¯”è¾ƒæœ€åä¸€ä½çš„å¤§å°ï¼Œå› ä¸º 6\u0026gt;4ï¼Œé€†åºæ•°ä¸º 1ï¼ŒæŒ‰é¡ºåºæ•´ç†æˆ {4,6}ï¼› æ¥ä¸‹æ¥éœ€è¦æ¯”è¾ƒ {5,7} å’Œ {4,6} çš„é€†åºæ•°ï¼Œé¦–å…ˆæ¯”è¾ƒæœ€åä¸€ä½ï¼Œå› ä¸º 7\u0026gt;6ï¼Œå³ {4,6} æ‰€æœ‰æ•°éƒ½æ¯” 7 å°ï¼Œé€†åºæ•° +2ï¼Œç»“æœæ”¾å…¥ {7}ï¼ŒæŒ‡é’ˆå·¦ç§»ï¼› æŒ‡é’ˆå·¦ç§»åï¼Œæ¯”è¾ƒçš„æ˜¯ {5,6} çš„å¤§å°ï¼Œå› ä¸º 5\u0026lt;6ï¼Œé€†åºæ•°ä¸º 0ï¼ŒæŠŠ 6 æ”¾å…¥ç»“æœä¸­ï¼Œå˜æˆ {6,7}ï¼ŒæŒ‡é’ˆå·¦ç§»ï¼› ä»¥æ­¤ç±»æ¨ï¼Œç°åœ¨æ¯”è¾ƒçš„æ˜¯ {5,4} çš„å¤§å°ï¼Œå› ä¸º 5\u0026gt;4ï¼Œé€†åºæ•°ä¸º 1ï¼ŒæŠŠ 5 æ”¾å…¥ç»“æœä¸­ï¼Œå˜æˆ {5,6,7}ï¼ŒæŒ‡é’ˆå·¦ç§»ï¼› æœ€åæŠŠ {4} æ”¾å…¥ç»“æœä¸­å³å¯ï¼Œé€†åºæ•°ä¸º 1+1+2+0+1=5ã€‚  è®¨åŒé€’å½’â€¦â€¦å‚è€ƒäº†é¢˜è§£çš„ä»£ç ï¼š\nclass Solution: def InversePairs(self, data: List[int]) -\u0026gt; int: return self.MergeSort(data)[1] % 1000000007 def MergeSort(self, data: List[int]): # è¿”å›æ’å¥½åºçš„æ•°æ®å’Œé€†åºæ•° # 1. å…ˆå†™é€€å‡ºæ¡ä»¶ï¼Œå³åªæœ‰ 0 ä¸ªæˆ–ä¸€ä¸ªå…ƒç´ çš„æƒ…å½¢ if len(data) \u0026lt;= 1: return (data, 0) else: # 2. å¯»æ‰¾ä¸­ç‚¹ï¼ŒæŠŠæ•°ç»„åˆ‡å‰²æˆä¸¤éƒ¨åˆ† mid = len(data) // 2 left, left_inverse = self.MergeSort(data[:mid]) right, right_inverse = self.MergeSort(data[mid:]) result = [] count_inverse = left_inverse + right_inverse # 3. å¼€å§‹è¿›è¡Œå½’å¹¶æ’åº l, r = 0, 0 while l \u0026lt; len(left) and r \u0026lt; len(right): if left[l] \u0026lt;= right[r]: # å·¦è¾¹ \u0026lt; å³è¾¹ï¼Œé€†åºæ•°ä¸º 0 result.append(left[l]) l += 1 else: # å·¦è¾¹ \u0026gt; å³è¾¹ï¼Œé€†åºæ•°ä¸ºå·¦è¾¹æŒ‡é’ˆå³è¾¹æ‰€æœ‰å…ƒç´ ä¸ªæ•°ï¼ˆå«ï¼‰ count_inverse += len(left) - l result.append(right[r]) r += 1 result += left[l:] + right[r:] # æ¯”è¾ƒç»“æŸï¼Œæ¥ä¸Šå‰©ä¸‹çš„å…ƒç´  return result, count_inverse æ–¹æ³•äºŒï¼šå¿«é€Ÿæ’åºï¼ˆCreditï¼šé¢˜è§£ï¼‰ åŒæ ·æ˜¯åˆ†æ²»ç­–ç•¥ï¼Œæ—¢ç„¶å¯ä»¥ç”¨å½’å¹¶ï¼Œé‚£ä¹ˆèƒ½ä¸èƒ½ç”¨å¿«æ’ï¼Ÿä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºé€†åºæ•°æœ¬è´¨ä¸Šæ˜¯æ¯”è¾ƒæ‰€æœ‰çš„ä¸¤ä¸¤ç»„åˆï¼Œå¿«é€Ÿæ’åºçš„æ—¶å€™ï¼Œé¦–å…ˆé€‰æ‹©ä¸»å…ƒï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œç„¶åæŠŠæ‰€æœ‰æ•°åˆ†æˆå¤§äºä¸»å…ƒå’Œå°äºä¸»å…ƒä¸¤ä¸ªç‹¬ç«‹éƒ¨åˆ†ï¼Œæ­¤æ—¶å°±å®Œæˆäº†ï¼š\n ä¸»å…ƒå’Œæ‰€æœ‰å…¶ä»–å…ƒç´ çš„æ¯”è¾ƒï¼› å¤§äºä¸»å…ƒçš„å…ƒç´ ä¸å°äºä¸»å…ƒçš„å…ƒç´ çš„é€ä¸€ç›¸äº’æ¯”è¾ƒï¼Œå‡†ç¡®çš„è¯´ï¼Œæ˜¯æ‰€æœ‰æ¯”ä¸»å…ƒå°çš„å…ƒç´ ï¼Œå’Œæ’åœ¨è¯¥å…ƒç´ å‰é¢ä¸”å¤§äºä¸»å…ƒçš„å…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼ˆä¸ºä»€ä¹ˆç›¸ç­‰ï¼Ÿå› ä¸ºæ±‚çš„æ˜¯é€†åºæ•°ï¼‰ã€‚  äºæ˜¯æ¥ä¸‹æ¥åªéœ€è¦é€’å½’åœ°å¯¹å¤§äºä¸»å…ƒå’Œå°äºä¸»å…ƒçš„å…ƒç´ åˆ†åˆ«æ‰§è¡Œç›¸åŒæ“ä½œå³å¯ã€‚\nclass Solution: def InversePairs(self, data: List[int]) -\u0026gt; int: return self.QuickSort(data) % 1000000007 def QuickSort(self, data: List[int]): # åŒæ ·å…ˆå†™é€€å‡ºæ¡ä»¶ if len(data) \u0026lt;= 1: return 0 else: bigger, smaller = [], [] count_inverse = 0 pivot = data[0] for num in data[1:]: if num \u0026gt; pivot: bigger.append(num) else: smaller.append(num) count_inverse += len(bigger) + 1 return count_inverse + self.QuickSort(bigger) + self.QuickSort(smaller) æ‰©å±•ï¼šæ ‘çŠ¶æ•°ç»„/çº¿æ®µæ ‘ é¡¾åæ€ä¹‰ï¼Œæ ‘çŠ¶æ•°ç»„å°±æ˜¯é•¿å¾—åƒæ ‘ä¸€æ ·çš„æ•°ç»„ï¼\næ ‘çŠ¶æ•°ç»„çš„ä¼˜ç‚¹æ˜¯å¯ä»¥ä»¥å¯¹æ•°æ—¶é—´å¤æ‚åº¦è·å¾—å…ƒç´ å›ºå®šçš„æ•°åˆ—å‰ N é¡¹çš„å’Œï¼ˆå…¶å®ä»»æ„åŒºé—´çš„å’Œéƒ½å¯ä»¥ï¼‰ï¼Œè¿™å’Œé€†åºæ•°æœ‰ä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿ\nå›é¡¾æœ€å¼€å§‹çš„åšæ³•ï¼Œæˆ‘ä»¬ä»å·¦åˆ°å³æ±‚å‡ºæ¯ä¸ªæ•°ä¹‹å‰æ¯”å®ƒå¤§çš„æ•°çš„ä¸ªæ•°ï¼Œç´¯åŠ èµ·æ¥å°±æ˜¯ç­”æ¡ˆã€‚å¦‚æœå­˜åœ¨æŸç§èƒ½ä»¥ O(log(n)) æ—¶é—´å¤æ‚åº¦è®¡ç®—å‡ºâ€œæ¯”å®ƒå¤§çš„æ•°çš„ä¸ªæ•°â€çš„æ•°æ®ç»“æ„ï¼Œæ—¶é—´å¤æ‚åº¦å°±é™åˆ° O(nlog(n)) äº†ï¼š\n éå†æ•°ç»„ï¼Œäº†è§£æ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ çš„å–å€¼èŒƒå›´ï¼Œå‡è®¾å–å€¼èŒƒå›´ä¸º 0\u0026lt;=x\u0026lt;=1000ï¼Œæ–°å»ºä¸€ä¸ªé•¿åº¦ä¸º 1001 çš„æ ‘çŠ¶æ•°ç»„ï¼ŒæŠŠæ‰€æœ‰å…ƒç´ åˆå§‹æˆ 0ã€‚è¿™ä¸ªæ ‘çŠ¶æ•°ç»„ç”¨äºå­˜å‚¨åˆ°ç›®å‰ä¸ºæ­¢æ¯ä¸ªæ•°å‡ºç°çš„æ¬¡æ•°ã€‚å…¶å®ä¹Ÿæœ‰ä¸åŒçš„åšæ³•ï¼Œæ¯”å¦‚æœ‰çš„äººä¼šå¯¹æ•°ç»„ä¸­çš„å…ƒç´ è¿›è¡Œæ’åºï¼Œå¹¶é‡æ–°ç¼–å·ï¼Œç§°ä¸º ç¦»æ•£åŒ–ï¼› è¯»å–ç¬¬ä¸€ä¸ªå…ƒç´  aï¼ŒæŠŠæ ‘çŠ¶æ•°ç»„ä¸­ a å¯¹åº”çš„æ•°æ® +1ï¼ˆO(log(n))ï¼‰ï¼› æ­¤æ—¶è®¡ç®—æ ‘çŠ¶æ•°ç»„ä¸­ [0, a] åŒºé—´çš„å’Œï¼ˆO(log(n))ï¼‰ï¼Œè¿™ä¸ªå’Œè¡¨ç¤ºç›®å‰ä¸ºæ­¢çš„æ•°ç»„å…ƒç´ ä¸­ \u0026lt;= a çš„å…ƒç´ ä¸ªæ•°ï¼Œä½¿ç”¨å½“å‰çš„ä½ç½® 1 å‡å»å®ƒï¼Œå°±å¾—åˆ°æ­¤å…ƒç´ çš„é€†åºæ•°ï¼› éå†æ•°ç»„æ‰€æœ‰å…ƒç´ ï¼ŒæŠŠæ‰€æœ‰é€†åºæ•°åŠ èµ·æ¥ï¼Œå°±å¾—åˆ°äº†ç­”æ¡ˆã€‚  æ ‘çŠ¶æ•°ç»„å’Œçº¿æ®µæ ‘çš„å®ç°ä»£ç å¯ä»¥å‚è€ƒ OI Wikiï¼Œæ—¢ç„¶è®°ä¸ä½ï¼Œåº”è¯¥ä¸ä¼šè€ƒå§â€¦â€¦\nBM21 æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­— å’Œ BM19 ç±»ä¼¼ï¼Œä¹Ÿæ˜¯ä¸ºäº†è€ƒå¯ŸäºŒåˆ†æŸ¥æ‰¾é€ å‡ºæ¥çš„é¢˜ï¼Œå‡è®¾æ•°ç»„ç”± AB å˜æˆ BAï¼š\n å‡è®¾æ•°æ®ä¸º [3,4,5,1,2]ï¼Œé¦–å…ˆç¡®å®š left=3, mid=5, right=2ï¼› å› ä¸º mid \u0026gt; rightï¼Œæ•°ç»„æ˜¯éé™çš„ï¼Œæ•… mid ä¸€å®šåœ¨ Bï¼Œright ä¸€å®šåœ¨ Aï¼Œæœ€å°å€¼ä¸€å®šåœ¨ [mid+1, right] ä¸­ã€‚æ›´æ–°åŒºé—´è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼› åŒç†ï¼Œå¦‚æœ mid \u0026lt; rightï¼Œè¯´æ˜ mid å’Œ right éƒ½åœ¨ A ä¸­ï¼Œæœ€å°å€¼æ˜¯ B å’Œ A çš„äº¤ç•Œç‚¹ï¼ˆA çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œæ•…ä¸€å®šåœ¨ [left, mid] ä¸­ï¼Œæ›´æ–°åŒºé—´è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼› æœ€åï¼Œå¦‚æœ mid == rightï¼Œå› ä¸ºæ•°ç»„æ˜¯éé™çš„ï¼Œå¯ä»¥è‚¯å®š right ä¸€å®šä¸æ˜¯æœ€å°å€¼ï¼Œæ•…æœç´¢åŒºé—´æ”¹ä¸º [left, right-1]ï¼› åŒºé—´ä¸æ–­ç¼©å°ï¼Œå½“ left == right æ—¶è¿”å›ç»“æœã€‚  ä¾ç„¶æ˜¯å¥—æ¨¡æ¿ï¼š\nclass Solution: def minNumberInRotateArray(self , rotateArray: List[int]) -\u0026gt; int: if len(rotateArray) == 0: return None left, right = 0, len(rotateArray) - 1 while left \u0026lt; right: mid = left + (right - left) // 2 if rotateArray[mid] \u0026gt; rotateArray[right]: # [mid+1, right] left = mid + 1 elif rotateArray[mid] \u0026lt; rotateArray[right]: # [left, mid] right = mid elif rotateArray[mid] == rotateArray[right]: # [left, right-1] right = right - 1 return rotateArray[left] BM22 æ¯”è¾ƒç‰ˆæœ¬å· æ„Ÿæ© Pythonï¼\nclass Solution: def compare(self , version1: str, version2: str) -\u0026gt; int: version1 = [int(i) for i in version1.split(\u0026#39;.\u0026#39;)] version2 = [int(i) for i in version2.split(\u0026#39;.\u0026#39;)] # å› ä¸º Python ä¸­ [1,0] \u0026lt; [1,0,0] if len(version1) \u0026gt; len(version2): version2 += [0,] * (len(version1) - len(version2)) else: version1 += [0,] * (len(version2) - len(version1)) if version1 \u0026lt; version2: return -1 elif version1 == version2: return 0 else: return 1 ","date":"2022-04-02T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-02/","title":"åšé¢˜ç¬”è®°02ï¼šäºŒåˆ†æŸ¥æ‰¾/æ’åº"},{"content":"BM1 åè½¬é“¾è¡¨  æŠŠé“¾è¡¨ç¬¬ä¸€ä¸ªç»“ç‚¹å˜æˆæœ€åä¸€ä¸ªï¼ˆnode.next=nullï¼‰ï¼Œå‰å¾€ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼› æŠŠè¯¥ç»“ç‚¹çš„ next æ”¹æˆå‰ä¸€ä¸ªç»“ç‚¹ï¼› ç»§ç»­å‰å¾€ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œç›´åˆ°æœ€åä¸€ä¸ªç»“ç‚¹ä¸ºæ­¢ã€‚  class Solution: def ReverseList(self , head: ListNode) -\u0026gt; ListNode: pre_node = None while head: next_node = head.next head.next = pre_node pre_node = head head = next_node return pre_node BM2 é“¾è¡¨å†…æŒ‡å®šåŒºé—´åè½¬ æ²¿ç”¨ä¸Šä¸€é¢˜çš„ä»£ç ï¼Œæ¯ç‡¥è€Œä¸”å®¹æ˜“å‡ºé”™â€¦â€¦\nåšå®Œ BM3 å›å¤´çœ‹å‘ç°å¿˜äº†ç»™è¾“å…¥ m,n åšæ£€æŸ¥ï¼Œwhateverã€‚\nclass Solution: def reverseBetween(self , head: ListNode, m: int, n: int) -\u0026gt; ListNode: # 0. è®¾ç½® 0 ç»“ç‚¹ dummy = ListNode(0) dummy.next = head # 1. æ‰¾åˆ°ä¸¤ç«¯ï¼Œå³ç¬¬ m-1, n+1 ä¸ªç»“ç‚¹ left = dummy for _ in range(m-1): left = left.next right = head for _ in range(n): right = right.next # 2. å¼€å§‹åè½¬ï¼Œhead æŒ‡å‘ç¬¬ m ä¸ªç»“ç‚¹ pre_node, head = right, left.next while head != right: next_node = head.next head.next = pre_node pre_node = head head = next_node # 3. æ¥å¤´ left.next = pre_node return dummy.next BM3 é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ¯kä¸ªä¸€ç»„ç¿»è½¬ æ„Ÿè§‰è¢«é’ˆå¯¹äº†ï¼Œå¤±å»äº†åæ§½çš„åŠ›æ°”ï¼Œæ²¡æœ‰åå¹´è„‘æº¢è¡€æƒ³ä¸å‡ºè¿™æ ·çš„é¢˜ç›®â€¦â€¦\nclass Solution: def reverseKGroup(self , head: ListNode, k: int) -\u0026gt; ListNode: if head == None or head.next == None: return head # 0. åŒæ ·å…ˆå†™ dummy dummy = ListNode(0) dummy.next = head # 1. è®¡ç®—éœ€è¦åè½¬å¤šå°‘æ¬¡ cur = head length = 0 while cur != None: length = length + 1 cur = cur.next count = length // k # 2. åŒæ ·å…ˆæ‰¾ä¸¤ç«¯ left = dummy right = head if count \u0026gt; 0: for _ in range(k): right = right.next # 3. å¼€å§‹å¾ªç¯åè½¬ for i in range(1, count+1): pre_node = right if count \u0026gt; i: for _ in range(k-1): pre_node = pre_node.next head = left.next while head != right: next_node = head.next head.next = pre_node pre_node = head head = next_node left.next = pre_node # å‰å¾€åé¢ k ä¸ªï¼Œæ³¨æ„æ­¤æ—¶æ˜¯æ–­å¼€çŠ¶æ€ï¼ˆç”»å›¾æ›´å®¹æ˜“ç†è§£ï¼‰ï¼Œéœ€è¦ç»™ right å·¦è¾¹è¡¥ dummy ä½œä¸º left if count \u0026gt; i: left = ListNode(0) left.next = right for _ in range(k): right = right.next return dummy.next ä»é¢˜è§£å­¦åˆ°ä¸€ç§åŒæŒ‡é’ˆæŠ€å·§ï¼šhead æŒ‡é’ˆä¸€ç›´æŒ‡åœ¨ç¬¬ä¸€ä¸ªç»“ç‚¹ä¸Šï¼Œleft æŒ‡é’ˆä¸€ç›´æŒ‡å‘ç¬¬ 0 ä¸ªç»“ç‚¹ï¼Œæ¯æ¬¡äº¤æ¢æ—¶ head.next.next = left.next ç„¶å head.next å’Œ left.next åˆ†åˆ«å‰è¿›ä¸€ä½ã€‚\nç»“åˆå›¾å½¢å¯èƒ½æ›´å®¹æ˜“ç†è§£ï¼ˆæ¯”å¦‚æƒ³åƒæˆä¸€ä¸²ç å­ï¼‰ï¼Œæ¯æ¬¡äº¤æ¢æŠŠç¬¬ä¸€ä¸ªç»“ç‚¹çš„å½“å‰ next ç»“ç‚¹ç§»åˆ°æœ€å·¦è¾¹ï¼ˆå³ç¬¬ 0 ä¸ªç»“ç‚¹çš„å³è¾¹ä¸€ä½ï¼‰ï¼Œç„¶åç¬¬ä¸€ä¸ªç»“ç‚¹å‘å³å‰è¿›ä¸€ä½ï¼Œç¬¬ 0 ä¸ªç»“ç‚¹ä¿æŒä¸åŠ¨ï¼Œä¸éš¾çœ‹åˆ°åªéœ€è¦ç§»åŠ¨ k-1 æ¬¡ã€‚\nclass Solution: def reverseKGroup(self , head: ListNode, k: int) -\u0026gt; ListNode: if head == None or head.next == None: return head # 0. åŒæ ·å…ˆå†™ dummy dummy = ListNode(0) dummy.next = head # 1. è®¡ç®—é“¾è¡¨é•¿åº¦ length = 0 while head != None: length = length + 1 head = head.next # 2. åŒæ ·å…ˆæ‰¾å·¦ç«¯ left = dummy head = dummy.next # 3. å¼€å§‹å¾ªç¯åè½¬ while length \u0026gt;= k: for j in range(k-1): next_node = head.next head.next = next_node.next next_node.next = left.next left.next = next_node length = length - k left = head head = left.next return dummy.next BM4 åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨ æ¯”è¾ƒå¤§å°ï¼Œå°çš„è¿›é“¾è¡¨ï¼ŒæŒ‡é’ˆç§»åˆ°ä¸‹ä¸€ä¸ªï¼Œåˆ°ç»“å°¾å°±æ”¶å·¥ã€‚\nclass Solution: def Merge(self , pHead1: ListNode, pHead2: ListNode) -\u0026gt; ListNode: # è€å¥—è·¯ï¼Œå…ˆåˆ›å»º dummy dummy = ListNode(0) head = dummy while pHead1 != None and pHead2 != None: if pHead1.val \u0026gt; pHead2.val: head.next = pHead2 pHead2 = pHead2.next else: head.next = pHead1 pHead1 = pHead1.next head = head.next head.next = (pHead2 if pHead2 else pHead1) return dummy.next BM5 åˆå¹¶ k ä¸ªå·²æ’åºçš„é“¾è¡¨ å­¦ä¹ ä½¿ç”¨ Python çš„ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆäºŒå‰å †ï¼‰ï¼Œä¸è¿‡æ•ˆæœä¸å’‹æ ·ï¼Œå’Œç›´æ¥ sort çš„æ•ˆç‡æ²¡æ˜æ˜¾å·®å¼‚ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒPython çš„äºŒå‰å †åœ¨æ¯”è¾ƒ tuple çš„å¤§å°æ—¶ï¼Œå¦‚æœ tuple ç¬¬ä¸€ä¸ªç»“ç‚¹ç›¸ç­‰ï¼Œå°±æ¥ç€æ¯”è¾ƒç¬¬äºŒä¸ªç»“ç‚¹ï¼Œå¦‚æœ tuple ç¬¬äºŒä¸ªç»“ç‚¹ä¸èƒ½æ¯”è¾ƒå¤§å°ï¼Œå°±ä¼šæŠ¥é”™ TypeError: '\u0026lt;' not supported between instances of xxx and xxxï¼Œæ‰€ä»¥è¿˜æ˜¯ä½¿ç”¨äº† index ä½œä¸ºæ¯”è¾ƒçš„ä¾æ®ã€‚\nclass Solution: def mergeKLists(self , lists: List[ListNode]) -\u0026gt; ListNode: import heapq dummy = ListNode(0) cur = dummy h = [(head.val, idx, head) for idx, head in enumerate(lists) if head] heapq.heapify(h) while h: _, idx, head = heapq.heappop(h) cur.next = head cur, head = cur.next, head.next if head: heapq.heappush(h, (head.val, idx, head)) return dummy.next BM6 åˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ ç†Ÿæ‚‰çš„å¿«æ…¢åŒæŒ‡é’ˆâ€œè¿½åŠé—®é¢˜â€ã€‚\nclass Solution: def hasCycle(self , head: ListNode) -\u0026gt; bool: slow, fast = head, head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: return True return False BM7 é“¾è¡¨ä¸­ç¯çš„å…¥å£ç»“ç‚¹ ä¹Ÿæ˜¯å¿«æ…¢åŒæŒ‡é’ˆâ€œè¿½åŠé—®é¢˜â€ã€‚å‡è®¾ç›¸é‡æ—¶æ…¢æŒ‡é’ˆèµ°äº† a æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°äº† 2a æ­¥ï¼Œåˆ™ 2a-a=a æ˜¯ç¯é•¿ z çš„æ•´æ•°å€ï¼ŒåŒæ—¶ä¹Ÿæ˜¯åˆ°ç¯å…¥å£çš„è·ç¦» x + ç¯å…¥å£åˆ°ç›¸é‡ç‚¹çš„è·ç¦» y + ç¯é•¿ z çš„æ•´æ•°ã€‚æ‰€ä»¥ x + y æ˜¯ç¯é•¿çš„æ•´æ•°å€ï¼Œåªè¦æŠŠå¿«æŒ‡é’ˆæ”¾å›èµ·ç‚¹é€ä¸ªéå†ï¼ˆæ…¢æŒ‡é’ˆåœ¨ y å¤„ï¼‰ï¼Œä¸¤ä¸ªæŒ‡é’ˆå†æ¬¡ç›¸é‡æ—¶å°±æ˜¯åœ¨å…¥å£èµ·ç‚¹ã€‚å¦‚æœå†åŠ ä¸ªè®¡æ•°å™¨ï¼Œå°±å¯ä»¥æ±‚å‡ºåˆ°ç¯å…¥å£çš„é•¿åº¦ã€‚\nclass Solution: def EntryNodeOfLoop(self, head): slow, fast = head, head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: fast = head while slow != fast: slow, fast = slow.next, fast.next return slow return None BM8 é“¾è¡¨ä¸­å€’æ•°æœ€å k ä¸ªç»“ç‚¹ ä¾ç„¶æ˜¯åŒæŒ‡é’ˆé—®é¢˜ã€‚åªè¦è®©ä¸€ä¸ªæŒ‡é’ˆå…ˆèµ° k æ­¥å°±å¥½ã€‚\nclass Solution: def FindKthToTail(self , head: ListNode, k: int) -\u0026gt; ListNode: slow, fast = head, head for _ in range(k): if not fast: return fast fast = fast.next while fast: slow, fast = slow.next, fast.next return slow BM9 åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ å’Œ BM8 çš„å”¯ä¸€åŒºåˆ«æ˜¯æ±‚å€’æ•° k+1 ä¸ªç»“ç‚¹ï¼Œæ‰€ä»¥è¦è®¾ç½® dummyã€‚\nclass Solution: def removeNthFromEnd(self , head: ListNode, n: int) -\u0026gt; ListNode: dummy = ListNode(0) dummy.next = head slow, fast = dummy, head for _ in range(n): if not fast: return fast fast = fast.next while fast: slow, fast = slow.next, fast.next slow.next = slow.next.next return dummy.next BM10 ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹ æ³¨æ„é“¾è¡¨æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ•°æ®ç»“æ„ï¼Œæ¯ä¸ªç»“ç‚¹å¯èƒ½æœ‰å¾ˆå¤šä¸ªå‰é©±ï¼Œä½†åç»§åªèƒ½æœ‰ä¸€ä¸ªã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨æœ‰å…¬å…±ç»“ç‚¹ï¼Œè¯´æ˜ä»æŸä¸ªç»“ç‚¹å¼€å§‹ï¼Œè¿™ä¸¤ä¸ªé“¾è¡¨å®Œå…¨ä¸€è‡´ã€‚å› æ­¤å¯ä»¥å…ˆç®—å‡ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦å·® dï¼Œè®©è¾ƒé•¿çš„é“¾è¡¨å…ˆèµ° d æ­¥ï¼Œä¸¤ä¸ªæŒ‡é’ˆç›¸é‡æ—¶å°±æ˜¯å…¬å…±ç»“ç‚¹ã€‚\né™¤æ­¤ä¹‹å¤–ï¼Œé¢˜è§£è¿˜ç»™å‡ºä¸€ç§æ–¹æ³•ï¼šæŠŠä¸¤ä¸ªé“¾è¡¨æ¥èµ·æ¥éå†ï¼ŒA=A+Bï¼ŒB=B+Aã€‚å› ä¸ºä¼šç»è¿‡ Noneï¼Œæ‰€ä»¥ä¸ä¼šå‡ºç°æ­»å¾ªç¯ã€‚\nclass Solution: def FindFirstCommonNode(self , head_1 , head_2 ): if (not head_1) or (not head_2): return None ptr_1, ptr_2 = head_1, head_2 while ptr_1 != ptr_2: ptr_1 = (ptr_1.next if ptr_1 else head_2) ptr_2 = (ptr_2.next if ptr_2 else head_1) return ptr_1 BM11 é“¾è¡¨ç›¸åŠ (äºŒ) è¿™ç§é¢˜ç›®æœ‰ä»€ä¹ˆå­˜åœ¨çš„å¿…è¦å—ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿæœ€åè¿˜æ˜¯å¿ƒå¹³æ°”å’Œä½¿ç”¨ BM1 çš„ä»£ç ï¼ˆçœç•¥ï¼‰â€¦â€¦\nclass Solution: def addInList(self , head_1: ListNode, head_2: ListNode) -\u0026gt; ListNode: head_1, head_2 = self.ReverseList(head_1), self.ReverseList(head_2) dummy = ListNode(0) head = dummy carrier = 0 while head_1 or head_2: sumup = (head_1.val if head_1 else 0) + (head_2.val if head_2 else 0) + carrier head.next = ListNode(sumup % 10) carrier = sumup // 10 head = head.next head_1 = (head_1.next if head_1 else None) head_2 = (head_2.next if head_2 else None) if carrier: head.next = ListNode(carrier) return self.ReverseList(dummy.next) BM12 å•é“¾è¡¨çš„æ’åº ä¸æƒ³æ‰‹å†™ merge sortâ€¦â€¦ä½¿ç”¨ BM5 çš„äºŒå‰å †å§ï¼š\nclass Solution: def sortInList(self , head: ListNode) -\u0026gt; ListNode: import heapq idx, h, dummy = 0, [], ListNode(0) cur = head while cur: heapq.heappush(h, (cur.val, idx, cur)) cur = cur.next idx = idx + 1 cur = dummy while h: cur.next = heapq.heappop(h)[2] cur = cur.next cur.next = None return dummy.next BM13 åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡ç»“æ„ å›æ–‡ç»“æ„å³æ­£å‘å’Œåå‘éå†ç»“æœå®Œå…¨ç›¸åŒçš„ç»“æ„ã€‚ç”±äºé“¾è¡¨åªèƒ½æ­£ç€èµ°ï¼Œå¯ä»¥è€ƒè™‘å…ˆæ‰¾åˆ°ä¸­ç‚¹ï¼ŒæŠŠååŠæˆªé“¾è¡¨ä½¿ç”¨ BM1 åè¿‡æ¥ï¼Œå†é€ä¸ªè¿›è¡Œæ¯”è¾ƒã€‚æ‰¾ä¸­ç‚¹ä¹Ÿå¯ä»¥ä½¿ç”¨å¿«æ…¢åŒæŒ‡é’ˆã€‚\nè™½ç„¶ä¸éš¾ï¼Œä½†æ˜¯ debug äº†å¥½ä¹…ï¼Œå¥½ä¸¢äººâ€¦â€¦\nclass Solution: def isPail(self , head: ListNode) -\u0026gt; bool: if (not head) or (not head.next): # é•¿åº¦ä¸º 0 æˆ– 1 return True dummy = ListNode(0) dummy.next = head slow, fast = dummy, dummy while fast and fast.next: slow, fast = slow.next, fast.next.next if not fast: # é“¾è¡¨é•¿åº¦ä¸ºå¥‡æ•°ï¼Œæ­¤æ—¶ slow åœ¨ä¸­ç‚¹ fast = self.ReverseList(slow) else: # é“¾è¡¨é•¿åº¦ä¸ºå¶æ•°ï¼Œæ­¤æ—¶ slow åœ¨å‰åŠæ®µæœ« fast = self.ReverseList(slow.next) slow = head while slow and fast and slow.val == fast.val: # ä¸è¦å¿˜è®°æ¯”è¾ƒçš„æ˜¯ .valï¼ï¼ï¼ slow, fast = slow.next, fast.next return ((not slow) or (not fast)) BM14 é“¾è¡¨çš„å¥‡å¶é‡æ’ æ€ä¹ˆåˆæ˜¯åŒæŒ‡é’ˆâ€¦â€¦JOJO æˆ‘ä¸åšäººå•¦ï¼\nå¤šæŒ‡é’ˆçš„é¢˜ç›®å¾€å¾€å¾ˆéš¾è¿›è¡Œè°ƒè¯•ï¼ˆæ‰€ä»¥æŒ‡é’ˆè¶Šå°‘è¶Šå¥½ï¼ï¼‰ï¼Œéœ€è¦å¯¹çŠ¶æ€è¿›è¡Œä»”ç»†åˆ†æã€‚ä¾‹å¦‚ï¼Œå½“ while å¾ªç¯ç»“æŸåï¼Œå¦‚æœé“¾è¡¨ç»“ç‚¹æ˜¯å¥‡æ•°ä¸ªï¼ˆodd æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œodd.next == even == Noneï¼‰ï¼Œåªéœ€è¦æŠŠ even_head æ¥å¥½ï¼›å¦‚æœé“¾è¡¨ç»“ç‚¹æ˜¯å¶æ•°ä¸ªï¼ˆodd.next == even != None æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹, even.next == Noneï¼‰ï¼ŒåŒæ ·åªéœ€è¦æ¥ä¸Š even_headï¼Œæ‰€ä»¥æœ€åçš„å¤„ç†æ²¡æœ‰ä»»ä½•é—®é¢˜ã€‚\nclass Solution: def oddEvenList(self , head: ListNode) -\u0026gt; ListNode: if (not head) or (not head.next) or (not head.next.next): # é•¿åº¦ä¸º 0,1,2 ä¸éœ€è¦å¤„ç† return head odd = head even, even_head = head.next, head.next while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head BM15 åˆ é™¤æœ‰åºé“¾è¡¨ä¸­é‡å¤çš„å…ƒç´ -I å†™äº†å¤ªå¤šåŒæŒ‡é’ˆï¼Œå·²ç»æˆä¸ºå·´ç”«æ´›å¤«çš„ç‹—äº†ï¼š\nclass Solution: def deleteDuplicates(self , head: ListNode) -\u0026gt; ListNode: slow, fast = head, head while fast: fast = fast.next while fast and fast.val == slow.val: fast = fast.next slow.next = fast slow = slow.next return head çœ‹é¢˜è§£æ‰å‘ç°ä¸€ä¸ªæŒ‡é’ˆå°±è¶³å¤Ÿäº†ï¼š\nclass Solution: def deleteDuplicates(self , head: ListNode) -\u0026gt; ListNode: if not head: return head cur = head while cur.next: if cur.next.val == cur.val: cur.next = cur.next.next else: cur = cur.next return head BM16 åˆ é™¤æœ‰åºé“¾è¡¨ä¸­é‡å¤çš„å…ƒç´ -II çœ‹ä¸Šå»å¾ˆç®€å•ï¼Œåšèµ·æ¥æ— ä»ä¸‹æ‰‹ã€‚ä»”ç»†æƒ³æƒ³ï¼Œè¿™é“é¢˜å…¶å®è¦ä¸‰ä¸ªç›¸é‚»çš„æŒ‡é’ˆï¼šå¦‚æœåé¢ä¸¤ä¸ªæŒ‡é’ˆçš„å€¼ç›¸åŒï¼Œåˆ™ä¸€ç›´å‰è¿›åˆ°ä¸åŒä¸ºæ­¢ï¼Œç„¶åæœ€å‰é¢çš„æŒ‡é’ˆçš„ next æŒ‡å‘æœ€åçš„æŒ‡é’ˆï¼ˆä¸åŒçš„å€¼ï¼‰ï¼Œç›´åˆ°ä¸­é—´çš„æŒ‡é’ˆæŒ‡åˆ° None ä¸ºæ­¢ï¼Œè¿™åˆä¼šäº§ç”Ÿè¶Šç•Œé—®é¢˜â€¦â€¦è¦ä»”ç»†åŒºåˆ†æ‰€æœ‰çŠ¶æ€ï¼Œå°å¿ƒå°å¿ƒå†å°å¿ƒï¼\nclass Solution: def deleteDuplicates(self , head: ListNode) -\u0026gt; ListNode: if head == None or head.next == None: return head dummy = ListNode(0) dummy.next = head slow, middle = dummy, head while middle: if middle.next: # middle ä¸æ˜¯æœ€åä¸€ä¸ªå…ƒç´  if middle.val == middle.next.val: # å‡ºç°é‡å¤ while middle.next and middle.val == middle.next.val: middle = middle.next # åœæ­¢æœ‰ä¸¤ç§å¯èƒ½ï¼šmiddle æ˜¯æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæˆ–è€…å‡ºç°ç¬¬ä¸€ä¸ªä¸ç­‰ if middle.next: # å‡ºç°ä¸ç­‰ slow.next = middle.next middle = middle.next else: # middle æ˜¯æœ€åä¸€ä¸ªå…ƒç´ ï¼Œmiddle.next = None slow.next = None return dummy.next else: # æ²¡æœ‰é‡å¤ï¼Œslow å’Œ middle åˆ†åˆ«å‰è¿›ä¸€æ ¼ slow = slow.next middle = middle.next else: # middle æ˜¯æœ€åä¸€ä¸ªå…ƒç´ ï¼Œä¸”å’Œå‰ä¸€ä¸ªå…ƒç´ æ²¡æœ‰é‡å¤ slow.next = middle return dummy.next å¯ä»¥å†ç²¾ç®€ä¸€ä¸‹åˆ¤æ–­é€»è¾‘ï¼Œä¸è¿‡å¯è¯»æ€§ä¼¼ä¹å˜å·®äº†ï¼š\nclass Solution: def deleteDuplicates(self , head: ListNode) -\u0026gt; ListNode: if head == None or head.next == None: return head dummy = ListNode(0) dummy.next = head slow, middle = dummy, head while middle and middle.next: # middle ä¸æ˜¯æœ€åä¸€ä¸ªå…ƒç´ ï¼Œä¹Ÿä¸ä¸ºç©º if middle.val == middle.next.val: # å‡ºç°é‡å¤ while middle.next and middle.val == middle.next.val: middle = middle.next # åœæ­¢æœ‰ä¸¤ç§å¯èƒ½ï¼šmiddle æ˜¯æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæˆ–è€…å‡ºç°ç¬¬ä¸€ä¸ªä¸ç­‰ # æ— è®ºæ˜¯å“ªä¸€ç§å¯èƒ½ï¼Œéƒ½æ˜¯ç›¸åŒçš„ä»£ç  slow.next = middle.next middle = middle.next else: # æ²¡æœ‰é‡å¤ï¼Œslow å’Œ middle åˆ†åˆ«å‰è¿›ä¸€æ ¼ slow = slow.next middle = middle.next if middle: # middle æ˜¯æœ€åä¸€ä¸ªå…ƒç´ ï¼Œä¸”å’Œå‰ä¸€ä¸ªå…ƒç´ æ²¡æœ‰é‡å¤ slow.next = middle return dummy.next å…¶å®æ›´å®¹æ˜“ç†è§£çš„æ–¹æ³•æ˜¯ä½¿ç”¨ hash æˆ–è€…å¸¸æ•°æ’åºï¼Œä¸è¿‡ç©ºé—´å¤æ‚åº¦å°±åšä¸åˆ° O(1) äº†ã€‚æ”¶å·¥ï½\n","date":"2022-04-01T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-01/","title":"åšé¢˜ç¬”è®°01ï¼šé“¾è¡¨"},{"content":"è¦å¥½å¥½å‡†å¤‡æ‰¾å·¥ä½œï¼\nLinux ç®€ä»‹ å†å² åœ¨è®¡ç®—æœºåˆšå‘æ˜çš„å¹´ä»£ï¼Œç”±äºè®¡ç®—æœºé€ ä»·æ˜‚è´µï¼Œäººä»¬å¸Œæœ›èƒ½é«˜æ•ˆåˆ©ç”¨å®è´µçš„ä¸Šæœºæ—¶é—´ï¼Œäºæ˜¯åˆ†æ—¶æ“ä½œç³»ç»Ÿè¯ç”Ÿäº†ã€‚å½“æ—¶çš„è®¡ç®—æœºèƒ½æä¾›å¤§çº¦ 16 ä¸ªæ–‡å­—ç»ˆç«¯ä½¿ç”¨ï¼Œç„¶è€Œè¿™è¿˜è¿œè¿œä¸èƒ½æ»¡è¶³éœ€æ±‚ã€‚\n1963 å¹´ï¼ŒMITã€è´å°”å®éªŒå®¤å’Œé€šç”¨ç”µæ°”å…¬å¸å¯åŠ¨äº†ä¸€é¡¹é›„å¿ƒå‹ƒå‹ƒçš„è®¡åˆ’ï¼šæ‰“é€ ä¸€ä¸ªèƒ½æä¾› 300 ä¸ªä»¥ä¸Šæ–‡å­—ç»ˆç«¯ä½¿ç”¨çš„è®¡ç®—æœºç³»ç»Ÿï¼ˆç§°ä¸ºâ€œMulticsâ€ï¼‰ã€‚è®¡åˆ’çš„å‚ä¸è€…ä¹‹ä¸€ã€è´å°”å®éªŒå®¤çš„ Ken Thompson å—åˆ°å¯å‘ï¼Œåœ¨ 1969 å¹´ä¸€ä¸ªå¶ç„¶çš„å‡æœŸé‡Œ1ï¼Œä¸º PDP-7 ç”µè„‘ç¼–å†™äº†ä¸€ä¸ªç®€å•çš„æ“ä½œç³»ç»Ÿï¼ˆæˆç§°ä¸ºâ€œUnicsâ€ï¼‰ï¼Œåæ¥è¿™ä¸ªç³»ç»Ÿé€æ¸æ¼”å˜æˆå¤§åé¼é¼çš„ Unixã€‚\nUnix é€æ¸å±•ç¤ºå‡ºäº†è¶³å¤Ÿçš„å•†ä¸šä»·å€¼ï¼Œå¼•å‘äº†ä¸€ç³»åˆ—è‘—ä½œæƒå®˜å¸ï¼Œäºæ˜¯è´å°”å®éªŒå®¤æ¯å…¬å¸ AT\u0026amp;T åœ¨ 1979 å¹´å†³å®šç¦æ­¢å‘å­¦ç”Ÿå¼€æ”¾æºç ã€‚1984 å¹´ï¼Œä¸ºäº†æ–¹ä¾¿æ•™å­¦ï¼ŒAndrew Tanenbaum2 å†³å®šè‡ªå·±åŠ¨æ‰‹ç¼–å†™ä¸€å¥—ç²¾ç®€ç‰ˆçš„ Unixï¼Œç§°ä¸º Minixã€‚åŒå¹´ï¼ŒRichard Mathew Stallman å‘èµ·äº† GNU è®¡åˆ’ï¼Œç„¶åæˆç«‹äº†è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šã€‚\nè‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒäº†ä¸€ç³»åˆ—æ–¹ä¾¿çš„è½¯ä»¶ï¼ˆGCC, Emacs, BASH, ...ï¼‰ï¼Œä½†å´è¿Ÿè¿Ÿæœªå‡ºæ“ä½œç³»ç»Ÿã€‚1991 å¹´ï¼ŒèŠ¬å…°å¤§å­¦ç”Ÿ Linus Torvalds å—åˆ° Minix å¯å‘ï¼Œåœ¨è´·æ¬¾ä¹°æ¥çš„ 386 ç”µè„‘ä¸Šä½¿ç”¨ GNU çš„ BASH, GCC ç­‰å·¥å…·ï¼ŒæˆåŠŸå®ç°äº†ä¸€ä¸ªç±»ä¼¼ Unix çš„å°å‹æ“ä½œç³»ç»Ÿï¼Œäºæ˜¯å‘å¸ƒåˆ° BBS ä¸Šå¼€æ”¾ä¸‹è½½å¹¶å¾æ±‚æ„è§ã€‚FTP æœåŠ¡å™¨ç®¡ç†å‘˜æŠŠä¸‹è½½ç›®å½•å‘½åä¸º Linuxï¼Œä»æ­¤è¿™ä¸ªç³»ç»Ÿå°±è¢«ç§°ä¸º Linux äº†ã€‚\nè™½ç„¶ Linux çš„æ¡Œé¢æ“ä½œç³»ç»Ÿåœ¨å¹³æ—¶éå¸¸ç½•è§ï¼Œä½† 95% ä»¥ä¸Šçš„ç½‘ç«™æœåŠ¡å™¨éƒ½åœ¨ä½¿ç”¨ Linux3ã€‚è¿™ä¸€ç³»åˆ—çš„ç¬”è®°å°±ä» Linux å¼€å§‹å§ï½\nåˆä½“éªŒ ä¼ ç»Ÿæ„ä¹‰ä¸Šçš„ Linux æŒ‡çš„æ˜¯ Linux Kernelï¼Œä½¿ç”¨èµ·æ¥å¹¶ä¸æ–¹ä¾¿ã€‚æ‰€å¹¸ç›®å‰å·²ç»æœ‰å„ç§æ‰“åŒ…å¥½çš„å‘è¡Œç‰ˆï¼ˆå¦‚ Ubuntuã€Arch Linux ç­‰ï¼‰ï¼Œä½ å¯ä»¥é€šè¿‡è™šæ‹Ÿæœºè¿è¡Œï¼Œä¹Ÿå¯ä»¥åˆ»å½•åˆ° U ç›˜ç›´æ¥å¯åŠ¨ï¼Œä¸æƒ³åŠ¨æ‰‹ä¹Ÿå¯ä»¥ä½¿ç”¨äº‘æœåŠ¡å™¨ã€‚è¿™é‡Œä½¿ç”¨çš„æ˜¯å…è´¹çš„ Google Colaboratoryï¼Œç™»å½•åå¯ä»¥çœ‹è§ï¼š\nWelcome to Ubuntu 18.04.5 LTS (GNU/Linux 5.4.144+ x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage ... ~# å’Œå¹³æ—¶ä½¿ç”¨çš„å›¾å½¢ç•Œé¢å®Œå…¨ä¸ä¸€æ ·ï¼Œæ¥ä¸‹æ¥å¯ä»¥è¯•è¯•æ‰§è¡Œç®€å•çš„å‘½ä»¤ï¼š\n~# w 13:55:23 up 1:13, 1 user, load average: 0.00, 0.00, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 127.0.0.1 12:45 1.00s 0.00s 0.00s w ~# date Sun Mar 27 13:55:30 UTC 2022 ~# cal March 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ~# pwd /root ~# id uid=0(root) gid=0(root) groups=0(root) ~# ls å‚æ•°ä¸å¸®åŠ© åœ¨æ‰§è¡Œä¸€ç³»åˆ—å‘½ä»¤åï¼Œä½ æœªå…ä¼šæ„Ÿè§‰æœ‰ç‚¹å¤±æœ›ï¼šè™½ç„¶è¿™ä¸ªæ“ä½œç³»ç»Ÿå‹‰å¼ºèƒ½ç”¨ï¼Œä½†ç”¨èµ·æ¥å¾ˆä¸é¡ºæ‰‹ã€‚ä¸ºäº†è®©è¿™äº›å·¥å…·æ›´é¡ºæ‰‹ï¼Œå¾€å¾€éœ€è¦ä¼ å…¥é¢å¤–çš„å‚æ•°ï¼Œæ¯”å¦‚ï¼š\n~# date -u +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34; 2022-03-27 14:16:52 ~# cal 01 2077 January 2077 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ~# ls -alh total 68K drwx------ 1 root root 4.0K Mar 27 14:08 . drwxr-xr-x 1 root root 4.0K Mar 27 12:42 .. -r-xr-xr-x 1 root root 1.2K Jan 1 2000 .bashrc drwxr-xr-x 3 root root 4.0K Mar 23 14:22 .gsutil drwxr-xr-x 5 root root 4.0K Mar 23 20:22 .ipython drwx------ 2 root root 4.0K Mar 23 20:22 .jupyter drwxr-xr-x 2 root root 4.0K Mar 27 12:42 .keras drwxr-xr-x 1 root root 4.0K Mar 23 20:22 .local drwxr-xr-x 4 root root 4.0K Mar 23 20:22 .npm -rw-r--r-- 1 root root 148 Aug 17 2015 .profile -r-xr-xr-x 1 root root 254 Jan 1 2000 .tmux.conf ä¸€èˆ¬çš„ Linux å‘½ä»¤å½¢å¼ä¸º command [-options] [parameter1...]ï¼Œè¦çŸ¥é“å‘½ä»¤æ¥å—ä»€ä¹ˆå‚æ•°ï¼Œåªèƒ½æŸ¥é˜…å‘½ä»¤å¯¹åº”çš„å¸®åŠ©æ–‡æ¡£ï¼Œå¦‚æ‰§è¡Œ command --help æˆ–è€… man commandï¼š\n~# cal --help cal: invalid option -- \u0026#39;-\u0026#39; Usage: cal [general options] [-jy] [[month] year] cal [general options] [-j] [-m month] [year] ncal -C [general options] [-jy] [[month] year] ncal -C [general options] [-j] [-m month] [year] ncal [general options] [-bhJjpwySM] [-H yyyy-mm-dd] [-s country_code] [[month] year] ncal [general options] [-bhJeoSM] [year] General options: [-31] [-A months] [-B months] [-d yyyy-mm] ç„¶è€ŒæŸ¥é˜…å¸®åŠ©æ–‡æ¡£å¾ˆè€—æ—¶ï¼Œä¹Ÿéš¾ä»¥è®°å¿†ï¼Œæ•…åœ¨å¼€å§‹ä¹‹å‰ï¼Œå»ºè®®å®‰è£… tldrã€‚\nå®‰è£…æ–°è½¯ä»¶ åœ¨ Ubuntuï¼Œå®‰è£…è½¯ä»¶åªéœ€è¦ä¸€è¡Œå‘½ä»¤ï¼š\n~# sudo apt install tldr Reading package lists... Done ... The following NEW packages will be installed: tldr 0 upgraded, 1 newly installed, 0 to remove and 41 not upgraded. Need to get 860 kB of archives. ... Processing triggers for man-db (2.8.3-2ubuntu0.1) ... é‚£ä¹ˆæ€ä¹ˆå¸è½½å‘¢ï¼Ÿæ²¡å…³ç³»ï¼Œæœ‰ tldrï¼\n~# tldr apt ... - Update the list of available packages and versions (it\u0026#39;s recommended to run this before other apt commands): sudo apt update - Search for a given package: apt search {{package}} - Show information for a package: apt show {{package}} - Install a package, or update it to the latest available version: sudo apt install {{package}} - Remove a package (using purge instead also removes its configuration files): sudo apt remove {{package}} ... å¯ä»¥çœ‹åˆ°å¸è½½å·²å®‰è£…ç¨‹åºçš„å‘½ä»¤æ˜¯ sudo apt remove commandï¼ˆå¦‚æœéœ€è¦åŒæ—¶ç§»é™¤ç¨‹åºçš„é…ç½®æ–‡ä»¶ï¼ŒæŠŠ remove æ”¹æˆ purgeï¼‰ã€‚é‡åˆ°ä¸æ‡‚çš„å‘½ä»¤ï¼Œåªè¦ tldr ä¸€ä¸‹å°±å¥½ï¼\næ–‡ä»¶ä¸ç›®å½•ç®¡ç† æ¦‚è¿° å’Œ Windows çš„æ–‡ä»¶ç›®å½•ä¸å¤ªä¸€æ ·ï¼ŒLinux çš„æ‰€æœ‰æ–‡ä»¶å’Œç›®å½•éƒ½æ˜¯ä»æ ¹ç›®å½•å¼€å§‹çš„ï¼Œè¢«ç§°ä¸ºç›®å½•æ ‘ã€‚æ¯ä¸€ä¸ªç›®å½•éƒ½å¯ä»¥æŒ‚è½½å„ç§æ–‡ä»¶ç³»ç»Ÿï¼Œå¦‚ç¡¬ç›˜çš„åˆ†åŒºã€å…‰ç›˜ã€ISO æ–‡ä»¶ã€ç½‘ç»œæ–‡ä»¶ç³»ç»Ÿç­‰ç­‰ã€‚\nä»æ ¹ç›®å½•å¼€å§‹ï¼Œæ¯ä¸ªç›®å½•æˆ–æ–‡ä»¶éƒ½æœ‰å”¯ä¸€çš„è·¯å¾„ï¼Œç§°ä¸ºç»å¯¹è·¯å¾„ã€‚ä¸ç»å¯¹è·¯å¾„ç›¸å¯¹åº”çš„ï¼Œè‡ªç„¶æ˜¯ç›¸å¯¹è·¯å¾„äº†ï¼Œå³ä½¿ç”¨ . è¡¨ç¤ºå½“å‰æ–‡ä»¶å¤¹ï¼Œä½¿ç”¨ .. è¡¨ç¤ºçˆ¶æ–‡ä»¶å¤¹ï¼Œä¾‹å¦‚ /var/log ç›®å½•åœ¨ /root ä¸‹çš„ç›¸å¯¹è·¯å¾„ä¸º ../var/logã€‚å¯¹äº Linux è¿ç»´è€Œè¨€ï¼Œä»¥ä¸‹æ˜¯éœ€è¦å®šæœŸå¤‡ä»½çš„ç›®å½•ï¼š\n /etc å­˜å‚¨äº†ç³»ç»Ÿçš„é‡è¦é…ç½®æ–‡ä»¶ï¼› /home æˆ–è€… /root æ˜¯é»˜è®¤çš„ç”¨æˆ·ç›®å½•ï¼› /srv å¯èƒ½æ˜¯æœåŠ¡å™¨ç¨‹åºæ•°æ®å­˜æ”¾ç›®å½•ï¼› /var/log å­˜æ”¾äº†å¤§é‡çš„æ—¥å¿—ï¼› /var/spool å­˜æ”¾é˜Ÿåˆ—æ–‡ä»¶ï¼Œå¦‚ /var/spool/mail å­˜æ”¾æ”¶åˆ°çš„æ–°é‚®ä»¶ï¼Œ/var/spool/cron å’Œ /var/spool/at å­˜æ”¾ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡ç­‰ï¼› /var/www/html æ˜¯å¸¸è§çš„ Web æœåŠ¡å™¨é¡µé¢é»˜è®¤ç›®å½•ï¼› â€¦â€¦  åŸºæœ¬æ“ä½œ å…ˆæ¥å°è¯•æœ€åŸºæœ¬çš„ç›®å½•å’Œæ–‡ä»¶æ“ä½œï¼š\n pwd æ‰“å°å½“å‰å·¥ä½œç›®å½•ï¼› cd path åˆ‡æ¢å·¥ä½œç›®å½•åˆ°æŒ‡å®šè·¯å¾„ï¼› ls path åˆ—å‡ºè·¯å¾„ä¸‹çš„æ‰€æœ‰ééšè—æ–‡ä»¶ï¼ˆå¸¸å¸¸ä½¿ç”¨ ls -alh pathï¼‰ï¼› file filename ç¡®å®šæ–‡ä»¶ç±»å‹ï¼›  ç°åœ¨å¯ä»¥åƒ Windows æ–‡ä»¶ç®¡ç†å™¨ä¸€æ ·ç®¡ç†æ–‡ä»¶äº†ï¼ä¸æ‡‚å¯ä»¥ä½¿ç”¨ tldrï¼š\n mkdir dirname åˆ›å»ºæ–°æ–‡ä»¶å¤¹ï¼› touch filename åˆ›å»ºæ–°æ–‡ä»¶ï¼› cp source destination å¤åˆ¶æ–‡ä»¶ï¼› mv source destination ç§»åŠ¨/é‡å‘½åæ–‡ä»¶ï¼› rm filename åˆ é™¤æ–‡ä»¶ï¼ˆç›´æ¥åˆ é™¤ï¼Œæ²¡æœ‰å›æ”¶ç«™å’Œç¡®è®¤é€‰é¡¹ï¼ï¼‰ï¼› ln -s source destination åˆ›å»ºæ–‡ä»¶çš„ç¬¦å·é“¾æ¥ï¼ˆå¿«æ·æ–¹å¼ï¼‰ï¼› ln source destination åˆ›å»ºæ–‡ä»¶çš„ç¡¬é“¾æ¥ï¼ˆæ›¿èº«ï¼‰ï¼›  æŸ¥çœ‹æ–‡ä»¶å†…å®¹ å› ä¸º Linux å‘½ä»¤è¡Œå¹¶ä¸æ˜¯å›¾å½¢ç•Œé¢ï¼Œèƒ½æ‰“å¼€æŸ¥çœ‹æˆ–ç¼–è¾‘çš„å¾€å¾€åªæœ‰æ–‡æœ¬æ–‡ä»¶ã€‚å¸¸ç”¨çš„æ–‡ä»¶æŸ¥çœ‹å‘½ä»¤æœ‰ï¼š\n cat filename æ‰“å°æ–‡ä»¶æ‰€æœ‰å†…å®¹ï¼ŒåŠ ä¸Šå‚æ•° -n å¯æ˜¾ç¤ºè¡Œå·ï¼Œè¿˜å¯ä»¥è¿æ¥æ–‡ä»¶ï¼› head filename æ‰“å°æ–‡ä»¶å¤´åè¡Œå†…å®¹ï¼ŒåŠ ä¸Šå‚æ•° -n 20 æ‰“å°å‰ 20 è¡Œï¼› tail filename æ‰“å°æ–‡ä»¶æœ€ååè¡Œå†…å®¹ï¼ŒåŠ ä¸Šå‚æ•° -n 20 æ‰“å°æœ€å 20 è¡Œï¼› less filename æ‰“å¼€æ–‡ä»¶é˜…è¯»å™¨ï¼Œå¯ä»¥ä¸Šä¸‹ç¿»é¡µï¼ŒæŒ‰ q é€€å‡ºï¼› diff file1 file2 æ¯”è¾ƒä¸¤ä¸ªæ–‡ä»¶çš„ä¸åŒä¹‹å¤„ï¼› od filename æ‰“å°äºŒè¿›åˆ¶æ–‡ä»¶ã€‚  å…¶ä¸­ less æœ‰è®¸å¤šæ–¹ä¾¿çš„å¿«æ·é”®ï¼Œå¦‚ G è·³è½¬åˆ°æ–‡ä»¶æœ«å°¾ï¼ŒF å®æ—¶åˆ·æ–°ï¼Œ/ æœç´¢å…³é”®è¯ï¼Œæ˜¯æŸ¥çœ‹æ—¥å¿—æ–‡ä»¶çš„å¥½å¸®æ‰‹ã€‚\nç®¡é“ä¸é‡å®šå‘ï¼ˆé‡ç‚¹ï¼‰ ç›´æ¥æ‰“å°æ–‡æœ¬æ–‡ä»¶å†…å®¹ä¸å¤ªç¾è§‚ï¼Œæˆ‘ä»¬å¾€å¾€éœ€è¦å¯¹æ–‡æœ¬è¿›è¡Œç®€å•çš„å¤„ç†ã€æ ¼å¼åŒ–å†è¾“å‡ºï¼Œæœ‰æ—¶è¿˜å¸Œæœ›æŠŠç»“æœä¿å­˜åˆ°æŒ‡å®šæ–‡ä»¶ã€‚\nLinux è¿˜æœ‰è®¸å¤šå¯ä»¥é…åˆç®¡é“å¤„ç†çš„æ–‡æœ¬å°å·¥å…·ï¼š\n echo sort uniq cut tr grep  ç°åœ¨ä½ å·²ç»å¯ä»¥å®Œæˆä¸€äº›ç®€å•çš„ä»»åŠ¡äº†ï¼Œæ¯”å¦‚\nä¸è¿‡ï¼Œæœ€è‘—åçš„ Unix æ–‡æœ¬å¤„ç†å·¥å…·é AWK å’Œ SED è«å±ã€‚\næŸ¥æ‰¾æ–‡ä»¶ which whereis locate find\næ–‡ä»¶ç³»ç»Ÿä¸å­˜å‚¨ç®¡ç† Raid LVM ç”¨æˆ·ä¸æƒé™ç®¡ç† ç”¨æˆ·ã€ç¾¤ç»„å’Œå…¶ä»– suä¸sudo visudo passwd adduser/useradd groupadd/addgroup usermod getfacl/setfacl\nchown chgrp chmod umask\nUID GID effective SUID SGID Sticky Bit sudo çš„å‘ æ–‡ä»¶ç³»ç»Ÿ ACL æœ€å°æƒé™åŸåˆ™ Vim ç®€ä»‹ æ´»ä¸‹æ¥ å¸¸ç”¨æ¨¡å¼ è¡Œé—´ä¸è¡Œå†…è·³è½¬ æ–‡æœ¬ç¼–è¾‘ å¤šè¡Œæ¨¡å¼ å¤šæ–‡ä»¶åˆ‡æ¢ Bash åŸºç¡€ å¸¸ç”¨å¿«æ·é”®  TAB å¯ä»¥è¿›è¡Œè‡ªåŠ¨è¡¥å…¨ï¼› ä¸Šä¸‹é”®å¯ä»¥æŒ‰é¡ºåºç¿»æŸ¥ä»¥å‰è¾“å…¥çš„å‘½ä»¤ï¼› Ctrl+R å¯ä»¥æŸ¥æ‰¾å†å²å‘½ä»¤ï¼›  å˜é‡å®šä¹‰ä¸ç¯å¢ƒå˜é‡ æ¡ä»¶åˆ¤æ–­ å¾ªç¯ Bash ç¼–ç¨‹åŸºç¡€ å…¶ä»–è¯é¢˜ å¼€æœºæµç¨‹ä¸è‡ªå¯åŠ¨é¡¹ç®¡ç† è¿›ç¨‹ç®¡ç†ä¸ä»»åŠ¡æ§åˆ¶ ps top htop\nfg bg jobs\nkill killall\nç³»ç»ŸæœåŠ¡ï¼ˆSystemdï¼‰ ä½œç”¨ï¼šå¼€æœºè‡ªåŠ¨å¯åŠ¨æœåŠ¡å™¨è½¯ä»¶ã€‚\nå®šæ—¶æœåŠ¡ï¼ˆCrontabï¼‰ ä½œç”¨ï¼šå®šæœŸè‡ªåŠ¨å¤‡ä»½ï¼Œæ¯å¤©è‡ªåŠ¨å®‰è£…å®‰å…¨æ›´æ–°ç­‰ã€‚\nä¿æŒæ‰§è¡Œï¼ˆnohup, screen/tmuxï¼‰ ä½œç”¨ï¼šæ‰§è¡Œè€—æ—¶é•¿çš„ä»»åŠ¡ï¼Œå¦‚æ–‡ä»¶åŒæ­¥ã€‚\né‡åˆ°éº»çƒ¦ï¼Ÿ æ‰©å±•é˜…è¯» [1] é»„ç®çš„ è¯¾ä»¶ ä¸ è¯¾ç¨‹å½•åƒï¼›\n[2] é¸Ÿå“¥çš„ Linux ç§æˆ¿èœï¼šåŸºç¡€å­¦ä¹ è®­ç»ƒç¯‡ï¼›\n[3] å¿«ä¹çš„ Linux å‘½ä»¤è¡Œã€‚\n  å…¶å®åªæ˜¯ä¸ºäº†æ‰“æ¸¸æˆâ€¦â€¦\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n ã€Šè®¡ç®—æœºç½‘ç»œã€‹ã€ã€Šæ“ä½œç³»ç»Ÿï¼šè®¾è®¡ä¸å®ç°ã€‹å’Œã€Šç°ä»£æ“ä½œç³»ç»Ÿã€‹çš„ä½œè€…ã€‚Andrew Tanenbaum ä¿ç•™äº† Minix çš„ç›¸å…³æƒåˆ©ï¼Œä½†è´­ä¹°æ•™æçš„äººå¯ä»¥å…è´¹å¾—åˆ°ä¸€ä»½ Minix æºä»£ç æ‹·è´ã€‚\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/Linux\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-03-27T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/devops-01/","title":"è¿ç»´ç¬”è®°01ï¼šLinux åŸºç¡€"}]