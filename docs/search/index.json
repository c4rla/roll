[{"content":"咕咕咕\n","date":"2022-04-16T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-08/","title":"做题笔记08：剑指Offer"},{"content":"BM83 字符串变形 感恩 Python！\nclass Solution: def trans(self , s: str, n: int) -\u0026gt; str: return \u0026#39; \u0026#39;.join(s.swapcase().split(\u0026#39; \u0026#39;)[::-1]) BM84 最长公共前缀 class Solution: def longestCommonPrefix(self , strs: List[str]) -\u0026gt; str: res = \u0026#34;\u0026#34; for e in zip(*strs): if len(set(e)) == 1: res += e[0] else: break return res BM85 验证IP地址 好无聊的题目，明明有内置函数不给用……直接抄题解了：\nclass Solution: def validate_IPv4(self, IP: str) -\u0026gt; str: nums = IP.split(\u0026#39;.\u0026#39;) for x in nums: # Validate integer in range (0, 255): # 1. length of chunk is between 1 and 3 if len(x) == 0 or len(x) \u0026gt; 3: return \u0026#34;Neither\u0026#34; # 2. no extra leading zeros # 3. only digits are allowed # 4. less than 255 if x[0] == \u0026#39;0\u0026#39; and len(x) != 1 or not x.isdigit() or int(x) \u0026gt; 255: return \u0026#34;Neither\u0026#34; return \u0026#34;IPv4\u0026#34; def validate_IPv6(self, IP: str) -\u0026gt; str: nums = IP.split(\u0026#39;:\u0026#39;) hexdigits = \u0026#39;0123456789abcdefABCDEF\u0026#39; for x in nums: # Validate hexadecimal in range (0, 2**16): # 1. at least one and not more than 4 hexdigits in one chunk # 2. only hexdigits are allowed: 0-9, a-f, A-F if len(x) == 0 or len(x) \u0026gt; 4 or not all(c in hexdigits for c in x): return \u0026#34;Neither\u0026#34; return \u0026#34;IPv6\u0026#34; def solve(self , IP: str) -\u0026gt; str: if IP.count(\u0026#39;.\u0026#39;) == 3: return self.validate_IPv4(IP) elif IP.count(\u0026#39;:\u0026#39;) == 7: return self.validate_IPv6(IP) else: return \u0026#34;Neither\u0026#34; BM86 大数加法 真的好无聊，明明之前在链表做过了……\nclass Solution: def solve(self , s: str, t: str) -\u0026gt; str: return str(int(s)+int(t)) BM87 合并两个有序的数组 合并排序，熟悉的双指针：\nclass Solution: def merge(self , A, m, B, n): head = m + n - 1 while m \u0026gt; 0 and n \u0026gt; 0: if A[m - 1] \u0026gt; B[n - 1]: A[head] = A[m - 1] head, m = head - 1, m - 1 else: A[head] = B[n - 1] head, n = head - 1, n - 1 if n \u0026gt; 0: while head \u0026gt;= 0: A[head] = B[head] head = head - 1 看了题解才知道可以逃课，新技能 get！\nclass Solution: def merge(self , A, m, B, n): A[m: m + n] = B return A.sort() BM88 判断是否为回文字符串 逃课万岁！\nclass Solution: def judge(self , s: str) -\u0026gt; bool: return s == s[::-1] 双指针反而是最慢的😂\nclass Solution: def judge(self , s: str) -\u0026gt; bool: return all(s[i] == s[-1-i] for i in range(len(s) // 2)) BM89 合并区间 先按开头数字排序再合并：\nclass Solution: def merge(self , intervals: List[Interval]) -\u0026gt; List[Interval]: intervals.sort(key = lambda x: x.start) result = [] for i in intervals: if not result or i.start \u0026gt; result[-1].end: result.append(i) else: result[-1].end = max(result[-1].end, i.end) return result BM90 最小覆盖子串 看清楚题目很重要😂\n这里的覆盖，指的是包含 T 中所有字母，并且字母的数量也要覆盖。比如 T 中有 3 个 \u0026quot;a\u0026quot;，覆盖的子串也要至少含有 3 个 \u0026quot;a\u0026quot;，也就是说，\u0026quot;a\u0026quot; 不能覆盖 \u0026quot;aa\u0026quot;。\n穷举大概是最容易想到的办法了。首先准备一个 end 指针遍历 S，如果 S 前 end 个字母能覆盖 T，就用另一个指针 start 从最左边开始求最小覆盖：\nclass Solution: def minWindow(self , S: str, T: str) -\u0026gt; str: def cover(S, T): return all(t in S and S.count(t) \u0026gt;= T.count(t) for t in set(T)) result = \u0026#34;\u0026#34; for end in range(len(S)): if cover(S[0: end + 1], T): start = 1 while cover(S[start: end + 1], T): start += 1 if not result or len(result) \u0026gt; (end + 1 - start + 1): result = S[start - 1: end + 1] return result 然后就超时啦😂\n有什么办法可以改进一下呢？不难看到最大的问题是 start 总是从 0 开始，不能使用前一次的结果。注意到：\n 命题 如果存在比当前更小的覆盖子串，则该子串的 start 一定至少是当前的 start + 1。\n证明 首先显然 S[start:end + 1] 是 S[:end + 1] 的最小覆盖子串，因为直到第 end 位才凑齐所有字母，结束位不可能小于 end；又由于 start 在减少到 S[start:end + 1] 不为最小覆盖子串后停止，开始位也不可能大于 start，得证。\n因此，如果存在更小的覆盖子串，子串的 end 一定大于当前的 end，从而 start 也必然会大于当前的 start。\n 这就是题解使用的 滑动窗口法 了，不过依然是超时😂\nclass Solution: def minWindow(self , S: str, T: str) -\u0026gt; str: def cover(S, T): return all(t in S and S.count(t) \u0026gt;= T.count(t) for t in set(T)) result = \u0026#34;\u0026#34; for end in range(len(S)): start = 0 if cover(S[start: end + 1], T): while cover(S[start: end + 1], T): start += 1 if not result or len(result) \u0026gt; (end + 1 - start + 1): result = S[start - 1: end + 1] return result 不难看到目前的性能瓶颈就是 cover 函数了，有什么办法可以把 cover 的时间复杂度降到 O(1) 呢？自然是以空间换时间了：\n 使用一个字典 d 存放 T 中所有字母和出现的次数，使用一个变量 missing 存放还缺少的字母数量，显然检查 cover 变成了检查 missing 是否等于 0。 从左往右扫描 S，如果遇到 d 中存在的字母，且 d[s] \u0026gt; 0，则 d[s] 和 missing 同时减 1； 如果 d[s] \u0026lt;= 0 则 missing 保持不变，d[s] 减 1； 接下来检查 missing，如果 missing 等于 0，说明当前窗口 S[start: end + 1] 是覆盖了所有字母的子串，尝试 start 自增以缩小窗口； 在 start 加一之前，需要同时把 d[S[start]] 加一。如果 d[S[start]] 大于等于 0，还要同时把 missing 加一； 当 start 自增到 S[start: end + 1] 不是覆盖子串时，记录下 S[start - 1: end + 1] 作为结果。  class Solution: def minWindow(self , S: str, T: str) -\u0026gt; str: from collections import Counter missing, d, result, start = len(T), Counter(T), \u0026#34;\u0026#34;, 0 for end in range(len(S)): if S[end] in d: # 记录当前字母 missing -= (d[S[end]] \u0026gt; 0) d[S[end]] -= 1 if missing == 0: # 目前窗口包含了所有字母，左指针往右移 while missing == 0: if S[start] in d: missing += (d[S[start]] \u0026gt;= 0) d[S[start]] += 1 start += 1 if not result or len(result) \u0026gt; (end + 1 - start + 1): result = S[start - 1: end + 1] # 记录结果 return result 虽然是通过了，但这个方法一定可以找到最小覆盖子串吗？这就需要证明 start 能到达最小覆盖子串的开头字母，且在此之前 end 没有达到最小覆盖子串的结束字母之后。后者是显然的，因为最小覆盖子串已经涵盖了所有字母，由遍历的过程，不可能在 start 到达开头之前 end 已经跳过了结尾。至于前者，想了半小时才想明白😂\n因为 start 是一个一个元素遍历的，只需要证明 start 必然会停在最小子串的开头即可。如果在 start 还没到达开头之前，end 已经到达结尾，则已经符合要求；如果 end 没有到达结尾，比如刚好是倒数第 2 个元素，则 start 处的值一定和最小子串最后一个元素的值相等，显然下一次移动就能达到要求；同理，倒数第 n 个元素最多只需要再移动 n-1 次，一定会移动到最小子串的开头。\nBM91 反转字符串 因为 Python 的字符串不可变，用不了双指针，可以理直气壮逃课😂\nclass Solution: def solve(self , s: str) -\u0026gt; str: return s[::-1] BM92 最长无重复子数组 和 BM90 很像，也是滑动窗口。如果 arr[start:end] 没有重复而 arr[start: end + 1] 出现了重复，也就是说 arr[end] 出现在 arr[start:end] 的某个位置 pos，显然下一个可能的最长无重复子数组的 start 一定是从 pos + 1 开始。\nclass Solution: def maxLength(self , arr: List[int]) -\u0026gt; int: d, start, result = {}, 0, 0 for end in range(len(arr)): if arr[end] in d: # 出现重复，到达下一个子串 while arr[start] != arr[end]: d.pop(arr[start]) start += 1 start += 1 else: # 没有重复 d[arr[end]] = 1 result = max(result, end - start + 1) return result BM93 盛水最多的容器 笨办法自然是穷举所有可能，然后很快意识到并不需要，如果 height[start] \u0026lt; height[end]，end 再怎么变化，盛水的量也不会变多，于是只需要把较小的一边前往下一个可能的值即可：\nclass Solution: def maxArea(self , height: List[int]) -\u0026gt; int: start, end, result = 0, len(height) - 1, 0 while start \u0026lt; end: result = max(result, min(height[start], height[end]) * (end - start)) if height[start] \u0026lt; height[end]: start += 1 else: end -= 1 return result BM94 接雨水问题 方法一：正反遍历 这题如果直接做可能无从下手，好在做过 BM93 之后，多多少少会有头绪：如果一个位置 i 要储水，一定要比水桶的两边都要低。怎么找到水桶的两边呢？\n再仔细想想就会明白，水桶的左边是 i 左边的最大值，水桶的右边是 i 右边的最大值，于是可以使用一个两重循环来解决。然后很快就会发现，i 左边的最大值和 i 右边的最大值都可以通过一次遍历得到，于是时间复杂度就降到了 O(n)：\nclass Solution: def maxWater(self , arr: List[int]) -\u0026gt; int: left_max, right_max = [0] * len(arr), [0] * len(arr) for i in range(len(arr) - 1): left_max[i + 1] = max(left_max[i], arr[i]) right_max[- i - 2] = max(right_max[- i - 1], arr[- i - 1]) result = 0 for i in range(len(arr)): # 其实第一位和最后一位都接不了雨水 if arr[i] \u0026lt; min(left_max[i], right_max[i]): # 接雨水 result += min(left_max[i], right_max[i]) - arr[i] return result 方法二：双指针 和 BM93 的双指针法很相似，首先把 start, end 指向数组的两端，并准备 left_max, right_max 两个数组（其实只需要两个数）：\n 如果 left_max[start] \u0026lt; right_max[end]，因为 right_max[end] \u0026lt;= right_max[start]，显然此时对 start 而言，左边是最小的一边，计算出雨水量的大小，然后 start 往右移； 如果 left_max[start] \u0026gt;= right_max[end]，因为 left_max[end] \u0026gt;= left_max[start]，显然此时对 end 而言，右边是最小的一边，计算出雨水量的大小，然后 end 往左移； 当 start \u0026gt; end 时终止循环，返回结果。  算法的正确性时显然的，因为每次循环恰好算出一个位置的雨水量。\nclass Solution: def maxWater(self , arr: List[int]) -\u0026gt; int: start, end, left_max, right_max, result = 0, len(arr) - 1, 0, 0, 0 while start \u0026lt;= end: left_max = max(left_max, arr[start]) right_max = max(right_max, arr[end]) if left_max \u0026lt; right_max: result += left_max - arr[start] start += 1 else: result += right_max - arr[end] end -= 1 return result 方法三：单调栈 这个算法仿佛是为这道题目量身定制的，但是压根想不出来：\n 使用一个单调栈存储元素的索引； 如果元素的大小小于等于栈顶元素的大小，入栈； 如果元素的大小大于栈顶元素的大小，出栈，直到元素的大小小于等于栈顶元素的大小为止（或者栈为空）； 每出栈一个（非栈底）元素，算一次雨水的宽度（i 和剩下的栈顶元素的间隔）和高度（i 和剩下栈顶元素的最小值，减去出栈元素的值），累加起来就是结果。  官方题解 更详细，不过既然有更好的解法了，看不懂也没什么关系😂\nclass Solution: def maxWater(self , arr: List[int]) -\u0026gt; int: stack, result = [], 0 for i in range(len(arr)): if not stack or arr[i] \u0026lt;= arr[stack[-1]]: # 入栈 stack.append(i) else: # 出栈，算雨水 while arr[i] \u0026gt; arr[stack[-1]]: top = stack.pop() if not stack: # 栈底元素，跳过 break else: left = stack[-1] # 剩下的栈顶元素 width = i - left - 1 height = min(arr[left], arr[i]) - arr[top] result += width * height stack.append(i) return result BM95 分糖果问题 看了题解好久还是没看懂……如果面试遇到这道题就只能😭\n方法一：直接法  从左到右遍历数组； 如果 arr[i] \u0026gt; arr[i - 1]，就分 pre + 1 颗糖，上升计数+1； 如果 arr[i] == arr[i - 1]，只需要分 1 颗糖，重新开始； 如果 arr[i] \u0026lt; arr[i - 1]，只需要分 1 颗糖，并且把前面连续递减的数字都 +1。  前面 3 步都很容易理解，唯独第 4 步不容易理解也不好写，题解 的做法是用 increase 记录前面的上升次数（即峰值），如果遇到连续递减的数字个数 decrease 恰好与峰值的数字相同（比如峰值为 5，前面又有 4 个递减的数 4,3,2,1，此时 decrease = 4，这时又遇到一个递减的数），就把峰值也纳入递减序列中，即给 decrease 再 +1。\nclass Solution: def candy(self , arr: List[int]) -\u0026gt; int: result = 0 for i in range(len(arr)): if not result or arr[i] == arr[i - 1]: increase, decrease, pre = 1, 0, 1 result += pre elif arr[i] \u0026gt; arr[i - 1]: pre += 1 result += pre decrease = 0 increase = pre else: decrease += 1 if decrease == increase: decrease += 1 result += decrease pre = 1 return result 方法二：贪心法 贪心法更容易理解与实现：\n 正向遍历，如果 arr[i] \u0026gt; arr[i - 1]，则 left[i] = left[i - 1] + 1，否则 left[i] = 1； 反向遍历，如果 arr[i] \u0026gt; arr[i + 1]，则 right[i] = right[i + 1] + 1，否则 right[i] = 1； 联立起来求最大值，即 result[i] = max(left[i], right[i])，再返回 result 数组的和。  class Solution: def candy(self , arr: List[int]) -\u0026gt; int: left, right = [1] * len(arr), [1] * len(arr) for i in range(1, len(arr)): if arr[i] \u0026gt; arr[i - 1]: left[i] = left[i - 1] + 1 for i in range(len(arr) - 2, -1, -1): if arr[i] \u0026gt; arr[i + 1]: right[i] = right[i + 1] + 1 return sum(max(i, j) for i,j in zip(left, right)) 但是贪心法为什么是正确的呢？因为正向遍历和反向遍历，计算出来的都是满足题目要求的最小值的一个下界，即 result[i] \u0026gt;= max(left[i], right[i])，只需要验证 max(left[i], right[i]) 确实是符合题目要求的一个解。\n假设 A,B 是数组中相邻的两个数的下标，且 arr[A] \u0026gt; arr[B]，如果 A \u0026gt; B，则 left[A] \u0026gt; left[B] \u0026gt;= 1, right[A] \u0026gt;= right[B] = 1，故 max(left[A], right[A]) \u0026gt;= left[A] \u0026gt; max(left[B], right[B]) = left[B]。由对称性，B \u0026gt; A 时也成立。当 arr[A] == arr[B] 时，也显然是题目的解（因为题目没作要求），因此 max(left[i], right[i]) 确实是符合要求的解。故确实为最小值。\nBM96 主持人调度（二） 一开始想到 区间调度问题 去了，把简单的问题复杂化了……\n其实就是模拟一个队列系统，活动到开始时间就进入队列，到结束时间就离开队列，记录队列中活动数量的最大值。可以直接遍历，也可以借助数据结构（如小顶堆）：\nclass Solution: def minmumNumberOfHost(self , n: int, startEnd: List[List[int]]) -\u0026gt; int: import heapq startEnd.sort() queue = [] heapq.heapify(queue) result = 0 for start, end in startEnd: while queue and queue[0] \u0026lt;= start: heapq.heappop(queue) heapq.heappush(queue, end) result = max(result, len(queue)) return result 也有更简单直观的方法：记录下所有开始时间和结束时间，并按时间前后排序，result 从 0 开始，遇到开始时间 +1，遇到结束时间 -1，最后返回 result 的最大值：\nclass Solution: def minmumNumberOfHost(self , n: int, startEnd: List[List[int]]) -\u0026gt; int: start = [(i[0],1) for i in startEnd] end = [(i[1], -1) for i in startEnd] queue = sorted(start + end) result, tmp = 0, 0 for event in queue: tmp += event[1] result = max(result, tmp) return result BTW，无权重的区间调度问题（即选择数量最多的不重合区间）也是可以使用贪心算法得到最优解的。\nBM97 旋转数组 这个问题的历史可能比 Unix 还要悠久😂\n方法一：三次镜像 把数组分成 [A B]，先翻转一次得到 [B' A']，再分别翻转过来，就得到了 [B A]，反过来也可以。\nclass Solution: def solve(self , n: int, m: int, arr: List[int]) -\u0026gt; List[int]: m = m % n def reverse(nums, start, end): while start \u0026lt; end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 reverse(arr, 0, n - 1) reverse(arr, 0, m - 1) reverse(arr, m, n - 1) return arr 这一算法有诸多优点：容易理解与实现，空间和时间都很高效，代码简短难以出错。Ken Thompson 在 1971 年开发 ed 文本编辑器时使用了这一算法，并主张把它作为一种编程常识。\n方法二：循环移位 注意到移位后的坐标，0-\u0026gt;m, 1-\u0026gt;m+1,...,n-1-\u0026gt;m-1，恰好是每个坐标加上 m（再对 n 求余），只要找到一条遍历的路径就好。\n使用一点循环群的知识，如果 m,n 互素，0-\u0026gt;m-\u0026gt;2m-\u0026gt;...-\u0026gt;(n-1)m-\u0026gt;0 (mod n) 可以遍历数组的所有数。如果 m 和 n 最大公约数为 g \u0026gt; 1，需要分别以 range(g) 为开头遍历才能完成。想法虽然简单，要写出代码并不容易……\nclass Solution: def solve(self , n: int, m: int, arr: List[int]) -\u0026gt; List[int]: from math import gcd m = m % n for i in range(gcd(m, n)): tmp = arr[i] start = i while start != (i + m) % n: arr[start] = arr[(start + n - m) % n] # 题意要反过来 start = (start + n - m) % n arr[start] = tmp return arr 理论上，这个算法似乎是最快的，因为只是遍历所有数一次进行了移位，操作数量应该是最少的。然而现实中，随着 m,n 的增大，算法的速度并不让人满意。Jon Bentley 猜测，这个算法不能很好地利用高速缓存，还会影响系统页面的性能。\n方法三：块交换 其实逃课才是正常想法吧！\nclass Solution: def solve(self , n: int, m: int, arr: List[int]) -\u0026gt; List[int]: m = m % n arr[:m], arr[m:] = arr[-m:], arr[:n-m] return arr 但是题目不允许使用额外的空间进行交换，有什么方法呢？不妨假设 [A B] -\u0026gt; [B A]：\n 如果 A 和 B 等长，直接 swap(A, B) 即可； 如果 A 比 B 长，则分成 [A1 A2 B] 再 swap(A1, B) -\u0026gt;[B A2 A1]，转化成了交换 A2 和 A1 的子问题； 如果 A 比 B 短，同样分成 [A B1 B2] 再 swap(A, B2) -\u0026gt; [B2 B1 A]，转化成了交换 B2 与 B1 的子问题。  可以看到这一流程等价于求最大公约数的更相减损术，故一定会终止。可以使用递归，也可以使用迭代（Gries \u0026amp; Mills）：\nclass Solution: def solve(self , n: int, m: int, arr: List[int]) -\u0026gt; List[int]: def swap(a, b, m): # arr[a,...,a+m-1] \u0026lt;-\u0026gt; arr[b,...,b+m-1] for i in range(m): arr[a + i], arr[b + i] = arr[b + i], arr[a + i] m = m % n if m == 0: return arr p, i, j = n - m, n - m, m # 把前面 n-m 个元素移到后面 while i != j: # p - 分界点，i - 左边长度，j - 右边长度 if i \u0026gt; j: # 左边比右边长 [A1 A2 B] -\u0026gt; [B A2 A1] swap(p - i, p, j) i -= j else: # 右边比左边长 [A B1 B2] -\u0026gt; [B2 B1 A] swap(p - i, p + j - i, i) j -= i swap(p - i, p, i) return arr 这是实际测试中最快的算法（可能因为能利用高速缓存），不过写起来复杂容易出错。\n扩展阅读：《编程珠玑》by Jon Bentley\nBM98 螺旋矩阵 挺普通的一道题……模拟 4 个边界，撞到边界之后更新边界的值和前进方向，难点是确定终止条件。\n这里为了简便使用了复数记录矩阵的坐标，(i,j) 表示矩阵第 i 行第 j 列。\nclass Solution: def spiralOrder(self , matrix: List[List[int]]) -\u0026gt; List[int]: if not matrix or not matrix[0]: return [] moves = ( 1j, 1, -1j, -1) # 右 下 左 上 bounds = [0, len(matrix[0]) - 1, len(matrix) - 1, 0] # 上 右 下 左 status, cor, result = 0, 0j, [] while True: if bounds[0] \u0026lt;= cor.real \u0026lt;= bounds[2] and bounds[3] \u0026lt;= cor.imag \u0026lt;= bounds[1]: # 仍然在边界范围内 result.append(matrix[int(cor.real)][int(cor.imag)]) cor += moves[status] else: # 越界 if bounds[0] \u0026gt; bounds[2] or bounds[3] \u0026gt; bounds[1]: # 终止条件 break else: #退一格，更新边界值，前进 cor -= moves[status] if status in (0, 3): bounds[status] += 1 else: bounds[status] -= 1 status = (status + 1) % 4 cor += moves[status] return result BM99 顺时针旋转矩阵 和 BM97 类似，先转置后翻转：\nclass Solution: def rotateMatrix(self , mat: List[List[int]], n: int) -\u0026gt; List[List[int]]: for i in range(n): # 转置矩阵 for j in range(i + 1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] for i in range(n): # 翻转矩阵 for j in range(n // 2): mat[i][j], mat[i][n - 1 - j] = mat[i][n - 1 - j], mat[i][j] return mat BM100 设计LRU缓存结构 想了很久都没有想明白怎么把哈希表和双向链表结合在一起还能做到 O(1)，一看源码，是使用哈希表存放 key 对应的双向链表结点的引用，这是怎么想出来的😭\n get 的流程：首先查询哈希表 d，如果找到 d[key]，访问 d[key] 的结点获取 val（哈希表，O(1)），并把 d[key] 的结点移到末尾（双向链表，O(1)）； set 的流程：如果 key 存在，访问 d[key] 的结点修改 val（哈希表，O(1)），并把 d[key] 的结点移到末尾（双向链表，O(1)）；否则新增结点，如果容量不足，需要删掉双向链表头结点（双向链表，O(1)）并且同时删掉对应的 d[key] 记录（哈希表，O(1)），然后在双向链表末端插入结点（双向链表，O(1)），最后给 d[key] 写入结点的引用（哈希表，O(1)）。  class Node: # 双向链表结点，存储 val def __init__(self, key, val): self.key = key # 为了能删除头结点 self.val = val self.pre = None self.next = None class Solution: def __init__(self, capacity: int): self.size = capacity self.head = None self.tail = None self.d = dict() def insert_end(self, node): # 链表尾插入新结点 if self.head == None: self.head = self.tail = node else: self.tail.next = node node.pre = self.tail self.tail = node def move_to_end(self, node): # 把结点移到链表尾 if node == self.tail: return elif node == self.head: # 脱离 if node.next: node.next.pre = None self.head = node.next else: self.head = self.tail = None else: pre, nxt = node.pre, node.next pre.next, nxt.pre = nxt, pre node.next = None self.insert_end(node) def remove_head(self): # 删除头结点 node = self.head self.d.pop(node.key) node.next.pre = None self.head = node.next del node def get(self, key: int) -\u0026gt; int: result = -1 if key in self.d: result = self.d[key].val self.move_to_end(self.d[key]) return result def set(self, key: int, value: int) -\u0026gt; None: if key in self.d: # 更新值 self.d[key].val = value self.move_to_end(self.d[key]) else: if self.size \u0026lt;= 0: self.remove_head() else: self.size -= 1 node = Node(key, value) self.d[key] = node self.insert_end(node) Python 的 OrderedDict 就是 使用哈希表+双链表实现的，OrderedDict 还提供了 官方逃课教程：\nfrom collections import OrderedDict class Solution: def __init__(self, capacity: int): self.size = capacity self.cache = OrderedDict() def get(self, key: int) -\u0026gt; int: result = -1 if key in self.cache: result = self.cache[key] self.cache.move_to_end(key) return result def set(self, key: int, value: int) -\u0026gt; None: if key in self.cache: # 更新值 self.cache[key] = value self.cache.move_to_end(key) else: if self.size \u0026lt;= 0: self.cache.popitem(last=False) else: self.size -= 1 self.cache[key] = value 除此以外，LRU 也可以使用哈希表+平衡二叉树（小顶堆）实现，比如初始化一个时间计数器 time，每插入/更新一次元素就修改一次时间计数器，并作为元素的排序依据。为了维护有序性，每次插入和更新元素的时间复杂度就变成了 O(log n)。\n不过 Python 没有内置平衡二叉树，小顶堆 heapq 是使用列表（数组）存储的，不能实现 O(log n) 删除或更新元素（heapq.heapify 是 O(n) 的，如果知道下标倒是 可以，但是下标会变），只能不太优雅地学 优先队列的实现 把元素设置为移除状态，更新数据后作为新元素重新插入。\n如果只是把元素设置成移除状态（而不是真的移除），其实也可以把双向链表换成双端队列，也可以学 LFU 使用哈希表（key 为 time）代替双向链表，需要额外维护一个 min_time 状态，不过因为 time 的跳跃增长，效率会有所下降。\nBM101 设计LFU缓存结构 和 LRU 类似，只是要比较的对象从“最近访问时间”变成 (访问频率，最近访问时间) 的二元组。Python 可以直接比较元组/列表的大小：\n\u0026gt;\u0026gt;\u0026gt; [1,1] \u0026lt; [1,2] \u0026lt; [2,1] \u0026lt; [2,2] True 因此可以把双向链表换成小顶堆/平衡二叉树来实现，不过满足不了时间复杂度 O(1) 的要求。\n另一种做法是综合利用前面的三点经验：\n 使用哈希表的值存放目标对象的引用，可以在不降低时间复杂度的情况下进行扩展； 使用一个 min_key 状态和哈希表，可以实现 O(1) 时间复杂度下可更新 key 数值的队列； 使用双向链表同样可以实现 O(1) 时间复杂度的队列，但不能随意更新 key 的数值。  于是可设计为：\n 依然是使用总哈希表存放值结点的引用； 因为使用频率 freq 每次更新是 +1 的，可以使用 min_freq 状态和另一个 freq 哈希表存放频率和值结点所在的数据结构； 最后，因为最近访问时间 time 每次更新都是移到结尾，可以使用双向链表来存储结点，这样就不需要存储访问时间的值了。  具体而言：\n 使用双向链表的结点存放对应的值（以及访问频率 freq）； 每个结点所在的双向链表，存放相同访问频率 freq 的结点，双向链表的引用作为 freq 哈希表中访问频率对应的值； 调用 set 时，首先通过总哈希表检查元素是否存在（哈希表，O(1)）：   如果存在，访问结点修改对应的值（O(1)），同时得到当前访问频率 freq；     使用 freq 哈希表，找到结点所在的双向链表（O(1)），从双向链表中移除结点（O(1)）；     更新结点的访问频率 freq，并插入对应频率在哈希表中对应的双向链表末端（O(1)），此时可能需要更新 min_freq 的值；     如果不存在，首先检查可用容量 capacity 是否大于 0，如果大于 0，新建这个结点，并插入到访问频率为 0 的双向链表末端，最后在总哈希表中填入引用；     如果小于 0，检查 min_freq 的值，在访问频率为 min_freq 的双向链表中移除头部的值再插入；     写入新结点完成后，重新把 min_freq 的值设为 0。   调用 get 时和 set 类似，如果存在，更新频率后返回值；如果不存在，返回 -1。  很精巧的设计！就算看懂了，要写起来也并不容易。怎么表示双向链表呢？怎么检查双向链表是否为空呢（此时 min_freq += 1）？写着写着，一个晚上就没了😭\n最后还是磕磕碰碰照着题解写了 100 行……如果面试遇到这道题，快跑！\nfrom collections import defaultdict class Node: # 双向链表结点，存储 key, val, freq def __init__(self, key, val, freq=0): self.key = key self.val = val self.freq = freq self.pre = None self.next = None class DLL: # 定义双链表 def __init__(self): self.head = self.tail = None def insert_end(self, node): # 插入尾结点 if self.head == None: self.head = self.tail = node else: self.tail.next = node node.pre = self.tail self.tail = node def remove_head(self): # 删除头结点 if self.head: node = self.head if node.next: node.next.pre = None else: # node == self.tail self.tail = None self.head = node.next return node def pop(self, node): # 移除特定结点 if node == self.head: self.remove_head() elif node == self.tail: node.pre.next = None self.tail = node.pre else: node.pre.next = node.next node.next.pre = node.pre def __bool__(self): # 判断是否为空 return not self.head == self.tail == None class Solution: def __init__(self, capacity=0): self.size = capacity self.cache = dict() self.freq_cache = defaultdict(DLL) self.min_freq = 0 def update(self, node, key, val): # 更新结点，访问频率+1 freq = node.freq self.freq_cache[freq].pop(node) if not self.freq_cache[freq]: # 双向链表为空 self.freq_cache.pop(freq) if self.min_freq == freq: self.min_freq += 1 node = Node(key, val, freq=freq+1) self.freq_cache[freq + 1].insert_end(node) self.cache[key] = node def set(self, key, val): if key in self.cache: self.update(self.cache[key], key, val) else: if self.size == 0: # 移除频率最低的缓存 old_node = self.freq_cache[self.min_freq].remove_head() if not self.freq_cache[self.min_freq]: # 双向链表为空 self.freq_cache.pop(self.min_freq) self.cache.pop(old_node.key) else: self.size -= 1 self.min_freq = 0 node = Node(key, val, freq=0) self.freq_cache[0].insert_end(node) self.cache[key] = node def get(self, key): res = -1 if key in self.cache: node = self.cache[key] res = node.val self.update(node, key, res) return res def LFU(self , operators: List[List[int]], k: int) -\u0026gt; List[int]: res = [] self.size = k for op in operators: if op[0] == 1: # set 操作 self.set(op[1], op[2]) else: # get 操作 res.append(self.get(op[1])) return res 天啊，整整 100 行！调试调了一个小时！终于结束了😭\n","date":"2022-04-13T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-07/","title":"做题笔记07：字符串/双指针/贪心算法/模拟"},{"content":"BM62 斐波那契数列 首先想到的自然是递推法：\nclass Solution: def Fibonacci(self , n: int) -\u0026gt; int: F_n_pre, F_n = 0, 1 # F_0, F_1 for _ in range(n - 1): F_n, F_n_pre = F_n + F_n_pre, F_n return F_n 不过，使用一点线性代数的知识：\n$$ \\left[\\begin{array}{c} F_2\\newline F_1 \\end{array}\\right] = \\left[\\begin{array}{c} F_1 + F_0\\newline F_1 \\end{array}\\right] = \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right]^{} \\left[\\begin{array}{c} F_1\\newline F_0 \\end{array}\\right] \\Rightarrow \\left[\\begin{array}{c} F_n\\newline F_{n - 1} \\end{array}\\right] = \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right]^{n} \\left[\\begin{array}{c} F_0\\newline F_{-1} \\end{array}\\right] $$\n就可以更快地算出结果，没错，就是快速幂算法！从最高位开始往下走（左移），遇到 0 平方（乘2），遇到 1 平方并乘自身（乘2加1）：\n$$6 = 0110_2 = ((0 \\cdot 2 + 1) \\cdot 2 + 1) \\cdot 2 \\Rightarrow a^6 = (((a^0)^2 \\cdot a)^2 \\cdot a)^2 = a^{((0 \\cdot 2 + 1) \\cdot 2 + 1) \\cdot 2}$$\n也许你已经迫不及待开始写代码了，但还可以更快一点，注意到：\n$$ \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right] = \\left[\\begin{array}{cc} F_2 \u0026amp; F_1\\newline F_1 \u0026amp; F_0 \\end{array}\\right] \\Rightarrow \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right]^n = \\left[\\begin{array}{cc} F_{n + 1} \u0026amp; F_n\\newline F_n \u0026amp; F_{n - 1} \\end{array}\\right] $$\n于是快速幂还可以进一步优化：\n$$ \\left[\\begin{array}{cc} F_{2 n + 1} \u0026amp; F_{2 n}\\newline F_{2 n} \u0026amp; F_{2 n - 1} \\end{array}\\right] = \\left[\\begin{array}{cc} 1 \u0026amp; 1\\newline 1 \u0026amp; 0 \\end{array}\\right]^{2 n} = \\left[\\begin{array}{cc} F_{n + 1} \u0026amp; F_n\\newline F_n \u0026amp; F_{n - 1} \\end{array}\\right]^2 = \\left[\\begin{array}{cc} F_{n + 1}^2 + F_n^2 \u0026amp; \\ast\\newline (F_{n + 1} + F_{n - 1}) F_n \u0026amp; \\ast \\end{array}\\right] $$\n得到最终结果：\n$$ F_{2 n + 1} = F_{n + 1}^2 + F_n^2, F_{2 n} = (F_{n + 1} + F_{n - 1}) F_n = (2 F_{n + 1} - F_n) F_n, F_{2 n + 2} = F_{n + 1}(2 F_n + F_{n + 1}) $$\nclass Solution: def Fibonacci(self , n: int) -\u0026gt; int: F_n, F_n_next = 0, 1 # F_0, F_1 highbit = 1 \u0026lt;\u0026lt; (n.bit_length() - 1) while highbit: if highbit \u0026amp; n: # n, n + 1 -\u0026gt; 2n + 1, 2n + 2 F_n, F_n_next = F_n * F_n + F_n_next * F_n_next, F_n_next * (2 * F_n + F_n_next) else: # n, n + 1 -\u0026gt; 2n, 2n + 1 F_n_next, F_n = F_n * F_n + F_n_next * F_n_next, F_n * (2 * F_n_next - F_n) highbit \u0026gt;\u0026gt;= 1 return F_n BM63 跳台阶 不难注意到 $F_0 = F_1 = 1, F_n = F_{n-1} + F_{n-2}$，即求 Fib(n+1)，把最后一行的 F_n 改成 F_n_next 即可。\nBM64 最小花费爬楼梯 动态规划第一题，假设爬上第 $i$ 级台阶的成本是 $C_i$，则 $C_0=0,C_1=\\min(0,C_0+\\text{cost}[0])=0,C_n=\\min(C_{n-2}+\\text{cost}[n-2], C_{n-1}+\\text{cost}[n-1])$。\nclass Solution: def minCostClimbingStairs(self , cost: List[int]) -\u0026gt; int: C_n_pre, C_n = 0, 0 # C_0, C_1 for idx in range(len(cost) - 1): # idx: 0 -\u0026gt; C_2, n-2 -\u0026gt; C_n C_n_pre, C_n = C_n, min(C_n_pre + cost[idx], C_n + cost[idx+1]) return C_n BM65 最长公共子序列(二) 看懂题目很重要😂\n子序列是指序列的某个子集（按顺序，不考虑重复），比如对字符串 \u0026quot;abcbda\u0026quot; 而言，任何一位字符都是子序列，任意抽取 $0 \\le n \\le 6$ 个字符也是子序列，如字符 1,3,6 构成的子序列为 \u0026quot;aca\u0026quot;。如果所有字符都不相同，则子序列的个数为 $2^n$（所有子集的个数）。假设两个字符串的长度分别为 $m,n$，则穷举需要比较 $2^m \\cdot 2^n=2^{m+n}$ 次。\n最长公共子序列可以衡量两个字符串的相似程度。在生物信息学中，常常需要比对不同的 DNA（由 ATCG 四个字母组成）、RNA（AUCG）、蛋白质（20 种氨基酸）的超长（字符串）序列。穷举的指数级时间复杂度，显然是不可被接受的。\n假设字符串 $X_m=[x_1,\\dots,x_m],Y_n=[y_1,\\dots,y_n]$ 的最长公共子序列为 $Z_k=[z_1,\\dots,z_k]$：\n 如果 $x_m=y_n$，则 $z_k=x_m=y_n$（否则可以把 $x_m$ 加入 $Z_k$ 中得到更长的公共子序列），此时 $Z_{k-1}$ 是 $X_{m-1},Y_{n-1}$ 的最长公共子序列； 如果 $x_m \\neq y_n$，则 $z_k \\neq x_m$ 意味着 $Z_k$ 是 $X_{m-1}$ 和 $Y_n$ 的最长公共子序列（显然是公共子序列，如果存在比它长的 $X_{m-1}, Y_n$ 公共子序列 $Z'$，则 $Z'$ 也是 $X_m, Y_n$ 的公共子序列，矛盾），同理 $z_k \\neq y_n$ 意味着 $Z_k$ 是 $X_m$ 和 $Y_{n-1}$ 的最长公共子序列。  我们要求的是 $Z_k$，由 (1)，如果 $x_m=y_n$，则可以得到 $z_k$，问题转化为求 $X_{m-1},Y_{n-1}$ 的最长公共子序列 $Z_{k-1}$；如果 $x_m \\neq y_n$，$z_k$ 有三种可能，$z_k = x_m \\neq y_n$，$z_k = y_n \\neq x_m$ 以及 $z_k \\neq x_m, z_k \\neq y_n$，而这三种可能都满足 (2)，故无论哪一种可能，只需要求 $X_{m-1}$ 和 $Y_n$ 的最长公共子序列 $Z$ 以及 $X_m$ 和 $Y_{n-1}$ 的最长公共子序列 $Z'$，$Z_k$ 必为 $Z,Z'$ 之一，且 $Z,Z'$ 都是 $Z_k$ 的子序列，故取 $Z,Z'$ 中较长者即为 $Z_k$。\n假设 $c[i][j]$ 表示 $X_i,Y_j$ 的最长公共子序列长度，则：\n$$ c[i][j] = \\left\\{ \\begin{array}{ll} 0 \u0026amp; i = 0 \\hspace{0.5em} \\text{or} \\hspace{0.5em} j = 0\\newline c[i - 1][j - 1] + 1 \u0026amp; i, j \u0026gt; 0, x_i = y_j\\newline \\max (c[i - 1][j], c [i][j - 1]) \u0026amp; i, j \u0026gt; 0, x_i \\neq y_j \\end{array} \\right. $$\n显然可以使用动态规划求解，首先做出表格，然后从左到右从上到下求解，不过结果可能不唯一（比如 \u0026quot;a\u0026quot; 和 \u0026quot;b\u0026quot; 都是 \u0026quot;ab\u0026quot; 和 \u0026quot;ba\u0026quot; 的最长公共子序列）。动手算一下就能发现，其实只需要保留上一行的结果。\nclass Solution: def LCS(self , s1: str, s2: str) -\u0026gt; str: m, n = len(s1), len(s2) result = [(0, \u0026#34;\u0026#34;)] * (n + 1) # 第 0 行，共有 n 个元素 for i in range(m): tmp = result.copy() # 保留上一行的结果 for j in range(n): if s1[i] == s2[j]: # c[i-1][j-1] + 1 count, seq = tmp[j] result[j+1] = (count + 1, seq + s2[j]) else: # max(c[i-1][j], c[i][j-1]) result[j+1] = max(tmp[j+1], result[j]) return result[n][1] if result[n][1] else -1 扩展阅读：《算法导论》、《生物信息学算法导论》。\nBM66 最长公共子串 方法一：动态规划（不给过） 很自然想把上一题套进来，如果 $x_i = y_j$，就有 $c[i][j] = c[i - 1][j - 1] + 1$，但是 $x_i \\neq y_j$ 怎么办呢？显然这里的 $c[i][j]$ 不能作为全局的状态，只能作为局部的状态，因此可以直接置零：\n$$ c[i][j] = \\left\\{ \\begin{array}{ll} 0 \u0026amp; i = 0 \\hspace{0.5em} \\text{or} \\hspace{0.5em} j = 0 \\hspace{0.5em} \\text{or} \\hspace{0.5em} x_i \\neq y_j \\newline c[i - 1][j - 1] + 1 \u0026amp; i, j \u0026gt; 0, x_i = y_j\\newline \\end{array} \\right. $$\n此时 $c[i][j]$ 表示从 $x[i]$ 开始计数，往前数 $c[i][j]$ 个元素，是一个公共子串。如 $c[i][j] = 1 \\Rightarrow x[i]=y[j],c[i][j] = 2 \\Rightarrow x[i]=y[j], x[i-1]=y[j-1],\\dots$\nclass Solution: def LCS(self , str1: str, str2: str) -\u0026gt; str: m, n = len(str1), len(str2), longest, res = (0, -1), [0] * (n + 1) for i in range(m): tmp = res.copy() for j in range(n): if str1[i] == str2[j]: res[j+1] = tmp[j] + 1 else: res[j+1] = 0 if res[j+1] \u0026gt; longest[0]: longest = (res[j+1], j + 1) return str2[longest[1] - longest[0]:longest[1]] 方法二：滑动窗口 这个算法可能不是很好懂，这里以 \u0026quot;1AB2345CD\u0026quot;,\u0026quot;12345EF\u0026quot; 为例，如果还是看不懂，建议使用 PythonTutor：\n 首先窗口大小为 1，从左边字符串 str1 的第一个字母 \u0026quot;1\u0026quot; 开始； 这个窗口 \u0026quot;1\u0026quot; 在右边字符串 str2 中，记录结果，把窗口变大，此时窗口变成 2； 此时窗口仍然是从 str1 的第一个字母开始，大小为 2，即 \u0026quot;1A\u0026quot;； 窗口 \u0026quot;1A\u0026quot; 不在 str2 中，向右滑动窗口，变成 \u0026quot;AB\u0026quot;； 同理，因为 \u0026quot;AB\u0026quot; 不在 str2 中，会一直滑动（\u0026quot;AB\u0026quot;-\u0026gt;\u0026quot;B2\u0026quot;-\u0026gt;\u0026quot;23\u0026quot;）； 窗口 \u0026quot;23\u0026quot; 在 str2 中，记录下结果，把窗口变大，此时窗口变成 \u0026quot;234\u0026quot;； 同理，因为 \u0026quot;234\u0026quot; 在 str2 中，记录后窗口变成 \u0026quot;2345\u0026quot;，记录下 \u0026quot;2345\u0026quot; 后，窗口扩大成 \u0026quot;2345C\u0026quot;； 因为 \u0026quot;2345C\u0026quot; 不在 str2 中，向右滑动窗口，变成 \u0026quot;345CD\u0026quot;； 同样 \u0026quot;345CD\u0026quot; 也不在 str2 中，无法再滑动窗口，故返回最后一次记录 \u0026quot;2345\u0026quot;。  class Solution: def LCS(self , str1: str, str2: str) -\u0026gt; str: res, left = \u0026#34;\u0026#34;, 0 for i in range(len(str1)): if str1[left:i + 1] in str2: # 记录结果，扩大窗口 res = str1[left:i + 1] else: # 滑动窗口 left = left + 1 return res 算法显然是正确的，因为最长的公共子串的首字母，一定会被滑动窗口滑到（窗口是一步一步往右滑的），然后窗口不断变大，直到超出范围（或到达末端）为止，因为是最长的子串，后面一定不会存在能扩大窗口的子串，故一定返回正确的结果。\n当然，检查窗口是否在字符串中需要高效的匹配算法，如 Rabin-Karp，KMP 算法等，Python 结合使用了 Boyer-Moore 算法和 Boyer-Moore-Horspool 算法。\nBM67 不同路径的数目(一) 显然 $dp[i][j]=dp[i-1][j]+dp[i][j-1]$，不过为什么不作弊呢？任意一条路径都需要往右走 $m-1$ 步。往下走 $n-1$ 步，一共 $m+n-2$ 步。反过来，确定了这 $m+n-2$ 步中往右走或往下走的位置，就确定了一条路径，故路径的数目为：\n$$ \\binom{m + n - 2}{m - 1} = \\binom{m + n - 2}{n - 1} = \\frac{(m + n - 2) !}{(m - 1) ! (n - 1) !} = \\frac{m + n - 2}{1} \\frac{m + n - 3}{2} \\cdots \\frac{m}{n - 1} $$\nclass Solution: def uniquePaths(self , m: int, n: int) -\u0026gt; int: result = 1 for i in range(1, min(m, n)): result *= m + n - 1 - i result //= i # 2 / 1 = 2.0 return result # return math.comb(m + n - 2, m - 1) BM68 矩阵的最小路径和 $dp[i][j]=\\min(dp[i-1][j],dp[i][j-1])+a[i][j]$，还要处理一下 $i=0$ 和 $j=0$ 的情形：\nclass Solution: def minPathSum(self , matrix: List[List[int]]) -\u0026gt; int: m, n = len(matrix), len(matrix[0]) for i in range(m): for j in range(n): if i == 0 and j == 0: pass elif i == 0: # 第一行 matrix[i][j] += matrix[i][j-1] elif j == 0: # 第一列 matrix[i][j] += matrix[i-1][j] else: matrix[i][j] += min(matrix[i-1][j], matrix[i][j-1]) return matrix[m-1][n-1] BM69 把数字翻译成字符串 一开始感觉无从下手，后来才想明白，就是带条件的跳台阶。假设 $s[i-1]s[i]$ 这两位为 $x$，则 $x$ 存在二义性时，$dp[i]=dp[i-1]+dp[i-2]$，否则 $dp[i]=dp[i-1]$ 或者 $dp[i]=dp[i-2]$。\n剑指 Offer 第46题 0-\u0026gt;A, 25-\u0026gt;Z，因此存在二义性当且仅当 $x$ 不以 0 开头，即 $x \\in [10,25]$，否则从中间分开译码，$dp[i]=dp[i-1]$。然而这题没有这么简单，需要仔细判断各种情况：\n $x \\in [11,19] \\cup [21,26]$ 时，显然存在二义性，故 $dp[i]=dp[i-1]+dp[i-2]$； $x \\in \\{10,20\\}$ 时，不存在二义性，不需要分开译码，此时 $dp[i]=dp[i-2]$； 如果 $x$ 以 0 结尾（00,30,...,90），则没有译码结果，此时直接返回 0； 否则（01-09,27-29,...,91-99）没有二义性，此时要从中间分开译码，$dp[i]=dp[i-1]$。  此外，以 0 开头的字符串也没有译码结果。\nclass Solution: def solve(self , nums: str) -\u0026gt; int: tmp, n = 1, len(nums) for i in range(n): if i == 0: if nums[i] != 0: result = tmp # tmp 缓存 dp[i-1] 的结果 else: # 第一位为 0， 没有译码结果 result = 0 break else: # n \u0026gt;= 2 if 11 \u0026lt;= int(nums[i-1:i+1]) \u0026lt;= 19 or 21 \u0026lt;= int(nums[i-1:i+1]) \u0026lt;= 26 : tmp, result = result, result + tmp # dp[i]=dp[i-1]+dp[i-2] elif int(nums[i-1:i+1]) in (10, 20): tmp, result = result, tmp # dp[i]=dp[i-2] elif nums[i] != \u0026#34;0\u0026#34;: tmp = result # dp[i]=dp[i-1] else: result = 0 break return result BM70 兑换零钱(一) 假如纸币面值为 [2,3,5]，显然 $dp[i] = \\min(dp[i-2], dp[i-3], dp[i-5]) + 1$，只要注意：\n 可能会出现无法兑换的情形，这时就需要把 $dp[i]$ 设置成一个不可能取到的特殊值，比如 aim+1（aim 表示要兑换的总额），如果最终结果大于等于这个数，说明无法兑换； 如何初始化？类似上面的做法，把预留的位置初始化为 aim+1 即可，此外还要注意 $dp[0]=0$。  class Solution: def minMoney(self , arr: List[int], aim: int) -\u0026gt; int: if not arr: return -1 from collections import deque arr = sorted(arr) dp = deque([aim + 1] * (arr[-1] - 1) + [0]) # dp[0] = 0 for i in range(aim): dp.append(min(dp[-j] for j in arr) + 1) dp.popleft() return dp[-1] if dp[-1] \u0026lt; (aim + 1) else -1 BM71 最长上升子序列(一) 方法一：动态规划 虽然已经做了很多动态规划题，但还是无从下手😂\n首先自然是思考 $dp$ 是记录什么状态的数组，由题意不妨假设 $dp[i]$ 是从开头到第 i 个字符的最长上升子序列长度。那么如何从 $dp[i]$ 到 $dp[i+1]$ 呢？需要筛选出 $arr[i+1]$ 前面所有严格比 $arr[i+1]$ 小的元素，并记录下标 $k_1,k_2,...$，于是 $dp[i+1]=\\max(dp[k_1], dp[k_2],...) + 1$；如果不存在严格小的元素，$dp[i+1]=1$。\n两种情况合起来就是 $dp[i+1]=\\max(dp[k_1] + 1, dp[k_2] + 1,...,1)$，最后返回 $dp$ 数组的最大值。\nclass Solution: def LIS(self , arr: List[int]) -\u0026gt; int: dp = [1] * len(arr) for i in range(len(arr)): for j in range(i): if arr[j] \u0026lt; arr[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) if dp else 0 方法二：贪心二分查找 如果 $a[k_1], a[k_2], \\dots, a[k_n]$ 是最长的上升子序列，那么 $a[k_1], a[k_2], \\dots, a[k_{n-1}]$ 的值应该尽可能的小。于是可以维护一个数组 $d[i]$，在遍历 arr 时记录长度为 $i$ 的上升子序列中，末位数字的最小值，如 [1,5,3,2,4] 对应的 $d[i]$ 为 [1] -\u0026gt; [1,5] -\u0026gt; [1,3] -\u0026gt; [1,2] -\u0026gt; [1,2,4]。更详细地说：\n $d[i]$ 一直是递增的，因为如果存在后面的元素比前面的小，说明存在更长的末位数字更小的上升子序列，删掉该序列一部分元素就引出了矛盾； 当 $arr[i]$ 大于 $d[i]$ 最后一位时，说明存在更长的上升子序列，把 $arr[i]$ 加入 $d[i]$ 末尾； 当 $arr[i]$ 小于 $d[i]$ 某个元素，比如 $d[i]=[1,2,4,6,7],arr[i]=3$，显然 [1,2,3] 是末尾数字更小的长度为 3 的上升子序列，令 $d[3]=arr[i] \\Rightarrow d[i]=[1,2,3,6,7]$。  第三步需要使用二分查找，最后返回数组 $d[i]$ 的长度即可。好久没写二分查找了，心惊胆战写完没想到一遍过😂\nclass Solution: def LIS(self , arr: List[int]) -\u0026gt; int: d = [] for i in range(len(arr)): if not d or arr[i] \u0026gt; d[-1]: d.append(arr[i]) elif arr[i] \u0026lt; d[-1]: left, right = 0, len(d) - 1 while left \u0026lt; right: mid = (left + right) // 2 if arr[i] \u0026lt; d[mid]: right = mid elif arr[i] \u0026gt; d[mid]: left = mid + 1 else: left = right = mid d[left] = arr[i] return len(d) BM72 连续子数组的最大和 简单得难以置信！假设 $dp[i]$ 表示以第 i 个元素结尾的连续子数组的最大和，即\n$$dp[i] = \\max(arr[i], arr[i]+arr[i-1],\\dots,\\sum_{j=1}^{i}arr[j])$$\n显然：\n$$ \\begin{array}{lll} d p [i + 1] \u0026amp; = \u0026amp; \\max (a r r [i + 1], a r r [i + 1] + a r r [i], \\ldots, \\sum_{j = 1}^{i + 1} a r r [j])\\newline \u0026amp; = \u0026amp; \\max \\left( a r r [i + 1], \\max \\left( a r r [i + 1] + a r r [i], \\ldots, \\sum_{j = 1}^{i + 1} a r r [j] \\right) \\right)\\newline \u0026amp; = \u0026amp; \\max \\left( a r r [i + 1], a r r [i + 1] + \\max \\left( a r r [i], \\ldots, \\sum_{j = 1}^i a r r [j] \\right) \\right)\\newline \u0026amp; = \u0026amp; \\max (a r r [i + 1], a r r [i + 1] + d p [i]) \\end{array} $$\nclass Solution: def FindGreatestSumOfSubArray(self , arr: List[int]) -\u0026gt; int: dp, result = 0, arr[0] for num in arr: dp = max(num, dp + num) result = max(dp, result) return result BM73 最长回文子串 方法一：中心扩散 从左到右遍历字符串，把每个字符当作回文子串的中心，尝试向左右扩散，注意要区分子串长度为奇数和偶数两种情况。\nclass Solution: def getLongestPalindrome(self , A: str) -\u0026gt; int: def expand(A, left, right): while 0 \u0026lt;= left and right \u0026lt; len(A) and A[left] == A[right]: left, right = left - 1, right + 1 return right - left - 1 result = 1 for i in range(len(A) - 1): result = max(result, expand(A, i, i), expand(A, i, i + 1)) return result 方法二：动态规划 如果 $dp[i][j]$ 表示第 i 个字符到第 j 个字符是否为回文子串：\n$$ d p [i] [j] = \\left\\{ \\begin{array}{ll} \\text{False} \u0026amp; i \u0026gt; j\\newline \\text{True} \u0026amp; i = j\\newline (A_i = = A_j) \u0026amp; i + 1 = j\\newline d p [i + 1] [j - 1] \\wedge (A_i = = A_j) \u0026amp; i + 1 \u0026lt; j \\end{array} \\right. $$\n在实现上，可以把 False 记为 0，True 记为回文子串的长度，即：\n$$ d p [i] [j] = \\left\\{ \\begin{array}{ll} 0 \u0026amp; i \u0026gt; j \\vee (A_i \\neq A_j)\\newline 1 \u0026amp; i = j\\newline 2 \u0026amp; i + 1 = j \\wedge (A_i = = A_j) \\newline d p [i + 1] [j - 1] + 2 \u0026amp; i + 1 \u0026lt; j \\wedge (A_i = = A_j) \\wedge d p [i + 1] [j - 1] \u0026gt; 0 \\newline 0 \u0026amp; i + 1 \u0026lt; j \\wedge (A_i = = A_j) \\wedge d p [i + 1] [j - 1] = 0 \\end{array} \\right. $$\n然后从最下面一行开始往上遍历：\nclass Solution: def getLongestPalindrome(self , A: str) -\u0026gt; int: result, dp = 0, [0] * len(A) for i in range(len(A) - 1, -1, -1): # 反过来遍历 for j in range(len(A) - 1, -1, -1): # 也是反过来 if i \u0026gt; j or A[i] != A[j]: dp[j] = 0 elif i == j: dp[j] = 1 elif (i + 1) == j: dp[j] = 2 elif dp[j-1] \u0026gt; 0: dp[j] = dp[j-1] + 2 else: dp[j] = 0 result = max(dp[j], result) if i == j: break # 前面都是 0，不用算了 return result 方法三：Manacher 算法 Manacher 算法其实并不复杂，可是就是看了好久……也不确定能不能讲清楚😂\nManacher 算法是中心扩散法的改进版：\n 通过添加无意义符合 \u0026quot;#\u0026quot; 把奇数和偶数的情况统一处理； 在遍历计算以 i 为中心的回文子串长度时，使用 i 之前的结果加速扩散。  第一点比较容易，我们可以分别考察奇数回文 \u0026quot;aba\u0026quot; -\u0026gt; \u0026quot;#a#b#a#\u0026quot; 和偶数回文 \u0026quot;abba\u0026quot; -\u0026gt; \u0026quot;#a#b#b#a#\u0026quot;，可以看到全部都变成了奇数回文，且若原回文长度为 n，新的回文长度就是 2n+1。\n第二点可能有点难，为此引入了“臂展”的概念，在遍历每一个元素时，记录下其（新）回文子串的臂展长度（恰好和原来的子串长度相等）。如果 i 在之前某个元素 j 的臂展内，则与 i 对称的元素 i_sym = 2 * j - i 也在 j 的臂展内。假设以 j 为中心的回文子串为 [left, right]，则：\n 如果 j 和 left 都不在 i_sym 的臂展长度以内，则由对称性，i 的臂展至少为 armlen[i_sym]，可以从 i - armlen[i_sym], i + armlen[i_sym] 开始扩散； 如果 j 在 i_sym 的臂展长度以内而 left 不在，则由对称性，i 的臂展至少为 armlen[i_sym]，可以从 i - armlen[i_sym], i + armlen[i_sym] 开始扩散； 如果 left 在 i_sym 的臂展长度以内而 j 不在，则由对称性，i 的臂展至少为 right - i，可以从 i - (right - i), i + (right - i) 开始扩散； 如果 j 和 left 都在 i_sym 的臂展长度以内，则由对称性，i 的臂展至少为 right - i，可以从 i - (right - i), i + (right - i) 开始扩散。  无论是哪一种情况，只要取 min_arm_len = min(arm_len[i_sym], right - i)，再从 i - min_arm_len, i + min_arm_len 开始扩展即可。\n最后就是 j 的选择，为了减少扩散匹配的次数（最大化 right - i），应选择使当前 right 达到最大的 j。\nclass Solution: def getLongestPalindrome(self , A: str) -\u0026gt; int: def expand(A, left, right): while 0 \u0026lt;= left and right \u0026lt; len(A) and A[left] == A[right]: left, right = left - 1, right + 1 return (right - left - 1 - 1) // 2 A = \u0026#34;#{}#\u0026#34;.format(\u0026#34;#\u0026#34;.join(A)) arm_len = [] result = 0 right = -1 j = -1 for i in range(len(A)): if right \u0026gt;= i: # 是回文串中心 i_sym = 2 * j - i # i 关于 j 的对称点 min_arm_len = min(arm_len[i_sym], right - i) cur_arm_len = expand(A, i - min_arm_len, i + min_arm_len) else: cur_arm_len = expand(A,i,i) arm_len.append(cur_arm_len) if i + cur_arm_len \u0026gt; right: j = i right = i + cur_arm_len result = max(result, cur_arm_len) return result BM74 数字字符串转化成IP地址 白想了半小时动态规划后被上了一课，其实根本不需要算法（因为数据量有限），用穷举就可以做😂\n其实就是选择 3 个小数点的位置，第一个小数点只能在 2,3,4 位，后两个只能在前一个的后 1,2,3 位上，只要写三层 for 循环即可：\nclass Solution: def restoreIpAddresses(self , s: str) -\u0026gt; List[str]: if len(s) \u0026lt; 4 or len(s) \u0026gt; 12 or (not s.isdigit()): return [] result = [] def valid(num): return (len(num) == 1) or (2 \u0026lt;= len(num) \u0026lt;= 3 and num[0] != \u0026#34;0\u0026#34; and int(num) \u0026lt; 256) for i in range(1, min(4, len(s) - 2)): if valid(s[:i]): for j in range(i + 1, min(i + 4,len(s) - 1)): if valid(s[i:j]): for k in range(j + 1, min(j + 4, len(s))): if valid(s[j:k]) and valid(s[k:]): result.append(s[:i] + \u0026#34;.\u0026#34; + s[i:j] + \u0026#34;.\u0026#34; + s[j:k] + \u0026#34;.\u0026#34; + s[k:]) return result BM75 编辑距离(一) 假设 $dp[i][j]$ 表示第一个字符串前 i 位与第二个字符串前 j 位的编辑距离，则：\n 如果 i=0 或 j=0，说明其中一个（子串）是空字符串，编辑距离等于另一个字符串（子串）的长度； 否则，如果 s1[i]=s2[j]，则 $dp[i][j]=dp[i-1][j-1]$； 最后，如果 s1[i]!=s2[j]，由编辑距离的定义，假设要把子串 s1[0:i] 变成 s2[0:j]，s1[0:i] 的最后一位必然会受到影响，可以想像一下按照最优的编辑过程把两个字符串进行对齐（不唯一）：  因此以下的情况必然会出现一种，而且与对其他位置的编辑相互独立：\n s2[j] 位于最右，没有匹配到任何字母，此时把 s2[j] 添加到最后一位，从而 s1[i+1]=s2[j]，对应的编辑距离为 $dp[i][j-1]+1$； s1[i] 位于最右，没有匹配到任何字母，此时删除 s1[i]，编辑距离为 $dp[i-1][j]+1$； s1[i] 与 s2[j] 配对成功，此时替换 s1[i] 为 s2[j]，编辑距离为 $dp[i-1][j-1]+1$。  可以填表加深理解：\nclass Solution: def editDistance(self , str1: str, str2: str) -\u0026gt; int: dp = list(range(len(str2) + 1)) for i in range(len(str1)): tmp = dp.copy() # dp 在第 i-1 行的结果 dp[0] = i + 1 for j in range(len(str2)): if str1[i] == str2[j]: dp[j + 1] = tmp[j] else: dp[j + 1] = 1 + min(tmp[j + 1], tmp[j], dp[j]) return dp[-1] BM76 正则表达式匹配 嗯嗯，就是使用正则表达式进行匹配嘛：\nclass Solution: def match(self , s: str, p: str) -\u0026gt; bool: from re import search return bool(search(r\u0026#34;^\u0026#34; + p + r\u0026#34;$\u0026#34;, s)) 看上去不难，但动手就会发现并不好写😂因为 * 可以匹配 0 次或无穷次，这就意味着 ba*s 可以匹配 bas, baas, baaas, ... 也可以直接丢弃，即匹配 bs, bsa, ...，除此之外还要处理 .*、a*a 这些棘手的情形……\n一般的正则表达式匹配实现非常复杂，不能使用动态规划1，所以还是直接抄题解吧😂\n假设 $dp[i][j]$ 表示字符串 s 前 i 个字符是否匹配模式 p 前 j 个字符，这里匹配的意思是配对，即字符串完美符合整个模式，则：\n 如果 $p[j]$ 是小写字母（或 .），显然：  $$ d p [i] [j] = \\left\\{ \\begin{array}{ll} d p [i - 1] [j - 1] \u0026amp; s [i] = p [j]\\newline \\text{False} \u0026amp; s [i] \\neq p [j] \\end{array} \\right. $$\n 如果 $p[j]$ 是 *，则意味着 $p[j-1]$ 可以出现 0 次或任意次，此时把 $p[j-1]p[j]$ 看成一个整体。如果 $s[i]=p[j-1]$（或者 $p[j-1]$ 是 .），和上面类似，说明模式 $p[j-1]p[j]$ 匹配到了 $s[i]$，这时有三种可能：   前面依然有模式 $p[j-1]p[j]$ 可以匹配到的字符，此时结果为 $dp[i-1][j]$； 前面没有模式 $p[j-1]p[j]$ 可以匹配到的字符，对应的结果为 $dp[i-1][j-2]$； 或者并不需要进行匹配（即 $p[j-1]$ 出现 0 次），对应的结果是 $dp[i][j-2]$。  如果 $s[i] \\neq p[j-1]$，显然唯一的可能是 $p[j-1]$ 出现 0 次，对应的结果是 $dp[i-2][j]$。\n如果再仔细想想就会发现，上面第 2 种情况其实已经被第 1 种情况覆盖（匹配 0 次也是符合模式），因此状态转移方程为：\n$$ d p [i] [j] = \\left\\{ \\begin{array}{ll} d p [i - 1] [j] \\hspace{0.5em} \\text{or} \\hspace{0.5em} d p [i] [j - 2] \u0026amp; s [i] = p [j - 1]\\newline d p [i] [j - 2] \u0026amp; s [i] \\neq p [j - 1] \\end{array} \\right. $$\n最后还要处理好初始化的情形，使用空字符串对模式进行匹配：\n 空字符串匹配空模式，因此 $dp[0][0] = \\text{True}$； 如果 p[j]==\u0026quot;*\u0026quot;，就有 $dp[0][j] = dp[0][j-2]$，否则 $dp[0][j]=\\text{False}$。  class Solution: def match(self , s: str, p: str) -\u0026gt; bool: m, n = len(s), len(p) dp = [True] + [False] * n for j in range(n): dp[j + 1] = dp[j - 1] if p[j] == \u0026#34;*\u0026#34; else False for i in range(m): tmp = dp.copy() # dp 在 i - 1 行的结果 dp[0] = False for j in range(n): if not p[j] == \u0026#34;*\u0026#34;: if p[j] == \u0026#34;.\u0026#34; or s[i] == p[j]: dp[j + 1] = tmp[j] #dp[i][j]=dp[i-1][j-1] else: dp[j + 1] = False else: if p[j-1] == \u0026#34;.\u0026#34; or s[i] == p[j - 1]: dp[j + 1] |= dp[j - 1] #dp[i][j]=dp[i-1][j] or dp[i][j-2] else: dp[j + 1] = dp[j - 1] return dp[n] BM77 最长的括号子串 方法一：栈 理清逻辑之后其实不难写：\n 使用栈记录左括号下标； 遍历字符串，遇到左括号入栈； 如果遇到右括号，且栈不为空，则弹出栈顶元素，如果此时栈仍不为空，子串的长度为 i - 此时的栈顶坐标； 如果上一步弹出后栈为空会无法计算子串长度，因此还需要记录入栈前最后一个右括号的下标 start。如果栈为空且字符为右括号，更新 start 的值。  class Solution: def longestValidParentheses(self , s: str) -\u0026gt; int: stack, start, result = [], -1, 0 for i in range(len(s)): if s[i] == \u0026#34;(\u0026#34;: stack.append(i) else: if stack: stack.pop() if stack: result = max(result, i - stack[-1]) else: result = max(result, i - start) else: start = i return result 方法二：动态规划 有种为 DP 而 DP 的感觉😂 $dp[i]$ 记录的是以 s[i] 作为结尾的最长有效子串长度，显然：\n 如果 s[i] 是左括号，因为没有有效子串以左括号结尾，$dp[i]=0$； 如果 s[i] 是右括号，需要分情况讨论： 如果 s[i-1] 是左括号，则显然 $dp[i] = dp[i-2] + 2$； 如果 s[i-1] 是右括号，就需要检查以 s[i-1] 为结尾的最长有效子串前面的元素 s[i-1-dp[i-1]] 是不是左括号，如果是就有 $dp[i] = dp[i-1] + 1 + dp[i-2-dp[i-1]]$，否则 $dp[i] = 0$。  class Solution: def longestValidParentheses(self , s: str) -\u0026gt; int: dp, result = [0] * (len(s) + 1), 0 for i in range(len(s)): if i \u0026gt; 0 and s[i - 1: i + 1] == \u0026#34;()\u0026#34;: dp[i + 1] = dp[i - 1] + 2 result = max(result, dp[i + 1]) elif i \u0026gt; 0 and s[i - 1: i + 1] == \u0026#34;))\u0026#34;: if i - 1 - dp[i] \u0026gt;= 0 and s[i - 1 - dp[i]] == \u0026#34;(\u0026#34;: dp[i + 1] = dp[i] + 2 + dp[i - 1 - dp[i]] result = max(result, dp[i + 1]) return result 方法三：正向逆向结合 从题解学到的除了节约空间外可能没什么用的做题技巧😂\n先正向扫描一遍，再反向扫描一遍，正向扫描的时候：\n 如果遇到左括号，left+1； 如果遇到右括号，right+1； 如果 left = right，记录 left+right（对应方法一栈空的情形）； 如果 left \u0026lt; right，left, right 清零。  之所以要反向扫描是因为这种方法不能处理最后栈里还有左括号的情形。\nclass Solution: def longestValidParentheses(self , s: str) -\u0026gt; int: left, right, result = 0, 0, 0 for i in s: if i == \u0026#34;(\u0026#34;: left += 1 else: right += 1 if left == right: result = max(result, left * 2) elif left \u0026lt; right: left, right = 0, 0 left, right = 0, 0 for i in reversed(s): if i == \u0026#34;)\u0026#34;: right += 1 else: left += 1 if left == right: result = max(result, left * 2) elif left \u0026gt; right: left, right = 0, 0 return result BM78 打家劫舍（一） 显而易见，$dp[i]=\\max(dp[i-1], nums[i]+dp[i-2])$。\nclass Solution: def rob(self , nums: List[int]) -\u0026gt; int: dp_prev, dp = 0, 0 for i in nums: dp_prev, dp = dp, max(dp, i + dp_prev) return dp BM79 打家劫舍（二） 和上一题的唯一区别是偷了第一家就不能偷最后一家，因此分两种情况处理：分别计算 [0, n-2] 与 [1, n-1] 的最大值：\nclass Solution: def rob(self , nums: List[int]) -\u0026gt; int: def robb(nums): dp_prev, dp = 0, 0 for i in nums: dp_prev, dp = dp, max(dp, i + dp_prev) return dp return max(robb(nums[:-1]), robb(nums[1:])) BM80 买卖股票的最好时机（一） 低买高卖，遍历每一天，计算在这一天之前的最低价买入后卖出的利润，求最大值即可。\nclass Solution: def maxProfit(self , prices: List[int]) -\u0026gt; int: lowest, profit = prices[0], 0 for i in prices: lowest = min(lowest, i) # 第 i 天前的最低价格 profit = max(profit, i-lowest) # 在第 i 天前买入后卖出的最大利润 return profit BM81 买卖股票的最好时机（二） 依然是低买高卖，累计所有“上坡”，打死不写 DP😂\nclass Solution: def maxProfit(self , prices: List[int]) -\u0026gt; int: return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, len(prices))) BM82 买卖股票的最好时机（三） 依然是逃课😂\n回顾 BM80 的做法，我们实际上以线性时间复杂度求出了在第 i 天前以最低价买入并在第 i 天之前（含）卖出的最大利润，可以把它用一个数组 dp1 记录下来。\n只要把程序倒过来，就可以以线性时间复杂度求出在第 i 天后以最高价卖出并在第 i 天之后（含）买入的最大利润，也可以使用一个数组 dp2 记录下来。因为只能买卖两次，最后返回 max(dp1+dp2) 即可。\nclass Solution: def maxProfit(self , prices: List[int]) -\u0026gt; int: lowest, profit, dp, result = prices[0], 0, [], 0 for i in prices: lowest = min(lowest, i) # 第 i 天前的最低价格 profit = max(profit, i - lowest) # 在第 i 天前买入后卖出的最大利润 dp.append(profit) highest, profit = prices[-1], 0 for j in reversed(prices): highest = max(highest, j) profit = max(profit, highest - j) result = max(result, dp.pop() + profit) return result 当然这种逃课做法不能推广到更一般的情形。标准的题解需要切分为 5 个状态：\n 未进行任何操作，此时现金利润恒为 0：$start[i] = dp[i][0] = 0$； 在第 i 天结束前，只进行一次买操作，此时现金利润为负：$buy_1[i] = dp[i][1] = \\max(buy_1[i - 1], start[i] - prices[i]) = \\max(buy_1[i - 1], - prices[i])$； 在第 i 天结束前，进行了一次买和卖操作：$sell_1[i] = dp[i][2] = \\max(sell_1[i - 1], prices[i] + buy_1[i])$； 在第 i 天结束前，完成了一笔交易和另外一次买操作：$buy_2[i] = dp[i][3] = \\max(buy_2[i-1], sell_1[i] - prices[i])$； 在第 i 天结束前，完成了两笔交易：$sell_2[i] = dp[i][4] = \\max(sell_2[i-1], buy_2[i] + prices[i])$。  最后返回 $sell_2$ 最后一次的结果。此时就能使用动态规划求解了：\nclass Solution: def maxProfit(self , prices: List[int]) -\u0026gt; int: buy1, sell1, buy2, sell2 = -prices[0], 0, -prices[0], 0 for i in prices: buy1 = max(buy1, -i) sell1 = max(sell1, i + buy1) buy2 = max(buy2, sell1 - i) sell2 = max(sell2, buy2 + i) return sell2   正则表达式的实现主要分为 DFA 和 NFA，DFA 记录下所有可能的匹配，然后遍历字符串进行检查；NFA 则是尝试一种可能的模式进行匹配，匹配失败后进行回溯。显然正则表达式的部分语法是不适合 DFA 的，目前绝大部分实现都是 NFA，但是 DFA 执行更快。有兴趣可以阅读《精通正则表达式》或者编译原理的教材。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-04-10T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-06/","title":"做题笔记06：动态规划"},{"content":"BM50 两数之和 LeetCode 第一题，梦开始的地方，使用字典作为缓存：\nclass Solution: def twoSum(self , numbers: List[int], target: int) -\u0026gt; List[int]: cache = {} for i in range(len(numbers)): if target - numbers[i] in cache: return [cache[target - numbers[i]] + 1, i + 1] else: cache[numbers[i]] = i return [] 不过按照题目的要求，大概是希望把数组排序后使用双指针（以时间换空间）：\nclass Solution: def twoSum(self , numbers: List[int], target: int) -\u0026gt; List[int]: lo, hi, numbers = 0, len(numbers) - 1, sorted((num, index) for index, num in enumerate(numbers)) while lo \u0026lt;= hi: total = numbers[lo][0] + numbers[hi][0] if total \u0026lt; target: lo = lo + 1 elif total \u0026gt; target: hi = hi - 1 else: return sorted([numbers[lo][1] + 1, numbers[hi][1] + 1]) return [] BM51 数组中出现次数超过一半的数字 这是剑指 Offer 面试题 39，方法非常多，比如使用字典保存每个数的出现次数，又比如使用类似快速排序的分治法，另外注意到数组中出现超过一半的数字，一定是数组的中位数，还可以使用二叉堆、红黑树等高级数据结构，不过都无法满足题目时间复杂度 O(n)，空间复杂度 O(1) 的要求。\n有没有办法再简化一下呢，比如不使用字典？假如只保存一个数和对应的出现次数，仍然有办法找出出现次数超过一半的数吗？其实也是可以的：\n 记录下当前的数字，出现次数设置为 1； 如果下一个数字相等，出现次数+1，否则 -1； 出现次数为 0 时，更换下一个数字。  class Solution: def MoreThanHalfNum_Solution(self , numbers: List[int]) -\u0026gt; int: num, times = None, 0 for i in numbers: if not times: num, times = i, 1 elif i == num: times = times + 1 else: times = times - 1 return num 理解这个算法比较快的方法大概是尝试构造一个反例，为了让出现次数超过一半的数字 num 且不被记录下来，只能是这种形式 [a, num, b, num, c, num, ..., y, num(, z)]，但与 num 出现次数超过一半矛盾。\nBM52 数组中只出现一次的两个数字 需要使用异或的技巧：\n 0 xor a = a, a xor a = 0 a xor b = b xor a a xor b = c, c xor a = b, c xor b = a  可以看到异或不同数的时候像做加法，异或相同数像在做减法。如果数组中只有一个数字只出现一次，只要把数组全部数异或一次就能得到结果。\n本题中因为有两个数 a,b，把全部数异或只能得到 a xor b。如果能把所有数分成两组，让 a,b 各自和组内其他数进行异或，问题就解决了。注意到异或后为 1 的位是两个数不同的位，不难写出代码：\nclass Solution: def FindNumsAppearOnce(self , array: List[int]) -\u0026gt; List[int]: # 1. 计算所有数的异或和 from functools import reduce axorb = reduce(lambda a,b: a^b, array) # 2. 寻找从最右边开始第一位为1对应的数字，如 6-\u0026gt;110-\u0026gt;10-\u0026gt;2，这里使用了位运算技巧 lowbit = axorb \u0026amp; -axorb # 3. 分组再次求异或和 a, b = 0, 0 for num in array: if num \u0026amp; lowbit: # 对应位为 1 a = a ^ num else: # 对应位为 0 b = b ^ num return sorted([a,b]) BM53 缺失的第一个正整数 很自然想到使用字典，然而题目不允许，怎么办呢？能不能直接在数组中记录某个正数是否出现的信息？于是学会了新技巧——原地哈希：\n 首先把所有负数和 0 设置为 n+1； 顺序遍历数组，如果 1-n 中某个数字 k 出现过，就把数组第 k 个元素设置为负数（记得要-1，k也有可能是负数，记得取绝对值）； 顺序遍历数组，第一个正数对应的索引就是所求的数（记得要+1）； 如果没找到正数，说明数组中的数恰好为 1-n，返回 n+1。  class Solution: def minNumberDisappeared(self , nums: List[int]) -\u0026gt; int: n = len(nums) # 1. 把所有负数和 0 替换成 n+1，此时数列全是正数 for i in range(n): if nums[i] \u0026lt;= 0: nums[i] = n + 1 # 2. 把出现过的数作为下标对应的数变成负数，此时数组的数为 [1, ...] 对应的下标则是 [0, n-1] for i in range(n): if abs(nums[i]) \u0026lt;= n: nums[abs(nums[i]) - 1] = - abs(nums[abs(nums[i]) - 1]) # 3. 找到第一个正数对应的数组下标 for i in range(n): if nums[i] \u0026gt; 0: return i + 1 return n + 1 BM54 三数之和 既然是三个数，遍历所有二元组就需要 O(n^2)，自然会想到先排个序再处理。只要写出两数之和的双指针版本，再加一个指针就是三数之和了，同理可以推广至 nSum，只需要注意跳转的时候要跳到下一个不同的数。\nclass Solution: def threeSum(self , nums: List[int]) -\u0026gt; List[List[int]]: nums, n = sorted(nums), len(nums) if n \u0026lt; 3: return [] low, mid, high = 0, 1, n-1 result = [] while low \u0026lt; n-2: while mid \u0026lt; high: if nums[mid] + nums[high] \u0026lt; 0 - nums[low]: # mid 跳到下一个数，0 可以换成 target tmp = nums[mid] while nums[mid] == tmp and mid \u0026lt; high: mid = mid + 1 elif nums[mid] + nums[high] \u0026gt; 0 - nums[low]: # high 跳到上一个数 tmp = nums[high] while nums[high] == tmp and mid \u0026lt; high: high = high - 1 else: result.append([nums[low], nums[mid], nums[high]]) tmp = nums[mid] while nums[mid] == tmp and mid \u0026lt; high: mid = mid + 1 high = n - 1 tmp = nums[low] # low 跳到下一个数 while nums[low] == tmp and low \u0026lt; n-2: low = low + 1 mid, high = low + 1, n - 1 return result BM55 没有重复项数字的全排列 久违的轻松时刻～\nclass Solution: def permute(self , nums: List[int]) -\u0026gt; List[List[int]]: from itertools import permutations return list(permutations(sorted(nums))) 其实方法非常多，Donald E. Knuth 在 The Art of Computer Programming 中用 一整册书 的篇幅讨论了各种排列和元组的生成方法。在文档里可以看到 itertools.permutations 的 实现原理，不过 并不好懂，似乎是使用了 Knuth 书中一种基于置换的算法。\n就算只考虑字典序遍历，相对简单的算法也有很多，比如注意到 1 2 3 的所有排列为：\n1 23 1 32 2 13 2 31 3 12 3 21 即可分解为子问题，不难写出递归代码：\nclass Solution: def permute(self , nums: List[int]) -\u0026gt; List[List[int]]: def perm(nums): if len(nums) \u0026lt;= 1: yield nums else: for i in range(len(nums)): for j in perm(nums[:i] + nums[i+1:]): # Slice 没有边界问题 yield [nums[i]] + j return list(perm(sorted(nums))) 从另一个角度看，其实是树的遍历问题（层序），可以使用一个队列来存储上一层的结果：\nclass Solution: def permute(self , nums: List[int]) -\u0026gt; List[List[int]]: from collections import deque queue = deque([[[], sorted(nums)]]) while queue[0][1]: for _ in range(len(queue)): prefix, suffix = queue.popleft() for i in range(len(suffix)): queue.append([prefix + [suffix[i]], suffix[:i] + suffix[i+1:]]) return [i[0] for i in queue] BM56 有重复项数字的全排列 从生成器的角度思考：如果当前的排列为 (1,2,4,5,3)，下一个排列是什么呢？回顾中序遍历的过程，首先要从后往前找到第一个有右子结点的结点，然后沿着这条路径往左下走，转换成数学的语言：\n 从最后一个数字开始往回走，找到第一个下降的数字，作为主元。（为什么？因为主元在“进位”前，后面的数必然达到最大值，故一定是非增序列，结合树的图形会更好理解。）这里 3\u0026lt;5，5\u0026gt;4，所以主元是4； 主元切换到下一个数字，即 4-\u0026gt;5，此时前三个数字为 {1,2,5}； 把剩下的数字由小到大排序，即 {4,3} -\u0026gt; {3,4}，再接到后面，即下一个排列为 {1,2,5,3,4}。其实只需交换上面两个数字后，把后半截反过来（因为交换不改变大小次序）。  class Solution: def permuteUnique(self , nums: List[int]) -\u0026gt; List[List[int]]: nums, n, res = sorted(nums), len(nums), [] res.append(nums.copy()) while True: pivot = n - 1 while pivot \u0026gt; 0 and nums[pivot - 1] \u0026gt;= nums[pivot]: pivot = pivot - 1 pivot = pivot - 1 # 循环在 pivot - 1 是主元时停止 if pivot \u0026lt; 0: # 到达最后一个排列，退出循环 break else: exchange = n - 1 # 寻找第一个大于 pivot 的元素，此时后面元素非增 while nums[exchange] \u0026lt;= nums[pivot]: exchange = exchange - 1 nums[pivot], nums[exchange] = nums[exchange], nums[pivot] nums[pivot+1:] = nums[n-1:pivot:-1] # 把后半截反过来 res.append(nums.copy()) return res 这个算法历史悠久，据 Knuth 考证似乎最早出现于 14 世纪。还有很多其他的算法，比如 Knuth 的 Algorithm L ……\nBM57 岛屿数量 按某种次序（比如从左到右从上到下）访问所有格子：\n 如果格子里是 '1'，计数器加1，格子元素设成 '0'； 此时访问格子上下左右，如果遇到 '1'，设置成 '0'，并且继续访问该格子上下左右； 如果格子是 '0' 就跳过； 最后返回计数器的结果。  class Solution: def solve(self , grid: List[List[str]]) -\u0026gt; int: if not grid: return 0 row, col = len(grid), len(grid[0]) count, queue = 0, [] inArea = lambda e: (e[0] \u0026gt;= 0 and e[0] \u0026lt; row and e[1] \u0026gt;= 0 and e[1] \u0026lt; col) for i in range(row): for j in range(col): if grid[i][j] == \u0026#39;1\u0026#39;: count = count + 1 grid[i][j] = \u0026#39;0\u0026#39; queue.extend(e for e in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)] if inArea(e)) while queue: e_i, e_j = queue.pop() if grid[e_i][e_j] == \u0026#39;1\u0026#39;: grid[e_i][e_j] = \u0026#39;0\u0026#39; queue.extend(e for e in [(e_i - 1, e_j), (e_i + 1, e_j), (e_i, e_j - 1), (e_i, e_j + 1)] if inArea(e)) return count BM58 字符串的排列 和 BM56 基本一致，只要稍微改动一下……感谢 Python🙏🙏\nclass Solution: def Permutation(self , string: str) -\u0026gt; List[str]: alps, n, res = sorted(string), len(string), [] res.append(\u0026#39;\u0026#39;.join(alps)) while True: pivot = n - 1 while pivot \u0026gt; 0 and alps[pivot - 1] \u0026gt;= alps[pivot]: pivot = pivot - 1 pivot = pivot - 1 # 循环在 pivot - 1 是主元时停止 if pivot \u0026lt; 0: # 到达最后一个排列，退出循环 break else: exchange = n - 1 # 寻找第一个大于 pivot 的元素，此时后面元素非增 while alps[exchange] \u0026lt;= alps[pivot]: exchange = exchange - 1 alps[pivot], alps[exchange] = alps[exchange], alps[pivot] alps[pivot+1:] = alps[n-1:pivot:-1] # 把后半截反过来 res.append(\u0026#39;\u0026#39;.join(alps)) return res BM59 N皇后问题 偷个懒，注意到如果把全排列第 i 个元素 j 的 (i,j) 看成坐标，显然是不同行不同列的，只需要检查是否在相同的对角线上，即检查有没有相同的 i+j 和 i-j。虽然过了，但时间很慢（O(n * n!)）……\nclass Solution: def Nqueen(self , n: int) -\u0026gt; int: from itertools import permutations count = 0 for e in permutations(range(n)): left, right, reg = {}, {}, 0 for i,j in enumerate(e): if (not i+j in left) and (not i-j in right): left[i+j], right[i-j], reg = True, True, reg + 1 else: break if reg == n: count = count + 1 return count 比较著名的方法是使用 位运算+递归：\nclass Solution: def Nqueen(self , n: int) -\u0026gt; int: count = 0 def DFS(row, shu, pie, na): # 横竖撇捺 nonlocal count available = ((1 \u0026lt;\u0026lt; n) - 1) \u0026amp; ~(shu | pie | na) # 截断 \u0026amp; 取反得到可用位 while available: p = available \u0026amp; -available # lowbit 为 1 的最低位 available ^= p # 把 lowbit 位置 0 if row == n - 1: count += 1 else: DFS(row + 1, shu | p, (pie | p) \u0026gt;\u0026gt; 1, (na | p) \u0026lt;\u0026lt; 1) DFS(0, 0, 0, 0) return count BM60 括号生成 也是树的遍历。\nclass Solution: def generateParenthesis(self , n: int) -\u0026gt; List[str]: from collections import deque queue = deque([(\u0026#39;\u0026#39;, 2 * n, 0, 0)]) # (前缀, 剩下的字符数，左括号数, 右括号数) while queue[0][1] \u0026gt; 0: prefix, char_left, count_left, count_right = queue.popleft() if count_left \u0026lt; n: queue.append((prefix + \u0026#39;(\u0026#39;, char_left - 1, count_left + 1, count_right)) if count_right \u0026lt; count_left: queue.append((prefix + \u0026#39;)\u0026#39;, char_left - 1, count_left, count_right + 1)) return [i[0] for i in queue] BM61 矩阵最长递增路径 最容易想到的是递归，dfs(x, y) = max(dfs(i, j) for i, j in jobs) + 1：\nclass Solution: def solve(self , matrix: List[List[int]]) -\u0026gt; int: row, col = len(matrix), len(matrix[0]) lengths, dirs = [[0] * row for _ in range(col)], [(-1, 0), (0, 1), (1, 0), (0, -1)] inArea = lambda x,y: (0 \u0026lt;= x \u0026lt; row and 0 \u0026lt;= y \u0026lt; col) def DFS(x,y): nonlocal lengths if lengths[x][y] == 0: jobs = [(x + i, y + j) for i, j in dirs if inArea(x + i, y + j) and matrix[x + i][y + j] \u0026gt; matrix[x][y] ] lengths[x][y] = (max(DFS(i, j) for i, j in jobs) + 1) if jobs else 1 return lengths[x][y] result = 0 for i in range(row): for j in range(col): result = max(result, DFS(i, j)) return result 又踩到了 Python 一个坑，debug 了足足一个小时：\n\u0026gt;\u0026gt;\u0026gt; [[0]*5]*3 [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] \u0026gt;\u0026gt;\u0026gt; x = [[0]*5]*3 \u0026gt;\u0026gt;\u0026gt; x[0][1] = 1 \u0026gt;\u0026gt;\u0026gt; x [[0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 0, 0]] 也可以看成动态规划或者树的遍历，从最大的数开始一步一步往四周倒着走：\nclass Solution: def solve(self , matrix: List[List[int]]) -\u0026gt; int: row, col = len(matrix), len(matrix[0]) lengths, dirs = [[0] * row for _ in range(col)], [(-1, 0), (0, 1), (1, 0), (0, -1)] inArea = lambda x,y: (0 \u0026lt;= x \u0026lt; row and 0 \u0026lt;= y \u0026lt; col) from collections import deque queue = deque() for x in range(row): for y in range(col): for i, j in dirs: if inArea(x + i, y + j) and matrix[x + i][y + j] \u0026gt; matrix[x][y]: lengths[x][y] += 1 if lengths[x][y] == 0: # 四周没有比它大的格子 queue.append((x, y)) result = 0 while queue: result += 1 for _ in range(len(queue)): x, y = queue.popleft() for i,j in dirs: if inArea(x + i, y + j) and matrix[x + i][y + j] \u0026lt; matrix[x][y]: lengths[x + i][y + j] -= 1 if lengths[x + i][y + j] == 0: # 次大的格子 queue.append((x + i, y + j)) return result 不写 += -= 过不了测试，奇怪的是差距应该并不明显😂\n","date":"2022-04-07T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-05/","title":"做题笔记05：哈希/递归/回溯"},{"content":"BM42 用两个栈实现队列 栈相当于把队列的一部分元素以相反的方向存储，再使用一个栈把所有元素的顺序反过来就是队列。等队列栈空了，就再做一次相同的事情。\nclass Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): self.stack1.append(node) def pop(self): if not self.stack1 and not self.stack2: # 队列为空 return None if not self.stack2: # 栈2为空，把栈1所有元素入栈 while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() BM43 包含min函数的栈 空间换时间，再准备一个栈缓存当前的min就好：\nclass Solution: def __init__(self): self.stack = [] self.stack_min = [] def push(self, node): self.stack.append(node) if not self.stack_min: self.stack_min.append(node) else: self.stack_min.append(min(node, self.stack_min[-1])) def pop(self): self.stack_min.pop() return self.stack.pop() def top(self): return self.stack[-1] def min(self): return self.stack_min[-1] BM44 有效括号序列 使用一个栈存储已经出现的左括号：\nclass Solution: def isValid(self , s: str) -\u0026gt; bool: stack, pairs = [], {\u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;} for char in s: if char in \u0026#39;([{\u0026#39;: stack.append(char) elif char in \u0026#39;)]}\u0026#39;: if not stack or pairs[char] != stack[-1]: return False else: stack.pop() return not stack BM45 滑动窗口的最大值 又是一道难题，首先想到的自然是优先队列，但是时间复杂度 O(nlog(n)) 不能满足要求，只能跑去看题解……\n题解的原理其实很简单：希望在下一个滑动窗口中利用前面滑动窗口的最大值信息，即维护一个窗口大小的双向队列。具体而言，因为当前窗口最大值前面的元素，对下一个窗口的最大值毫无影响，因此不需要存储，队列里存储的值即为 [当前窗口的最大值, 前一个数到滑动窗口末的最大值, 前一个数到滑动窗口末的最大值, ...]。\n如何形成这样的队列？只要每个新元素在入列之前，把栈中比它小的元素从右边出列即可。窗口开始滑动时，如果队列第一个元素滑出窗口就出列，然后把当前元素入列。\n这个思路有点像动态规划，也有点像二叉搜索树的前序遍历……\nclass Solution: def maxInWindows(self , num: List[int], size: int) -\u0026gt; List[int]: from collections import deque if not num or size == 0 or size \u0026gt; len(num): return [] window = deque([]) for i in range(size): # 得到第一个窗口的状态 while window and num[window[-1]] \u0026lt; num[i]: window.pop() window.append(i) result = [num[window[0]]] for i in range(size, len(num)): if window[0] \u0026lt;= i - size: window.popleft() while window and num[window[-1]] \u0026lt; num[i]: window.pop() window.append(i) result.append(num[window[0]]) return result BM46 最小的K个数 最简单的一题（x\nclass Solution: def GetLeastNumbers_Solution(self , input: List[int], k: int) -\u0026gt; List[int]: import heapq return heapq.nsmallest(k, input) 其实和 sorted(input)[:k] 没什么区别😂\nBM47 寻找第K大 上面搞错了，这才是最简单的一题（x\nclass Solution: def findKth(self , a: List[int], n: int, K: int) -\u0026gt; int: return sorted(a)[-K] 试着写了一下题解快速排序的代码，结果第8个测试用例超出限制了……所以不要浪费生命，less is more！\nBM48 数据流中的中位数 依然是考察堆排序。准备一个大顶堆存放小元素，一个小顶堆存放大元素，并且保持大顶堆所有元素都小于小顶堆所有元素。显然中位数必然在这两个队的队顶元素之间。添加元素时，可以先加入大堆，再从大堆取出最大值加入小堆（为了维持相对大小关系），也可以反过来。\n注意 Python 里没有最大堆，所以放入和取出最大堆元素的时候都加了负号。\nimport heapq class Solution: def __init__(self): self.max_h, self.min_h = [], [] def Insert(self, num): if len(self.min_h) == len(self.max_h): # 两堆相等，优先加入小堆 heapq.heappush(self.min_h, -heapq.heappushpop(self.max_h, -num)) else: # 加入大堆 heapq.heappush(self.max_h, -heapq.heappushpop(self.min_h, num)) def GetMedian(self): if len(self.min_h) == len(self.max_h): return (self.min_h[0] - self.max_h[0]) / 2.0 else: return self.min_h[0] BM49 表达式求值 刷新了中等题的难度下限（x\nclass Solution: def solve(self , s: str) -\u0026gt; int: return eval(s) 还是认真做一下吧，题解的方法像在写有限状态机：\n 准备两个栈，一个放操作数，一个放运算符。为了兼顾第一个字符为 +- 的情形，操作数的栈中先放个 0； 顺序扫描字符串，如果是数字，继续读取，直到第一个不是数字的字符为止，把数字压入操作数栈； 如果是左括号，压入运算符栈； 如果是右括号，对操作数和运算符进行出栈计算，然后把结果压入操作数栈，这个动作一直持续到操作数栈栈顶元素为左括号为止，左括号出栈； 如果是操作符，则和前一个操作符的运算优先级进行比较，如果小于等于前一个操作符的优先级，则出栈进行计算，一直持续到前一个操作符优先级小于当前操作符优先级为止，或者运算符栈为空； 操作符还有另一种情况：(+,+- 这种两个运算符相连的情形（前一个可以是括号），此时为了处理方便，需要给操作数栈插入一个 0； 对于其他的情形（比如空格），直接跳过，遍历完成后计算并返回结果。  class Solution: def solve(self , s: str) -\u0026gt; int: nums, ops, i, s_len, last_is_ops = [], [], 0, len(s), True prior, allnum = {\u0026#39;+\u0026#39;:1, \u0026#39;-\u0026#39;: 1, \u0026#39;*\u0026#39;: 2}, set(str(i) for i in range(10)) func = {\u0026#39;+\u0026#39;: lambda x,y: x+y, \u0026#39;-\u0026#39;: lambda x,y: y-x, \u0026#39;*\u0026#39;: lambda x,y: x*y} while i \u0026lt; s_len: if s[i] in allnum: # 可能有多位数字 num = 0 while i \u0026lt; s_len and s[i] in allnum: num, i = num * 10 + int(s[i]), i + 1 nums.append(num) i, last_is_ops = i - 1, False elif s[i] == \u0026#39;(\u0026#39;: # 出现左括号 ops.append(s[i]) last_is_ops = True elif s[i] == \u0026#39;)\u0026#39;: # 出现右括号，出栈并计算结果，last_is_ops==False 保持不变 while ops and ops[-1] != \u0026#39;(\u0026#39;: nums.append(func[ops.pop()](nums.pop(), nums.pop())) ops.pop() elif s[i] in prior: # 出现运算符，如果优先级\u0026lt;=上一个，对上一个运算符进行计算 if last_is_ops: # 处理 (+, +- 这种特殊情形 nums.append(0) while ops and ops[-1] != \u0026#39;(\u0026#39; and prior[ops[-1]] \u0026gt;= prior[s[i]]: nums.append(func[ops.pop()](nums.pop(), nums.pop())) ops.append(s[i]) last_is_ops = True i = i + 1 while ops: # 把剩余的计算完，一般只剩下 a+b*c,a-b*c nums.append(func[ops.pop()](nums.pop(), nums.pop())) return nums[-1] 写了 30 行代码，感觉像过了半个世纪😂\n","date":"2022-04-06T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-04/","title":"做题笔记04：堆/栈/队列"},{"content":"BM23 二叉树的前序遍历 继续记模板！\nclass Solution: def preorderTraversal(self , root: TreeNode) -\u0026gt; List[int]: result = [] self.preOrder(root, result) return result def preOrder(self, root, result): if not root: return None else: result.append(root.val) self.preOrder(root.left, result) self.preOrder(root.right, result) BM24 二叉树的中序遍历 直接使用递归超出系统限制了，虽然可以使用作弊器：\nimport sys sys.setrecursionlimit(100000) 但还是学习一下非递归的写法吧：\nclass Solution: def inorderTraversal(self , root: TreeNode) -\u0026gt; List[int]: result = [] self.inOrder(root, result) return result def preOrder(self, root, result): # 前序，“根左右” if not root: return None stack = [root] while stack: top = stack.pop() result.append(top.val) if top.right: # 优先加入右结点，因为是栈，左结点会先出来 stack.append(top.right) if top.left: stack.append(top.left) def inOrder(self, root, result): # 中序，“左根右” if not root: return None stack = [] while root: # 左 stack.append(root) root = root.left while stack: # root 是当前访问的结点 node = stack.pop() # 根 result.append(node.val) root = node.right # 右 while root: stack.append(root) root = root.left BM25 二叉树的后序遍历 后序的非递归版本并不好写，最简单的做法似乎是把前序遍历反转一下：\nclass Solution: def postorderTraversal(self , root: TreeNode) -\u0026gt; List[int]: result = [] self.postOrder(root, result) return result[::-1] def postOrder(self, root, result): # 后序1，前序“根右左”，反转在上面 if not root: return None stack = [root] while stack: top = stack.pop() result.append(top.val) if top.left: stack.append(top.left) if top.right: stack.append(top.right) def postOrder2(self, root, result): # 后序2，“左右根” if not root: return None stack = [root] while stack: top = stack.pop() # 根 if top: stack.append(top) stack.append(None) # 标记此结点已经访问过 if top.right: # 右 stack.append(top.right) if top.left: # 左 stack.append(top.left) else: result.append(stack.pop().val) BM26 求二叉树的层序遍历 相对简单，使用队列一层一层扫描即可：\nclass Solution: def levelOrder(self , root: TreeNode) -\u0026gt; List[List[int]]: if not root: return from collections import deque result, queue = [], deque([root]) while queue: tmp = [] for _ in range(len(queue)): node = queue.popleft() tmp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(tmp) return result 比较有趣的是递归的写法，然而直接 Stack Overflow……\nBM27 按之字形顺序打印二叉树 层序遍历+判断正负，也很简单。\nclass Solution: def Print(self , root: TreeNode) -\u0026gt; List[List[int]]: if not root: return from collections import deque result, queue, tik = [], deque([root]), True while queue: tmp = [] for _ in range(len(queue)): node = queue.popleft() tmp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if tik: result.append(tmp) else: result.append(tmp[::-1]) tik = (not tik) return result BM28 二叉树的最大深度 依然是层序遍历。\nclass Solution: def maxDepth(self , root: TreeNode) -\u0026gt; int: if not root: return 0 from collections import deque queue, depth = deque([root]), 0 while queue: for _ in range(len(queue)): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) depth = depth + 1 return depth BM29 二叉树中和为某一值的路径(一) 本来以为很简单，但写起来意外不顺手，最后还是基于后序遍历的代码修改。只要再加一个栈，就可以获得完整的路径。\nclass Solution: def hasPathSum(self , root: TreeNode, sumup: int) -\u0026gt; bool: if not root: return False stack, count = [root], 0 while stack: node = stack.pop() if node: stack.extend([node, None]) count += node.val if node.right: stack.append(node.right) if node.left: stack.append(node.left) else: node = stack.pop() if (not node.left) and (not node.right) and count == sumup: # 叶子结点 return True else: count -= node.val return False BM30 二叉搜索树与双向链表 中序遍历，二叉树的题目写起来意外棘手……\nclass Solution: def Convert(self , root ): if not root: return None stack, pre = [], None # 使用两个指针记录状态 while root: # 左 stack.append(root) root = root.left while stack: # root 是当前访问的结点 node = stack.pop() # 根 root = node.right # 右 node.left = pre if pre: pre.right = node else: head = node pre = node while root: stack.append(root) root = root.left return head BM31 对称的二叉树 仔细想想，好像任何一种遍历方式都可以，只要把左右颠倒过来遍历，再比较即可。\n这里使用层序遍历，不过要注意，元素为空也是一种需要比较的状态……\nclass Solution: def isSymmetrical(self , root: TreeNode) -\u0026gt; bool: if not root: return True queue_left, queue_right = [root], [root] while queue_left and queue_right: node_left = queue_left.pop() node_right = queue_right.pop() if node_left and node_right: # 同时存在 if node_left.val != node_right.val: return False else: queue_left.append(node_left.left) # 空状态也要记录 queue_left.append(node_left.right) queue_right.append(node_right.right) queue_right.append(node_right.left) elif (not node_left) and (not node_right): # 同时为空 pass else: return False return (not queue_left) and (not queue_right) BM32 合并二叉树 同样是任何一种遍历方式都可以，依然是层序：\nclass Solution: def mergeTrees(self , t1: TreeNode, t2: TreeNode) -\u0026gt; TreeNode: if not t1: return t2 if not t2: return t1 head = TreeNode(t1.val + t2.val) queue1, queue2, queue = [t1], [t2], [head] while queue1 and queue2: node1, node2, node = queue1.pop(), queue2.pop(), queue.pop() if node1.left and node2.left: node.left = TreeNode(node1.left.val + node2.left.val) queue.append(node.left) queue1.append(node1.left) queue2.append(node2.left) elif node1.left: node.left = node1.left elif node2.left: node.left = node2.left else: pass if node1.right and node2.right: node.right = TreeNode(node1.right.val + node2.right.val) queue.append(node.right) queue1.append(node1.right) queue2.append(node2.right) elif node1.right: node.right = node1.right elif node2.right: node.right = node2.right else: pass return head BM33 二叉树的镜像 爱上了层序……\nclass Solution: def Mirror(self , root: TreeNode) -\u0026gt; TreeNode: if not root: return root queue = [root] while queue: node = queue.pop() node.left, node.right = node.right, node.left # 原地镜像 if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root BM34 判断是不是二叉搜索树 又是中序遍历……\nclass Solution: def isValidBST(self , root: TreeNode) -\u0026gt; bool: if not root: return False stack, pre = [], -2**32-1 while root: stack.append(root) root = root.left while stack: node = stack.pop() if not node.val \u0026gt; pre: return False else: pre = node.val root = node.right while root: stack.append(root) root = root.left return True BM35 判断是不是完全二叉树 又是层序遍历。\nclass Solution: def isCompleteTree(self , root: TreeNode) -\u0026gt; bool: if not root: return True from collections import deque queue, flag = deque([root]), False # 标记是否出现叶子结点 while queue: for _ in range(len(queue)): node = queue.popleft() if node: if flag: # 之前有空结点 return False else: queue.extend([node.left, node.right]) else: # 出现空结点 flag = True return True # 遍历完成，没有中途退出，是完全二叉树 BM36 判断是不是平衡二叉树 美好的一天从一道“简单”题开始😭\n方法一：递归（Credit：官方解答） 其实就是要写一个递归计算二叉树深度的函数，发现不平衡立刻返回 False：\nclass Solution: def IsBalanced_Solution(self , root: TreeNode) -\u0026gt; bool: return self.height(root) \u0026gt;= 0 # 能求出高度就是平衡二叉树 def height(self, root: TreeNode) -\u0026gt; int: if not root: # 空结点，高度自然是 0 return 0 else: leftHeight = self.height(root.left) rightHeight = self.height(root.right) if leftHeight == -1 or rightHeight == -1 or abs(leftHeight - rightHeight) \u0026gt; 1: return -1 else: return max(leftHeight, rightHeight) + 1 方法二：后序遍历 类似 BM29，使用一个字典存储每个结点的深度：\nclass Solution: def IsBalanced_Solution(self , root: TreeNode) -\u0026gt; bool: if not root: return True stack, height = [root], {None: 0} while stack: root = stack.pop() if root: stack.extend([root, None]) if root.left: # 不小心写反了！ stack.append(root.left) if root.right: stack.append(root.right) else: node = stack.pop() if abs(height[node.left] - height[node.right]) \u0026gt; 1: return False else: height[node] = max(height[node.left], height[node.right]) + 1 return True BM37 二叉搜索树的最近公共祖先 偷懒了，怎么简单怎么写。\nclass Solution: def lowestCommonAncestor(self , root: TreeNode, p: int, q: int) -\u0026gt; int: while root: if p \u0026lt; root.val and q \u0026lt; root.val: root = root.left elif p \u0026gt; root.val and q \u0026gt; root.val: root = root.right else: return root.val BM38 在二叉树中找到两个节点的最近公共祖先 就很朴素：\n 后序遍历二叉树，找到前往两个结点的路径； 按顺序逐个比较路径中的每个结点，找到最后一个相同的并返回。  奇怪的是，如果用数组保存 TreeNode 的话，在比较相等的时候会出问题……\nclass Solution: def lowestCommonAncestor(self , root: TreeNode, o1: int, o2: int) -\u0026gt; int: from os.path import commonprefix if not root: return None stack, path, path1, path2 = [root], [], [], [] while stack: node = stack.pop() if node: stack.extend([node, None]) path.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) else: node = stack.pop() if node.val == o1: path1 = path.copy() # 浅复制 if node.val == o2: path2 = path.copy() path.pop() return commonprefix([path1, path2])[-1] BM39 序列化二叉树 标准答案是按前序和中序遍历做的，还是喜欢层序（因为官方使用的就是层序），虽然不难，但是很长……\nclass Solution: def Serialize(self, root): if not root: return \u0026#39;{}\u0026#39; from collections import deque result, queue = \u0026#39;\u0026#39;, deque([root]) while any(queue): for _ in range(len(queue)): node = queue.popleft() if node: queue.extend([node.left, node.right]) if result: result += \u0026#34;,\u0026#34; + str(node.val) else: result += \u0026#34;{\u0026#34; + str(node.val) else: queue.extend([None, None]) result += \u0026#34;,#\u0026#34; return result + \u0026#34;}\u0026#34; def Deserialize(self, s): if s == \u0026#34;{}\u0026#34;: return None from collections import deque data = s[1:-1].split(\u0026#39;,\u0026#39;) root = TreeNode(0) queue = deque([root]) for s in range(len(data)): if data[s] != \u0026#39;#\u0026#39;: head = queue.popleft() head.val = int(data[s]) if 2 * (s + 1) \u0026lt; len(data): # 编号为 N 的结点子结点编号为 2N, 2N+1，对应的数组坐标为 N-1 if data[2 * (s + 1) - 1] != \u0026#39;#\u0026#39;: head.left = TreeNode(0) queue.append(head.left) if data[2 * (s + 1)] != \u0026#39;#\u0026#39;: head.right = TreeNode(0) queue.append(head.right) else: # 到达最底层 pass else: # 空结点 pass return root BM40 重建二叉树 明明这题更难一点😭题解的做法是递归：\n 找到前序遍历的第一个结点，即为根结点； 找到中序遍历中根结点所在的位置，根结点左边的结点即为左子树，右边的结点即为右子树； 同样对前序遍历的结点进行左右子树的切分，递归做下去即可。  class Solution: def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -\u0026gt; TreeNode: if not len(pre) or not len(vin): return None root = TreeNode(pre[0]) root_index = vin.index(pre[0]) root.left = self.reConstructBinaryTree(pre[1:root_index+1], vin[0:root_index]) root.right = self.reConstructBinaryTree(pre[root_index+1:], vin[root_index+1:]) return root 如果不使用递归，考虑使用栈作为辅助存储：\n 从前序遍历读取第一个结点，栈为空，新建结点后放入栈中； 从前序遍历中读取下一个结点，计算中序索引，并与栈中的结点在中序中的索引大小进行比较； 如果小于栈最后一个结点的索引，说明是栈最后一个结点的左子结点，入栈； 如果大于栈最后一个结点的索引，说明这个结点一定是栈中某个元素的右结点，以反方向遍历栈，找到栈中中序索引比结点索引小且距离最小的第一个结点，就是所求的祖先。  终于写出来了，然而效率并不如递归……\nclass Solution: def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -\u0026gt; TreeNode: if not len(pre) or not len(vin): return None stack, vin_index, tmp = [], dict((j,i) for i,j in enumerate(vin)), [] for val in pre: if not stack: # 刚开始 栈为空 stack.append(TreeNode(val)) tmp.append(val) else: # 栈不为空，开始比较结点 while stack[-1].val != val: # 结点未入栈 if vin_index[val] \u0026lt; vin_index[stack[-1].val]: # 小于最后一个结点，为左子结点 stack[-1].left = TreeNode(val) stack.append(stack[-1].left) tmp.append(val) else: # 是某个祖先的右结点 closest_index = -1 # 中序遍历栈中离结点最近的左边结点坐标 for node in reversed(stack): if vin_index[node.val] \u0026lt; vin_index[val]: if vin_index[node.val] \u0026gt; closest_index: closest_index = vin_index[node.val] if closest_index == vin_index[val] - 1: break else: # 似乎可以再优化一下…… pass else: # 遇到右边的结点，停止 break while vin_index[stack[-1].val] != closest_index: stack.pop() tmp.pop() stack[-1].right = TreeNode(val) stack.append(stack[-1].right) tmp.append(val) return stack[0] BM41 输出二叉树的右视图 又是层序遍历！收工👏\nclass Solution: def solve(self , pre: List[int], vin: List[int]) -\u0026gt; List[int]: tree = self.reConstructBinaryTree(pre, vin) if not tree: return [] from collections import deque queue, result = deque([tree]), [] while queue: for _ in range(len(queue)): node = queue.popleft() val = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(val) return result ","date":"2022-04-03T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-03/","title":"做题笔记03：二叉树"},{"content":"BM17 二分查找-I 学习套模版（闭区间搜索），这个模版还可以用于有重复数字时搜索左侧和右侧边界（只要修改 target == nums[mid] 即可）。\nclass Solution: def search(self , nums: List[int], target: int) -\u0026gt; int: left, right = 0, len(nums) - 1 # 使用闭区间 [0, length-1] 做二分查找 while left \u0026lt;= right: # 因为是闭区间，终止条件为 left\u0026gt;right 即 [left, right] 为空 mid = left + (right - left) // 2 # 模版的防溢出，虽然 Python 不用管 if target == nums[mid]: return mid elif target \u0026gt; nums[mid]: # 搜索区间改为 [mid+1, length-1] left = mid + 1 elif target \u0026lt; nums[mid]: # 搜索区间改为 [0, mid-1] right = mid - 1 return -1 # 没找到结果 BM18 二维数组中的查找 左上角是最小的数，右下角是最大的数，假如从左上角开始，如果 target 比左上角的数大，就有两条可能的路径。虽然不是不能做，但有没有更简单的做法？\n数组中有两个特殊的位置只有一条路径：右上角和左下角。如果以右上角作为顶点，每个元素的左元素和下元素作为子结点，不难看到这是一棵二叉搜索树。\nclass Solution: def Find(self , target: int, array: List[List[int]]) -\u0026gt; bool: i, j = 0, len(array[0]) - 1 # i 是纵坐标， j 是横坐标，从右上角开始 while j \u0026gt;= 0 and i \u0026lt; len(array) and target != array[i][j]: if target \u0026lt; array[i][j]: j = j - 1 elif target \u0026gt; array[i][j]: i = i + 1 return (j \u0026gt;= 0 and i \u0026lt; len(array)) BM19 寻找峰值 很无聊的一道题，为了使用二分查找生造出来的感觉……\n出发点大概是，注意到如果中间元素比右边元素大，则中间元素可能是峰值，如果不是，中间元素的左边一定比中间元素大，也可能是峰值……如果最左边元素是最大值然后一直递减，按照题目的条件，最左边元素也算是峰值，因此一定有峰值在 [0, mid] 之间。同理，如果中间元素比右边元素小，一定有峰值在 [mid+1, length-1]：\nclass Solution: def findPeakElement(self , nums: List[int]) -\u0026gt; int: left, right = 0, len(nums) - 1 while left \u0026lt; right: mid = left + (right - left) // 2 if nums[mid] \u0026gt; nums[mid+1]: # 搜索区间变成 [0, mid] right = mid else: # 搜索区间变成 [mid + 1, length-1] left = mid + 1 return right # 区间一直在收缩，直到 left == right BM20 数组中的逆序对 终于遇到第一道真正意义上的难题😭\n方法一：归并排序（Credit：《剑指Offer》） 最容易想到的计算方式是按定义计算，如 {7,5,6,4} 的步骤如下：\n 把 7 和结果中的数比较（{}），逆序数为 0，放入结果中； 把 5 和结果中的数比较（{7}），逆序数为 1，放入结果中； 把 6 和结果中的数比较（{7,5}），逆序数为 1，放入结果中； 把 4 和结果中的数比较（{7,5,6}），逆序数为 3，放入结果中； 结束，总的逆序数为 0+1+1+3=5。  显然直接计算方法的时间复杂度为 O(n^2)，不能满足题目要求，有没有别的方法呢？试试采用分治法，比如归并排序：\n 把 {7,5,6,4} 依次划分成最小的部分，即 {7},{5},{6},{4}； 尝试合并：{7}{5} 比较最后一位的大小，因为 7\u0026gt;5，逆序数为 1，按顺序合成 {5,7}；{6}{4} 比较最后一位的大小，因为 6\u0026gt;4，逆序数为 1，按顺序整理成 {4,6}； 接下来需要比较 {5,7} 和 {4,6} 的逆序数，首先比较最后一位，因为 7\u0026gt;6，即 {4,6} 所有数都比 7 小，逆序数 +2，结果放入 {7}，指针左移； 指针左移后，比较的是 {5,6} 的大小，因为 5\u0026lt;6，逆序数为 0，把 6 放入结果中，变成 {6,7}，指针左移； 以此类推，现在比较的是 {5,4} 的大小，因为 5\u0026gt;4，逆序数为 1，把 5 放入结果中，变成 {5,6,7}，指针左移； 最后把 {4} 放入结果中即可，逆序数为 1+1+2+0+1=5。  讨厌递归……参考了题解的代码：\nclass Solution: def InversePairs(self, data: List[int]) -\u0026gt; int: return self.MergeSort(data)[1] % 1000000007 def MergeSort(self, data: List[int]): # 返回排好序的数据和逆序数 # 1. 先写退出条件，即只有 0 个或一个元素的情形 if len(data) \u0026lt;= 1: return (data, 0) else: # 2. 寻找中点，把数组切割成两部分 mid = len(data) // 2 left, left_inverse = self.MergeSort(data[:mid]) right, right_inverse = self.MergeSort(data[mid:]) result = [] count_inverse = left_inverse + right_inverse # 3. 开始进行归并排序 l, r = 0, 0 while l \u0026lt; len(left) and r \u0026lt; len(right): if left[l] \u0026lt;= right[r]: # 左边 \u0026lt; 右边，逆序数为 0 result.append(left[l]) l += 1 else: # 左边 \u0026gt; 右边，逆序数为左边指针右边所有元素个数（含） count_inverse += len(left) - l result.append(right[r]) r += 1 result += left[l:] + right[r:] # 比较结束，接上剩下的元素 return result, count_inverse 方法二：快速排序（Credit：题解） 同样是分治策略，既然可以用归并，那么能不能用快排？也是可以的，因为逆序数本质上是比较所有的两两组合，快速排序的时候，首先选择主元（第一个元素），然后把所有数分成大于主元和小于主元两个独立部分，此时就完成了：\n 主元和所有其他元素的比较； 大于主元的元素与小于主元的元素的逐一相互比较，准确的说，是所有比主元小的元素，和排在该元素前面且大于主元的元素进行比较（为什么相等？因为求的是逆序数）。  于是接下来只需要递归地对大于主元和小于主元的元素分别执行相同操作即可。\nclass Solution: def InversePairs(self, data: List[int]) -\u0026gt; int: return self.QuickSort(data) % 1000000007 def QuickSort(self, data: List[int]): # 同样先写退出条件 if len(data) \u0026lt;= 1: return 0 else: bigger, smaller = [], [] count_inverse = 0 pivot = data[0] for num in data[1:]: if num \u0026gt; pivot: bigger.append(num) else: smaller.append(num) count_inverse += len(bigger) + 1 return count_inverse + self.QuickSort(bigger) + self.QuickSort(smaller) 扩展：树状数组/线段树 顾名思义，树状数组就是长得像树一样的数组！\n树状数组的优点是可以以对数时间复杂度获得元素固定的数列前 N 项的和（其实任意区间的和都可以），这和逆序数有什么关系呢？\n回顾最开始的做法，我们从左到右求出每个数之前比它大的数的个数，累加起来就是答案。如果存在某种能以 O(log(n)) 时间复杂度计算出“比它大的数的个数”的数据结构，时间复杂度就降到 O(nlog(n)) 了：\n 遍历数组，了解数组中所有元素的取值范围，假设取值范围为 0\u0026lt;=x\u0026lt;=1000，新建一个长度为 1001 的树状数组，把所有元素初始成 0。这个树状数组用于存储到目前为止每个数出现的次数。其实也有不同的做法，比如有的人会对数组中的元素进行排序，并重新编号，称为 离散化； 读取第一个元素 a，把树状数组中 a 对应的数据 +1（O(log(n))）； 此时计算树状数组中 [0, a] 区间的和（O(log(n))），这个和表示目前为止的数组元素中 \u0026lt;= a 的元素个数，使用当前的位置 1 减去它，就得到此元素的逆序数； 遍历数组所有元素，把所有逆序数加起来，就得到了答案。  树状数组和线段树的实现代码可以参考 OI Wiki，既然记不住，应该不会考吧……\nBM21 旋转数组的最小数字 和 BM19 类似，也是为了考察二分查找造出来的题，假设数组由 AB 变成 BA：\n 假设数据为 [3,4,5,1,2]，首先确定 left=3, mid=5, right=2； 因为 mid \u0026gt; right，数组是非降的，故 mid 一定在 B，right 一定在 A，最小值一定在 [mid+1, right] 中。更新区间进行二分查找； 同理，如果 mid \u0026lt; right，说明 mid 和 right 都在 A 中，最小值是 B 和 A 的交界点（A 的第一个元素），故一定在 [left, mid] 中，更新区间进行二分查找； 最后，如果 mid == right，因为数组是非降的，可以肯定 right 一定不是最小值，故搜索区间改为 [left, right-1]； 区间不断缩小，当 left == right 时返回结果。  依然是套模板：\nclass Solution: def minNumberInRotateArray(self , rotateArray: List[int]) -\u0026gt; int: if len(rotateArray) == 0: return None left, right = 0, len(rotateArray) - 1 while left \u0026lt; right: mid = left + (right - left) // 2 if rotateArray[mid] \u0026gt; rotateArray[right]: # [mid+1, right] left = mid + 1 elif rotateArray[mid] \u0026lt; rotateArray[right]: # [left, mid] right = mid elif rotateArray[mid] == rotateArray[right]: # [left, right-1] right = right - 1 return rotateArray[left] BM22 比较版本号 感恩 Python！\nclass Solution: def compare(self , version1: str, version2: str) -\u0026gt; int: version1 = [int(i) for i in version1.split(\u0026#39;.\u0026#39;)] version2 = [int(i) for i in version2.split(\u0026#39;.\u0026#39;)] # 因为 Python 中 [1,0] \u0026lt; [1,0,0] if len(version1) \u0026gt; len(version2): version2 += [0,] * (len(version1) - len(version2)) else: version1 += [0,] * (len(version2) - len(version1)) if version1 \u0026lt; version2: return -1 elif version1 == version2: return 0 else: return 1 ","date":"2022-04-02T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-02/","title":"做题笔记02：二分查找/排序"},{"content":"BM1 反转链表  把链表第一个结点变成最后一个（node.next=null），前往下一个结点； 把该结点的 next 改成前一个结点； 继续前往下一个结点，直到最后一个结点为止。  class Solution: def ReverseList(self , head: ListNode) -\u0026gt; ListNode: pre_node = None while head: next_node = head.next head.next = pre_node pre_node = head head = next_node return pre_node BM2 链表内指定区间反转 沿用上一题的代码，枯燥而且容易出错……\n做完 BM3 回头看发现忘了给输入 m,n 做检查，whatever。\nclass Solution: def reverseBetween(self , head: ListNode, m: int, n: int) -\u0026gt; ListNode: # 0. 设置 0 结点 dummy = ListNode(0) dummy.next = head # 1. 找到两端，即第 m-1, n+1 个结点 left = dummy for _ in range(m-1): left = left.next right = head for _ in range(n): right = right.next # 2. 开始反转，head 指向第 m 个结点 pre_node, head = right, left.next while head != right: next_node = head.next head.next = pre_node pre_node = head head = next_node # 3. 接头 left.next = pre_node return dummy.next BM3 链表中的节点每k个一组翻转 感觉被针对了，失去了吐槽的力气，没有十年脑溢血想不出这样的题目……\nclass Solution: def reverseKGroup(self , head: ListNode, k: int) -\u0026gt; ListNode: if head == None or head.next == None: return head # 0. 同样先写 dummy dummy = ListNode(0) dummy.next = head # 1. 计算需要反转多少次 cur = head length = 0 while cur != None: length = length + 1 cur = cur.next count = length // k # 2. 同样先找两端 left = dummy right = head if count \u0026gt; 0: for _ in range(k): right = right.next # 3. 开始循环反转 for i in range(1, count+1): pre_node = right if count \u0026gt; i: for _ in range(k-1): pre_node = pre_node.next head = left.next while head != right: next_node = head.next head.next = pre_node pre_node = head head = next_node left.next = pre_node # 前往后面 k 个，注意此时是断开状态（画图更容易理解），需要给 right 左边补 dummy 作为 left if count \u0026gt; i: left = ListNode(0) left.next = right for _ in range(k): right = right.next return dummy.next 从题解学到一种双指针技巧：head 指针一直指在第一个结点上，left 指针一直指向第 0 个结点，每次交换时 head.next.next = left.next 然后 head.next 和 left.next 分别前进一位。\n结合图形可能更容易理解（比如想像成一串珠子），每次交换把第一个结点的当前 next 结点移到最左边（即第 0 个结点的右边一位），然后第一个结点向右前进一位，第 0 个结点保持不动，不难看到只需要移动 k-1 次。\nclass Solution: def reverseKGroup(self , head: ListNode, k: int) -\u0026gt; ListNode: if head == None or head.next == None: return head # 0. 同样先写 dummy dummy = ListNode(0) dummy.next = head # 1. 计算链表长度 length = 0 while head != None: length = length + 1 head = head.next # 2. 同样先找左端 left = dummy head = dummy.next # 3. 开始循环反转 while length \u0026gt;= k: for j in range(k-1): next_node = head.next head.next = next_node.next next_node.next = left.next left.next = next_node length = length - k left = head head = left.next return dummy.next BM4 合并两个排序的链表 比较大小，小的进链表，指针移到下一个，到结尾就收工。\nclass Solution: def Merge(self , pHead1: ListNode, pHead2: ListNode) -\u0026gt; ListNode: # 老套路，先创建 dummy dummy = ListNode(0) head = dummy while pHead1 != None and pHead2 != None: if pHead1.val \u0026gt; pHead2.val: head.next = pHead2 pHead2 = pHead2.next else: head.next = pHead1 pHead1 = pHead1.next head = head.next head.next = (pHead2 if pHead2 else pHead1) return dummy.next BM5 合并 k 个已排序的链表 学习使用 Python 的优先队列（二叉堆），不过效果不咋样，和直接 sort 的效率没明显差异。\n需要注意的是，Python 的二叉堆在比较 tuple 的大小时，如果 tuple 第一个结点相等，就接着比较第二个结点，如果 tuple 第二个结点不能比较大小，就会报错 TypeError: '\u0026lt;' not supported between instances of xxx and xxx，所以还是使用了 index 作为比较的依据。\nclass Solution: def mergeKLists(self , lists: List[ListNode]) -\u0026gt; ListNode: import heapq dummy = ListNode(0) cur = dummy h = [(head.val, idx, head) for idx, head in enumerate(lists) if head] heapq.heapify(h) while h: _, idx, head = heapq.heappop(h) cur.next = head cur, head = cur.next, head.next if head: heapq.heappush(h, (head.val, idx, head)) return dummy.next BM6 判断链表中是否有环 熟悉的快慢双指针“追及问题”。\nclass Solution: def hasCycle(self , head: ListNode) -\u0026gt; bool: slow, fast = head, head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: return True return False BM7 链表中环的入口结点 也是快慢双指针“追及问题”。假设相遇时慢指针走了 a 步，快指针走了 2a 步，则 2a-a=a 是环长 z 的整数倍，同时也是到环入口的距离 x + 环入口到相遇点的距离 y + 环长 z 的整数。所以 x + y 是环长的整数倍，只要把快指针放回起点逐个遍历（慢指针在 y 处），两个指针再次相遇时就是在入口起点。如果再加个计数器，就可以求出到环入口的长度。\nclass Solution: def EntryNodeOfLoop(self, head): slow, fast = head, head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: fast = head while slow != fast: slow, fast = slow.next, fast.next return slow return None BM8 链表中倒数最后 k 个结点 依然是双指针问题。只要让一个指针先走 k 步就好。\nclass Solution: def FindKthToTail(self , head: ListNode, k: int) -\u0026gt; ListNode: slow, fast = head, head for _ in range(k): if not fast: return fast fast = fast.next while fast: slow, fast = slow.next, fast.next return slow BM9 删除链表的倒数第 n 个节点 和 BM8 的唯一区别是求倒数 k+1 个结点，所以要设置 dummy。\nclass Solution: def removeNthFromEnd(self , head: ListNode, n: int) -\u0026gt; ListNode: dummy = ListNode(0) dummy.next = head slow, fast = dummy, head for _ in range(n): if not fast: return fast fast = fast.next while fast: slow, fast = slow.next, fast.next slow.next = slow.next.next return dummy.next BM10 两个链表的第一个公共结点 注意链表是一种特殊的数据结构，每个结点可能有很多个前驱，但后继只能有一个。如果两个链表有公共结点，说明从某个结点开始，这两个链表完全一致。因此可以先算出两个链表的长度差 d，让较长的链表先走 d 步，两个指针相遇时就是公共结点。\n除此之外，题解还给出一种方法：把两个链表接起来遍历，A=A+B，B=B+A。因为会经过 None，所以不会出现死循环。\nclass Solution: def FindFirstCommonNode(self , head_1 , head_2 ): if (not head_1) or (not head_2): return None ptr_1, ptr_2 = head_1, head_2 while ptr_1 != ptr_2: ptr_1 = (ptr_1.next if ptr_1 else head_2) ptr_2 = (ptr_2.next if ptr_2 else head_1) return ptr_1 BM11 链表相加(二) 这种题目有什么存在的必要吗？？？？？？最后还是心平气和使用 BM1 的代码（省略）……\nclass Solution: def addInList(self , head_1: ListNode, head_2: ListNode) -\u0026gt; ListNode: head_1, head_2 = self.ReverseList(head_1), self.ReverseList(head_2) dummy = ListNode(0) head = dummy carrier = 0 while head_1 or head_2: sumup = (head_1.val if head_1 else 0) + (head_2.val if head_2 else 0) + carrier head.next = ListNode(sumup % 10) carrier = sumup // 10 head = head.next head_1 = (head_1.next if head_1 else None) head_2 = (head_2.next if head_2 else None) if carrier: head.next = ListNode(carrier) return self.ReverseList(dummy.next) BM12 单链表的排序 不想手写 merge sort……使用 BM5 的二叉堆吧：\nclass Solution: def sortInList(self , head: ListNode) -\u0026gt; ListNode: import heapq idx, h, dummy = 0, [], ListNode(0) cur = head while cur: heapq.heappush(h, (cur.val, idx, cur)) cur = cur.next idx = idx + 1 cur = dummy while h: cur.next = heapq.heappop(h)[2] cur = cur.next cur.next = None return dummy.next BM13 判断一个链表是否为回文结构 回文结构即正向和反向遍历结果完全相同的结构。由于链表只能正着走，可以考虑先找到中点，把后半截链表使用 BM1 反过来，再逐个进行比较。找中点也可以使用快慢双指针。\n虽然不难，但是 debug 了好久，好丢人……\nclass Solution: def isPail(self , head: ListNode) -\u0026gt; bool: if (not head) or (not head.next): # 长度为 0 或 1 return True dummy = ListNode(0) dummy.next = head slow, fast = dummy, dummy while fast and fast.next: slow, fast = slow.next, fast.next.next if not fast: # 链表长度为奇数，此时 slow 在中点 fast = self.ReverseList(slow) else: # 链表长度为偶数，此时 slow 在前半段末 fast = self.ReverseList(slow.next) slow = head while slow and fast and slow.val == fast.val: # 不要忘记比较的是 .val！！！ slow, fast = slow.next, fast.next return ((not slow) or (not fast)) BM14 链表的奇偶重排 怎么又是双指针……JOJO 我不做人啦！\n多指针的题目往往很难进行调试（所以指针越少越好！），需要对状态进行仔细分析。例如，当 while 循环结束后，如果链表结点是奇数个（odd 是最后一个结点，odd.next == even == None），只需要把 even_head 接好；如果链表结点是偶数个（odd.next == even != None 是最后一个结点, even.next == None），同样只需要接上 even_head，所以最后的处理没有任何问题。\nclass Solution: def oddEvenList(self , head: ListNode) -\u0026gt; ListNode: if (not head) or (not head.next) or (not head.next.next): # 长度为 0,1,2 不需要处理 return head odd = head even, even_head = head.next, head.next while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head BM15 删除有序链表中重复的元素-I 写了太多双指针，已经成为巴甫洛夫的狗了：\nclass Solution: def deleteDuplicates(self , head: ListNode) -\u0026gt; ListNode: slow, fast = head, head while fast: fast = fast.next while fast and fast.val == slow.val: fast = fast.next slow.next = fast slow = slow.next return head 看题解才发现一个指针就足够了：\nclass Solution: def deleteDuplicates(self , head: ListNode) -\u0026gt; ListNode: if not head: return head cur = head while cur.next: if cur.next.val == cur.val: cur.next = cur.next.next else: cur = cur.next return head BM16 删除有序链表中重复的元素-II 看上去很简单，做起来无从下手。仔细想想，这道题其实要三个相邻的指针：如果后面两个指针的值相同，则一直前进到不同为止，然后最前面的指针的 next 指向最后的指针（不同的值），直到中间的指针指到 None 为止，这又会产生越界问题……要仔细区分所有状态，小心小心再小心！\nclass Solution: def deleteDuplicates(self , head: ListNode) -\u0026gt; ListNode: if head == None or head.next == None: return head dummy = ListNode(0) dummy.next = head slow, middle = dummy, head while middle: if middle.next: # middle 不是最后一个元素 if middle.val == middle.next.val: # 出现重复 while middle.next and middle.val == middle.next.val: middle = middle.next # 停止有两种可能：middle 是最后一个元素，或者出现第一个不等 if middle.next: # 出现不等 slow.next = middle.next middle = middle.next else: # middle 是最后一个元素，middle.next = None slow.next = None return dummy.next else: # 没有重复，slow 和 middle 分别前进一格 slow = slow.next middle = middle.next else: # middle 是最后一个元素，且和前一个元素没有重复 slow.next = middle return dummy.next 可以再精简一下判断逻辑，不过可读性似乎变差了：\nclass Solution: def deleteDuplicates(self , head: ListNode) -\u0026gt; ListNode: if head == None or head.next == None: return head dummy = ListNode(0) dummy.next = head slow, middle = dummy, head while middle and middle.next: # middle 不是最后一个元素，也不为空 if middle.val == middle.next.val: # 出现重复 while middle.next and middle.val == middle.next.val: middle = middle.next # 停止有两种可能：middle 是最后一个元素，或者出现第一个不等 # 无论是哪一种可能，都是相同的代码 slow.next = middle.next middle = middle.next else: # 没有重复，slow 和 middle 分别前进一格 slow = slow.next middle = middle.next if middle: # middle 是最后一个元素，且和前一个元素没有重复 slow.next = middle return dummy.next 其实更容易理解的方法是使用 hash 或者常数排序，不过空间复杂度就做不到 O(1) 了。收工～\n","date":"2022-04-01T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/oj-01/","title":"做题笔记01：链表"},{"content":"要好好准备找工作！\nLinux 简介 历史 在计算机刚发明的年代，由于计算机造价昂贵，人们希望能高效利用宝贵的上机时间，于是分时操作系统诞生了。当时的计算机能提供大约 16 个文字终端使用，然而这还远远不能满足需求。\n1963 年，MIT、贝尔实验室和通用电气公司启动了一项雄心勃勃的计划：打造一个能提供 300 个以上文字终端使用的计算机系统（称为“Multics”）。计划的参与者之一、贝尔实验室的 Ken Thompson 受到启发，在 1969 年一个偶然的假期里1，为 PDP-7 电脑编写了一个简单的操作系统（戏称为“Unics”），后来这个系统逐渐演变成大名鼎鼎的 Unix。\nUnix 逐渐展示出了足够的商业价值，引发了一系列著作权官司，于是贝尔实验室母公司 AT\u0026amp;T 在 1979 年决定禁止向学生开放源码。1984 年，为了方便教学，Andrew Tanenbaum2 决定自己动手编写一套精简版的 Unix，称为 Minix。同年，Richard Mathew Stallman 发起了 GNU 计划，然后成立了自由软件基金会。\n自由软件基金会发布了一系列方便的软件（GCC, Emacs, BASH, ...），但却迟迟未出操作系统。1991 年，芬兰大学生 Linus Torvalds 受到 Minix 启发，在贷款买来的 386 电脑上使用 GNU 的 BASH, GCC 等工具，成功实现了一个类似 Unix 的小型操作系统，于是发布到 BBS 上开放下载并征求意见。FTP 服务器管理员把下载目录命名为 Linux，从此这个系统就被称为 Linux 了。\n虽然 Linux 的桌面操作系统在平时非常罕见，但 95% 以上的网站服务器都在使用 Linux3。这一系列的笔记就从 Linux 开始吧～\n初体验 传统意义上的 Linux 指的是 Linux Kernel，使用起来并不方便。所幸目前已经有各种打包好的发行版（如 Ubuntu、Arch Linux 等），你可以通过虚拟机运行，也可以刻录到 U 盘直接启动，不想动手也可以使用云服务器。这里使用的是免费的 Google Colaboratory，登录后可以看见：\nWelcome to Ubuntu 18.04.5 LTS (GNU/Linux 5.4.144+ x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage ... ~# 和平时使用的图形界面完全不一样，接下来可以试试执行简单的命令：\n~# w 13:55:23 up 1:13, 1 user, load average: 0.00, 0.00, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 127.0.0.1 12:45 1.00s 0.00s 0.00s w ~# date Sun Mar 27 13:55:30 UTC 2022 ~# cal March 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ~# pwd /root ~# id uid=0(root) gid=0(root) groups=0(root) ~# ls 参数与帮助 在执行一系列命令后，你未免会感觉有点失望：虽然这个操作系统勉强能用，但用起来很不顺手。为了让这些工具更顺手，往往需要传入额外的参数，比如：\n~# date -u +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34; 2022-03-27 14:16:52 ~# cal 01 2077 January 2077 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ~# ls -alh total 68K drwx------ 1 root root 4.0K Mar 27 14:08 . drwxr-xr-x 1 root root 4.0K Mar 27 12:42 .. -r-xr-xr-x 1 root root 1.2K Jan 1 2000 .bashrc drwxr-xr-x 3 root root 4.0K Mar 23 14:22 .gsutil drwxr-xr-x 5 root root 4.0K Mar 23 20:22 .ipython drwx------ 2 root root 4.0K Mar 23 20:22 .jupyter drwxr-xr-x 2 root root 4.0K Mar 27 12:42 .keras drwxr-xr-x 1 root root 4.0K Mar 23 20:22 .local drwxr-xr-x 4 root root 4.0K Mar 23 20:22 .npm -rw-r--r-- 1 root root 148 Aug 17 2015 .profile -r-xr-xr-x 1 root root 254 Jan 1 2000 .tmux.conf 一般的 Linux 命令形式为 command [-options] [parameter1...]，要知道命令接受什么参数，只能查阅命令对应的帮助文档，如执行 command --help 或者 man command：\n~# cal --help cal: invalid option -- \u0026#39;-\u0026#39; Usage: cal [general options] [-jy] [[month] year] cal [general options] [-j] [-m month] [year] ncal -C [general options] [-jy] [[month] year] ncal -C [general options] [-j] [-m month] [year] ncal [general options] [-bhJjpwySM] [-H yyyy-mm-dd] [-s country_code] [[month] year] ncal [general options] [-bhJeoSM] [year] General options: [-31] [-A months] [-B months] [-d yyyy-mm] 然而查阅帮助文档很耗时，也难以记忆，故在开始之前，建议安装 tldr。\n安装新软件 在 Ubuntu，安装软件只需要一行命令：\n~# sudo apt install tldr Reading package lists... Done ... The following NEW packages will be installed: tldr 0 upgraded, 1 newly installed, 0 to remove and 41 not upgraded. Need to get 860 kB of archives. ... Processing triggers for man-db (2.8.3-2ubuntu0.1) ... 那么怎么卸载呢？没关系，有 tldr！\n~# tldr apt ... - Update the list of available packages and versions (it\u0026#39;s recommended to run this before other apt commands): sudo apt update - Search for a given package: apt search {{package}} - Show information for a package: apt show {{package}} - Install a package, or update it to the latest available version: sudo apt install {{package}} - Remove a package (using purge instead also removes its configuration files): sudo apt remove {{package}} ... 可以看到卸载已安装程序的命令是 sudo apt remove command（如果需要同时移除程序的配置文件，把 remove 改成 purge）。遇到不懂的命令，只要 tldr 一下就好！\n文件与目录管理 概述 和 Windows 的文件目录不太一样，Linux 的所有文件和目录都是从根目录开始的，被称为目录树。每一个目录都可以挂载各种文件系统，如硬盘的分区、光盘、ISO 文件、网络文件系统等等。\n从根目录开始，每个目录或文件都有唯一的路径，称为绝对路径。与绝对路径相对应的，自然是相对路径了，即使用 . 表示当前文件夹，使用 .. 表示父文件夹，例如 /var/log 目录在 /root 下的相对路径为 ../var/log。对于 Linux 运维而言，以下是需要定期备份的目录：\n /etc 存储了系统的重要配置文件； /home 或者 /root 是默认的用户目录； /srv 可能是服务器程序数据存放目录； /var/log 存放了大量的日志； /var/spool 存放队列文件，如 /var/spool/mail 存放收到的新邮件，/var/spool/cron 和 /var/spool/at 存放等待执行的任务等； /var/www/html 是常见的 Web 服务器页面默认目录； ……  基本操作 先来尝试最基本的目录和文件操作：\n pwd 打印当前工作目录； cd path 切换工作目录到指定路径； ls path 列出路径下的所有非隐藏文件（常常使用 ls -alh path）； file filename 确定文件类型；  现在可以像 Windows 文件管理器一样管理文件了！不懂可以使用 tldr：\n mkdir dirname 创建新文件夹； touch filename 创建新文件； cp source destination 复制文件； mv source destination 移动/重命名文件； rm filename 删除文件（直接删除，没有回收站和确认选项！）； ln -s source destination 创建文件的符号链接（快捷方式）； ln source destination 创建文件的硬链接（替身）；  查看文件内容 因为 Linux 命令行并不是图形界面，能打开查看或编辑的往往只有文本文件。常用的文件查看命令有：\n cat filename 打印文件所有内容，加上参数 -n 可显示行号，还可以连接文件； head filename 打印文件头十行内容，加上参数 -n 20 打印前 20 行； tail filename 打印文件最后十行内容，加上参数 -n 20 打印最后 20 行； less filename 打开文件阅读器，可以上下翻页，按 q 退出； diff file1 file2 比较两个文件的不同之处； od filename 打印二进制文件。  其中 less 有许多方便的快捷键，如 G 跳转到文件末尾，F 实时刷新，/ 搜索关键词，是查看日志文件的好帮手。\n管道与重定向（重点） 直接打印文本文件内容不太美观，我们往往需要对文本进行简单的处理、格式化再输出，有时还希望把结果保存到指定文件。\nLinux 还有许多可以配合管道处理的文本小工具：\n echo sort uniq cut tr grep  现在你已经可以完成一些简单的任务了，比如\n不过，最著名的 Unix 文本处理工具非 AWK 和 SED 莫属。\n查找文件 which whereis locate find\n文件系统与存储管理 Raid LVM 用户与权限管理 用户、群组和其他 su与sudo visudo passwd adduser/useradd groupadd/addgroup usermod getfacl/setfacl\nchown chgrp chmod umask\nUID GID effective SUID SGID Sticky Bit sudo 的坑 文件系统 ACL 最小权限原则 Vim 简介 活下来 常用模式 行间与行内跳转 文本编辑 多行模式 多文件切换 Bash 基础 常用快捷键  TAB 可以进行自动补全； 上下键可以按顺序翻查以前输入的命令； Ctrl+R 可以查找历史命令；  变量定义与环境变量 条件判断 循环 Bash 编程基础 其他话题 开机流程与自启动项管理 进程管理与任务控制 ps top htop\nfg bg jobs\nkill killall\n系统服务（Systemd） 作用：开机自动启动服务器软件。\n定时服务（Crontab） 作用：定期自动备份，每天自动安装安全更新等。\n保持执行（nohup, screen/tmux） 作用：执行耗时长的任务，如文件同步。\n遇到麻烦？ 扩展阅读 [1] 黄玮的 课件 与 课程录像；\n[2] 鸟哥的 Linux 私房菜：基础学习训练篇；\n[3] 快乐的 Linux 命令行。\n  其实只是为了打游戏……\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 《计算机网络》、《操作系统：设计与实现》和《现代操作系统》的作者。Andrew Tanenbaum 保留了 Minix 的相关权利，但购买教材的人可以免费得到一份 Minix 源代码拷贝。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/Linux\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-03-27T00:00:00Z","permalink":"https://c4rla.github.io/roll/p/devops-01/","title":"运维笔记01：Linux 基础"}]