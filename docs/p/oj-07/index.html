<!DOCTYPE html>
<html lang="zh-CN">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='一鼓作气做完！'><title>做题笔记07：字符串/双指针/贪心算法/模拟</title>

<link rel='canonical' href='https://c4rla.github.io/roll/p/oj-07/'>

<link rel="stylesheet" href="https://c4rla.github.io/roll/scss/style.min.b949db8bead9abdc40291b93383b8da6abc3aa62e74f5580356c06ddbb792dab.css"><meta property='og:title' content='做题笔记07：字符串/双指针/贪心算法/模拟'>
<meta property='og:description' content='一鼓作气做完！'>
<meta property='og:url' content='https://c4rla.github.io/roll/p/oj-07/'>
<meta property='og:site_name' content='卷心菜'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='OJ' /><meta property='article:published_time' content='2022-04-13T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2022-04-13T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="做题笔记07：字符串/双指针/贪心算法/模拟">
<meta name="twitter:description" content="一鼓作气做完！">
    <link rel="shortcut icon" href="https://c4rla.github.io/roll/img/favicon.png" />
<style type="text/css">
    .site-info {text-align: center;}
    .site-info > figure.site-avatar {margin: 0 auto var(--sidebar-element-separation);}
     
     
    @media (min-width: 768px) {.container .left-sidebar {width: 100%;}}
    blockquote.quote {position: relative; margin: 1.5em -10em 0 -10; padding-left: 18%; padding-right: 15%; border: none; background-color: transparent}
    blockquote.quote::before {position: absolute; left: 7%; content: '“'; color: var(--color-contrast-low); font-family: serif; font-size: 3em; font-weight: 700; line-height: 1}
    blockquote cite {display: block; text-align: right;}
    .article-content>p:not(.no-text) {overflow-x: auto; overflow-y: hidden;}
</style>
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://c4rla.github.io/roll/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <h2 class="article-title">
        <a href="https://c4rla.github.io/roll/p/oj-07/">做题笔记07：字符串/双指针/贪心算法/模拟</a>
    </h2>

    
    <h3 class="article-subtitle">
        一鼓作气做完！
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2022年4月13日</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 16 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    
    
    <h2 id="bm83-字符串变形">BM83 字符串变形</h2>
<p>感恩 Python！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trans</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div><h2 id="bm84-最长公共前缀">BM84 最长公共前缀</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestCommonPrefix</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">strs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div><h2 id="bm85-验证ip地址">BM85 验证IP地址</h2>
<p>好无聊的题目，明明有内置函数不给用……直接抄题解了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validate_IPv4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IP</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="n">IP</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="c1"># Validate integer in range (0, 255):</span>
            <span class="c1"># 1. length of chunk is between 1 and 3</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&#34;Neither&#34;</span>
            <span class="c1"># 2. no extra leading zeros</span>
            <span class="c1"># 3. only digits are allowed</span>
            <span class="c1"># 4. less than 255</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&#34;Neither&#34;</span>
        <span class="k">return</span> <span class="s2">&#34;IPv4&#34;</span>
    
    <span class="k">def</span> <span class="nf">validate_IPv6</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IP</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="n">IP</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="n">hexdigits</span> <span class="o">=</span> <span class="s1">&#39;0123456789abcdefABCDEF&#39;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="c1"># Validate hexadecimal in range (0, 2**16):</span>
            <span class="c1"># 1. at least one and not more than 4 hexdigits in one chunk</span>
            <span class="c1"># 2. only hexdigits are allowed: 0-9, a-f, A-F</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">hexdigits</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="s2">&#34;Neither&#34;</span>
        <span class="k">return</span> <span class="s2">&#34;IPv6&#34;</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">IP</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">IP</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_IPv4</span><span class="p">(</span><span class="n">IP</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">IP</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_IPv6</span><span class="p">(</span><span class="n">IP</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&#34;Neither&#34;</span>
</code></pre></div><h2 id="bm86-大数加法">BM86 大数加法</h2>
<p>真的好无聊，明明之前在链表做过了……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
</code></pre></div><h2 id="bm87-合并两个有序的数组">BM87 合并两个有序的数组</h2>
<p>合并排序，熟悉的双指针：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">B</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">head</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">head</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">head</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">head</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">head</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">head</span><span class="p">]</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div><p>看了题解才知道可以逃课，新技能 get！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">m</span><span class="p">:</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span>
        <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</code></pre></div><h2 id="bm88-判断是否为回文字符串">BM88 判断是否为回文字符串</h2>
<p><del>逃课万岁！</del></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">judge</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div><p>双指针反而是最慢的😂</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">judge</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div><h2 id="bm89-合并区间">BM89 合并区间</h2>
<p>先按开头数字排序再合并：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Interval</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Interval</span><span class="p">]:</span>
        <span class="n">intervals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span> <span class="ow">or</span> <span class="n">i</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><h2 id="bm90-最小覆盖子串">BM90 最小覆盖子串</h2>
<p>看清楚题目很重要😂</p>
<p>这里的覆盖，指的是包含 T 中所有字母，并且字母的数量也要覆盖。比如 T 中有 3 个 &quot;a&quot;，覆盖的子串也要至少含有 3 个 &quot;a&quot;，也就是说，&quot;a&quot; 不能覆盖 &quot;aa&quot;。</p>
<p>穷举大概是最容易想到的办法了。首先准备一个 end 指针遍历 S，如果 S 前 end 个字母能覆盖 T，就用另一个指针 start 从最左边开始求最小覆盖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minWindow</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">cover</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="n">S</span> <span class="ow">and</span> <span class="n">S</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">T</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">cover</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">T</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">cover</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">T</span><span class="p">):</span>
                    <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><p>然后就超时啦😂</p>
<p>有什么办法可以改进一下呢？不难看到最大的问题是 start 总是从 0 开始，不能使用前一次的结果。注意到：</p>
<blockquote>
<p><strong>命题</strong> 如果存在比当前更小的覆盖子串，则该子串的 start 一定至少是当前的 start + 1。</p>
<p><strong>证明</strong> 首先显然 S[start:end + 1] 是 S[:end + 1] 的最小覆盖子串，因为直到第 end 位才凑齐所有字母，结束位不可能小于 end；又由于 start 在减少到 S[start:end + 1] 不为最小覆盖子串后停止，开始位也不可能大于 start，得证。</p>
<p>因此，如果存在更小的覆盖子串，子串的 end 一定大于当前的 end，从而 start 也必然会大于当前的 start。</p>
</blockquote>
<p>这就是题解使用的 <a class="link" href="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif"  target="_blank" rel="noopener"
    >滑动窗口法</a> 了，不过依然是超时😂</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minWindow</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">cover</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="n">S</span> <span class="ow">and</span> <span class="n">S</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">T</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">cover</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">T</span><span class="p">):</span>
                <span class="k">while</span> <span class="n">cover</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">T</span><span class="p">):</span>
                    <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><p>不难看到目前的性能瓶颈就是 cover 函数了，有什么办法可以把 cover 的时间复杂度降到 O(1) 呢？自然是以空间换时间了：</p>
<ol>
<li>使用一个字典 d 存放 T 中所有字母和出现的次数，使用一个变量 missing 存放还缺少的字母数量，显然检查 cover 变成了检查 missing 是否等于 0。</li>
<li>从左往右扫描 S，如果遇到 d 中存在的字母，且 d[s] &gt; 0，则 d[s] 和 missing 同时减 1；</li>
<li>如果 d[s] &lt;= 0 则 missing 保持不变，d[s] 减 1；</li>
<li>接下来检查 missing，如果 missing 等于 0，说明当前窗口 S[start: end + 1] 是覆盖了所有字母的子串，尝试 start 自增以缩小窗口；</li>
<li>在 start 加一之前，需要同时把 d[S[start]] 加一。如果 d[S[start]] 大于等于 0，还要同时把 missing 加一；</li>
<li>当 start 自增到 S[start: end + 1] 不是覆盖子串时，记录下 S[start - 1: end + 1] 作为结果。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minWindow</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
        <span class="n">missing</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">Counter</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span> <span class="c1"># 记录当前字母</span>
                <span class="n">missing</span> <span class="o">-=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">S</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="n">S</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 目前窗口包含了所有字母，左指针往右移</span>
                <span class="k">while</span> <span class="n">missing</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                        <span class="n">missing</span> <span class="o">+=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># 记录结果</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><p>虽然是通过了，但这个方法一定可以找到最小覆盖子串吗？这就需要证明 start 能到达最小覆盖子串的开头字母，且在此之前 end 没有达到最小覆盖子串的结束字母之后。后者是显然的，因为最小覆盖子串已经涵盖了所有字母，由遍历的过程，不可能在 start 到达开头之前 end 已经跳过了结尾。至于前者，想了半小时才想明白😂</p>
<p>因为 start 是一个一个元素遍历的，只需要证明 start 必然会停在最小子串的开头即可。如果在 start 还没到达开头之前，end 已经到达结尾，则已经符合要求；如果 end 没有到达结尾，比如刚好是倒数第 2 个元素，则 start 处的值一定和最小子串最后一个元素的值相等，显然下一次移动就能达到要求；同理，倒数第 n 个元素最多只需要再移动 n-1 次，一定会移动到最小子串的开头。</p>
<h2 id="bm91-反转字符串">BM91 反转字符串</h2>
<p>因为 Python 的字符串不可变，用不了双指针，可以理直气壮逃课😂</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div><h2 id="bm92-最长无重复子数组">BM92 最长无重复子数组</h2>
<p>和 BM90 很像，也是滑动窗口。如果 arr[start:end] 没有重复而 arr[start: end + 1] 出现了重复，也就是说 arr[end] 出现在 arr[start:end] 的某个位置 pos，显然下一个可能的最长无重复子数组的 start 一定是从 pos + 1 开始。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxLength</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{},</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span> <span class="c1"># 出现重复，到达下一个子串</span>
                <span class="k">while</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]:</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">])</span>
                    <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># 没有重复</span>
                <span class="n">d</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><h2 id="bm93-盛水最多的容器">BM93 盛水最多的容器</h2>
<p>笨办法自然是穷举所有可能，然后很快意识到并不需要，如果 height[start] &lt; height[end]，end 再怎么变化，盛水的量也不会变多，于是只需要把较小的一边前往下一个可能的值即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxArea</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">end</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">[</span><span class="n">end</span><span class="p">]:</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><h2 id="bm94-接雨水问题">BM94 接雨水问题</h2>
<h3 id="方法一正反遍历">方法一：正反遍历</h3>
<p>这题如果直接做可能无从下手，好在做过 BM93 之后，多多少少会有头绪：如果一个位置 i 要储水，一定要比水桶的两边都要低。怎么找到水桶的两边呢？</p>
<p>再仔细想想就会明白，水桶的左边是 i 左边的最大值，水桶的右边是 i 右边的最大值，于是可以使用一个两重循环来解决。然后很快就会发现，i 左边的最大值和 i 右边的最大值都可以通过一次遍历得到，于是时间复杂度就降到了 O(n)：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxWater</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">left_max</span><span class="p">,</span> <span class="n">right_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">left_max</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">right_max</span><span class="p">[</span><span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">right_max</span><span class="p">[</span><span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span> <span class="c1"># 其实第一位和最后一位都接不了雨水</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">left_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">right_max</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span> <span class="c1"># 接雨水</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">right_max</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><h3 id="方法二双指针">方法二：双指针</h3>
<p>和 BM93 的双指针法很相似，首先把 start, end 指向数组的两端，并准备 left_max, right_max 两个数组（其实只需要两个数）：</p>
<ol>
<li>如果 left_max[start] &lt; right_max[end]，因为 right_max[end] &lt;= right_max[start]，显然此时对 start 而言，左边是最小的一边，计算出雨水量的大小，然后 start 往右移；</li>
<li>如果 left_max[start] &gt;= right_max[end]，因为 left_max[end] &gt;= left_max[start]，显然此时对 end 而言，右边是最小的一边，计算出雨水量的大小，然后 end 往左移；</li>
<li>当 start &gt; end 时终止循环，返回结果。</li>
</ol>
<p>算法的正确性时显然的，因为每次循环恰好算出一个位置的雨水量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxWater</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">left_max</span><span class="p">,</span> <span class="n">right_max</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">left_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_max</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">])</span>
            <span class="n">right_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">right_max</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">left_max</span> <span class="o">&lt;</span> <span class="n">right_max</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">left_max</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">right_max</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><h3 id="方法三单调栈">方法三：单调栈</h3>
<p>这个算法仿佛是为这道题目量身定制的，但是压根想不出来：</p>
<ol>
<li>使用一个单调栈存储元素的索引；</li>
<li>如果元素的大小小于等于栈顶元素的大小，入栈；</li>
<li>如果元素的大小大于栈顶元素的大小，出栈，直到元素的大小小于等于栈顶元素的大小为止（或者栈为空）；</li>
<li>每出栈一个（非栈底）元素，算一次雨水的宽度（i 和剩下的栈顶元素的间隔）和高度（i 和剩下栈顶元素的最小值，减去出栈元素的值），累加起来就是结果。</li>
</ol>
<p><a class="link" href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/"  target="_blank" rel="noopener"
    >官方题解</a> 更详细，不过既然有更好的解法了，看不懂也没什么关系😂</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxWater</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">stack</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span> <span class="c1"># 入栈</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># 出栈，算雨水</span>
                <span class="k">while</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span> <span class="c1"># 栈底元素，跳过</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">left</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 剩下的栈顶元素</span>
                        <span class="n">width</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">height</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">top</span><span class="p">]</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><h2 id="bm95-分糖果问题">BM95 分糖果问题</h2>
<p>看了题解好久还是没看懂……如果面试遇到这道题就只能😭</p>
<h3 id="方法一直接法">方法一：直接法</h3>
<ol>
<li>从左到右遍历数组；</li>
<li>如果 arr[i] &gt; arr[i - 1]，就分 pre + 1 颗糖，上升计数+1；</li>
<li>如果 arr[i] == arr[i - 1]，只需要分 1 颗糖，重新开始；</li>
<li>如果 arr[i] &lt; arr[i - 1]，只需要分 1 颗糖，并且把前面连续递减的数字都 +1。</li>
</ol>
<p>前面 3 步都很容易理解，唯独第 4 步不容易理解也不好写，<a class="link" href="https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/"  target="_blank" rel="noopener"
    >题解</a> 的做法是用 increase 记录前面的上升次数（即峰值），如果遇到连续递减的数字个数 decrease 恰好与峰值的数字相同（比如峰值为 5，前面又有 4 个递减的数 4,3,2,1，此时 decrease = 4，这时又遇到一个递减的数），就把峰值也纳入递减序列中，即给 decrease 再 +1。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">candy</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span> <span class="ow">or</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">increase</span><span class="p">,</span> <span class="n">decrease</span><span class="p">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">pre</span>
            <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">pre</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">pre</span>
                <span class="n">decrease</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">increase</span> <span class="o">=</span> <span class="n">pre</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">decrease</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">decrease</span> <span class="o">==</span> <span class="n">increase</span><span class="p">:</span>
                    <span class="n">decrease</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">decrease</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><h3 id="方法二贪心法">方法二：贪心法</h3>
<p>贪心法更容易理解与实现：</p>
<ol>
<li>正向遍历，如果 arr[i] &gt; arr[i - 1]，则 left[i] = left[i - 1] + 1，否则 left[i] = 1；</li>
<li>反向遍历，如果 arr[i] &gt; arr[i + 1]，则 right[i] = right[i + 1] + 1，否则 right[i] = 1；</li>
<li>联立起来求最大值，即 result[i] = max(left[i], right[i])，再返回 result 数组的和。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">candy</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">right</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>
</code></pre></div><p>但是贪心法为什么是正确的呢？因为正向遍历和反向遍历，计算出来的都是满足题目要求的最小值的一个下界，即 result[i] &gt;= max(left[i], right[i])，只需要验证 max(left[i], right[i]) 确实是符合题目要求的一个解。</p>
<p>假设 A,B 是数组中相邻的两个数的下标，且 arr[A] &gt; arr[B]，如果 A &gt; B，则 left[A] &gt; left[B] &gt;= 1, right[A] &gt;= right[B] = 1，故 max(left[A], right[A]) &gt;= left[A] &gt; max(left[B], right[B]) = left[B]。由对称性，B &gt; A 时也成立。当 arr[A] == arr[B] 时，也显然是题目的解（因为题目没作要求），因此 max(left[i], right[i]) 确实是符合要求的解。故确实为最小值。</p>
<h2 id="bm96-主持人调度二">BM96 主持人调度（二）</h2>
<p>一开始想到 <a class="link" href="https://en.wikipedia.org/wiki/Interval_scheduling"  target="_blank" rel="noopener"
    >区间调度问题</a> 去了，把简单的问题复杂化了……</p>
<p>其实就是模拟一个队列系统，活动到开始时间就进入队列，到结束时间就离开队列，记录队列中活动数量的最大值。可以直接遍历，也可以借助数据结构（如小顶堆）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minmumNumberOfHost</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">startEnd</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">heapq</span>
        <span class="n">startEnd</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">startEnd</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><p>也有更简单直观的方法：记录下所有开始时间和结束时间，并按时间前后排序，result 从 0 开始，遇到开始时间 +1，遇到结束时间 -1，最后返回 result 的最大值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minmumNumberOfHost</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">startEnd</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">startEnd</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">startEnd</span><span class="p">]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><p>BTW，无权重的区间调度问题（即选择数量最多的不重合区间）也是可以使用贪心算法得到最优解的。</p>
<h2 id="bm97-旋转数组">BM97 旋转数组</h2>
<p>这个问题的历史可能比 Unix 还要悠久😂</p>
<h3 id="方法一三次镜像">方法一：三次镜像</h3>
<p>把数组分成 [A B]，先翻转一次得到 [B' A']，再分别翻转过来，就得到了 [B A]，反过来也可以。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
        <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">end</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span>
</code></pre></div><p><img src="https://c4rla.github.io/roll/p/oj-07/vector-rotation-reversal.jpg"
	width="1007"
	height="423"
	
	loading="lazy"
	
		alt="先翻转左手，再翻转右手，最后两只手一起翻转！"
	
	
		class="gallery-image" 
		data-flex-grow="238"
		data-flex-basis="571px"
	
></p>
<p>这一算法有诸多优点：容易理解与实现，空间和时间都很高效，代码简短难以出错。Ken Thompson 在 1971 年开发 ed 文本编辑器时使用了这一算法，并主张把它作为一种编程常识。</p>
<h3 id="方法二循环移位">方法二：循环移位</h3>
<p>注意到移位后的坐标，0-&gt;m, 1-&gt;m+1,...,n-1-&gt;m-1，恰好是每个坐标加上 m（再对 n 求余），只要找到一条遍历的路径就好。</p>
<p><img src="https://c4rla.github.io/roll/p/oj-07/vector-rotation-juggling.jpg"
	width="800"
	height="258"
	
	loading="lazy"
	
		alt="Jon Bentley 称之为“精巧的杂技”。"
	
	
		class="gallery-image" 
		data-flex-grow="310"
		data-flex-basis="744px"
	
></p>
<p>使用一点循环群的知识，如果 m,n 互素，0-&gt;m-&gt;2m-&gt;...-&gt;(n-1)m-&gt;0 (mod n) 可以遍历数组的所有数。如果 m 和 n 最大公约数为 g &gt; 1，需要分别以 range(g) 为开头遍历才能完成。想法虽然简单，要写出代码并不容易……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">gcd</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span> 
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">start</span> <span class="o">!=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[(</span><span class="n">start</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span> <span class="c1"># 题意要反过来</span>
                <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">arr</span>
</code></pre></div><p>理论上，这个算法似乎是最快的，因为只是遍历所有数一次进行了移位，操作数量应该是最少的。然而现实中，随着 m,n 的增大，<a class="link" href="https://web.archive.org/web/20030902103955/http://www.cs.bell-labs.com/cm/cs/pearls/s02b.pdf"  target="_blank" rel="noopener"
    >算法的速度并不让人满意</a>。Jon Bentley 猜测，这个算法不能很好地利用高速缓存，还会影响系统页面的性能。</p>
<h3 id="方法三块交换">方法三：块交换</h3>
<p><del>其实逃课才是正常想法吧！</del></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
        <span class="n">arr</span><span class="p">[:</span><span class="n">m</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">m</span><span class="p">:]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="n">m</span><span class="p">:],</span> <span class="n">arr</span><span class="p">[:</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">arr</span>
</code></pre></div><p>但是题目不允许使用额外的空间进行交换，有什么方法呢？不妨假设 [A B] -&gt; [B A]：</p>
<ul>
<li>如果 A 和 B 等长，直接 swap(A, B) 即可；</li>
<li>如果 A 比 B 长，则分成 [A1 A2 B] 再 swap(A1, B) -&gt;[B A2 A1]，转化成了交换 A2 和 A1 的子问题；</li>
<li>如果 A 比 B 短，同样分成 [A B1 B2] 再 swap(A, B2) -&gt; [B2 B1 A]，转化成了交换 B2 与 B1 的子问题。</li>
</ul>
<p>可以看到这一流程等价于求最大公约数的更相减损术，故一定会终止。可以使用递归，也可以使用迭代（Gries &amp; Mills）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span> <span class="c1"># arr[a,...,a+m-1] &lt;-&gt; arr[b,...,b+m-1]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span> <span class="c1"># 把前面 n-m 个元素移到后面</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span> <span class="c1"># p - 分界点，i - 左边长度，j - 右边长度</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span> <span class="c1"># 左边比右边长 [A1 A2 B] -&gt; [B A2 A1]</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="n">j</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># 右边比左边长 [A B1 B2] -&gt; [B2 B1 A]</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="n">i</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span>
</code></pre></div><p>这是实际测试中最快的算法（可能因为能利用高速缓存），不过写起来复杂容易出错。</p>
<p>扩展阅读：《编程珠玑》by Jon Bentley</p>
<h2 id="bm98-螺旋矩阵">BM98 螺旋矩阵</h2>
<p>挺普通的一道题……模拟 4 个边界，撞到边界之后更新边界的值和前进方向，难点是确定终止条件。</p>
<p>这里为了简便使用了复数记录矩阵的坐标，(i,j) 表示矩阵第 i 行第 j 列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">spiralOrder</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">moves</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 右 下 左 上</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># 上 右 下 左</span>
        <span class="n">status</span><span class="p">,</span> <span class="n">cor</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cor</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cor</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># 仍然在边界范围内</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">cor</span><span class="o">.</span><span class="n">real</span><span class="p">)][</span><span class="nb">int</span><span class="p">(</span><span class="n">cor</span><span class="o">.</span><span class="n">imag</span><span class="p">)])</span>
                <span class="n">cor</span> <span class="o">+=</span> <span class="n">moves</span><span class="p">[</span><span class="n">status</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># 越界</span>
                <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># 终止条件</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#退一格，更新边界值，前进</span>
                    <span class="n">cor</span> <span class="o">-=</span> <span class="n">moves</span><span class="p">[</span><span class="n">status</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">status</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                        <span class="n">bounds</span><span class="p">[</span><span class="n">status</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bounds</span><span class="p">[</span><span class="n">status</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
                    <span class="n">cor</span> <span class="o">+=</span> <span class="n">moves</span><span class="p">[</span><span class="n">status</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><h2 id="bm99-顺时针旋转矩阵">BM99 顺时针旋转矩阵</h2>
<p><img src="https://c4rla.github.io/roll/p/oj-07/matrix-rotation.png"
	width="2132"
	height="996"
	
	loading="lazy"
	
		alt="Credit: 题解"
	
	
		class="gallery-image" 
		data-flex-grow="214"
		data-flex-basis="513px"
	
></p>
<p>和 BM97 类似，先转置后翻转：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rotateMatrix</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">mat</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1"># 转置矩阵</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1"># 翻转矩阵</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mat</span>
</code></pre></div><h2 id="bm100-设计lru缓存结构">BM100 设计LRU缓存结构</h2>
<p>想了很久都没有想明白怎么把哈希表和双向链表结合在一起还能做到 O(1)，一看源码，是使用哈希表存放 key 对应的双向链表结点的引用，这是怎么想出来的😭</p>
<ol>
<li>get 的流程：首先查询哈希表 d，如果找到 d[key]，访问 d[key] 的结点获取 val（哈希表，O(1)），并把 d[key] 的结点移到末尾（双向链表，O(1)）；</li>
<li>set 的流程：如果 key 存在，访问 d[key] 的结点修改 val（哈希表，O(1)），并把 d[key] 的结点移到末尾（双向链表，O(1)）；否则新增结点，如果容量不足，需要删掉双向链表头结点（双向链表，O(1)）并且同时删掉对应的 d[key] 记录（哈希表，O(1)），然后在双向链表末端插入结点（双向链表，O(1)），最后给 d[key] 写入结点的引用（哈希表，O(1)）。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span> <span class="c1"># 双向链表结点，存储 val</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="c1"># 为了能删除头结点</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">insert_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># 链表尾插入新结点</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">node</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
    
    <span class="k">def</span> <span class="nf">move_to_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># 把结点移到链表尾</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">node</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">:</span> <span class="c1"># 脱离</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pre</span><span class="p">,</span> <span class="n">nxt</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">pre</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
            <span class="n">pre</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">nxt</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">,</span> <span class="n">pre</span>
        <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_end</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">remove_head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># 删除头结点</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
        <span class="k">del</span> <span class="n">node</span>
        
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span>
            
    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">:</span> <span class="c1"># 更新值</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_head</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert_end</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</code></pre></div><p>Python 的 OrderedDict 就是 <a class="link" href="https://hg.python.org/cpython/file/2.7/Lib/collections.py#l38"  target="_blank" rel="noopener"
    >使用哈希表+双链表实现的</a>，OrderedDict 还提供了 <a class="link" href="https://docs.python.org/3/library/collections.html#collections.OrderedDict"  target="_blank" rel="noopener"
    >官方逃课教程</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
            
    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span> <span class="c1"># 更新值</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</code></pre></div><p>除此以外，LRU 也可以使用哈希表+平衡二叉树（小顶堆）实现，比如初始化一个时间计数器 time，每插入/更新一次元素就修改一次时间计数器，并作为元素的排序依据。为了维护有序性，每次插入和更新元素的时间复杂度就变成了 O(log n)。</p>
<p>不过 Python 没有内置平衡二叉树，小顶堆 heapq 是使用列表（数组）存储的，不能实现 O(log n) 删除或更新元素（<code>heapq.heapify</code> 是 O(n) 的，如果知道下标倒是 <a class="link" href="https://stackoverflow.com/questions/10162679/python-delete-element-from-heap"  target="_blank" rel="noopener"
    >可以</a>，但是下标会变），只能不太优雅地学 <a class="link" href="https://docs.python.org/zh-cn/3/library/heapq.html#priority-queue-implementation-notes"  target="_blank" rel="noopener"
    >优先队列的实现</a> 把元素设置为移除状态，更新数据后作为新元素重新插入。</p>
<p>如果只是把元素设置成移除状态（而不是真的移除），其实也可以把双向链表换成双端队列，也可以学 LFU 使用哈希表（key 为 time）代替双向链表，需要额外维护一个 min_time 状态，不过因为 time 的跳跃增长，效率会有所下降。</p>
<h2 id="bm101-设计lfu缓存结构">BM101 设计LFU缓存结构</h2>
<p>和 LRU 类似，只是要比较的对象从“最近访问时间”变成 (访问频率，最近访问时间) 的二元组。Python 可以直接比较元组/列表的大小：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="kc">True</span>
</code></pre></div><p>因此可以把双向链表换成小顶堆/平衡二叉树来实现，不过满足不了时间复杂度 O(1) 的要求。</p>
<p>另一种做法是综合利用前面的三点经验：</p>
<ul>
<li>使用哈希表的值存放目标对象的引用，可以在不降低时间复杂度的情况下进行扩展；</li>
<li>使用一个 min_key 状态和哈希表，可以实现 O(1) 时间复杂度下可更新 key 数值的队列；</li>
<li>使用双向链表同样可以实现 O(1) 时间复杂度的队列，但不能随意更新 key 的数值。</li>
</ul>
<p>于是可设计为：</p>
<ul>
<li>依然是使用总哈希表存放值结点的引用；</li>
<li>因为使用频率 freq 每次更新是 +1 的，可以使用 min_freq 状态和另一个 freq 哈希表存放频率和值结点所在的数据结构；</li>
<li>最后，因为最近访问时间 time 每次更新都是移到结尾，可以使用双向链表来存储结点，这样就不需要存储访问时间的值了。</li>
</ul>
<p>具体而言：</p>
<ul>
<li>使用双向链表的结点存放对应的值（以及访问频率 freq）；</li>
<li>每个结点所在的双向链表，存放相同访问频率 freq 的结点，双向链表的引用作为 freq 哈希表中访问频率对应的值；</li>
<li>调用 set 时，首先通过总哈希表检查元素是否存在（哈希表，O(1)）：</li>
<li>
<ul>
<li>如果存在，访问结点修改对应的值（O(1)），同时得到当前访问频率 freq；</li>
</ul>
</li>
<li>
<ul>
<li>使用 freq 哈希表，找到结点所在的双向链表（O(1)），从双向链表中移除结点（O(1)）；</li>
</ul>
</li>
<li>
<ul>
<li>更新结点的访问频率 freq，并插入对应频率在哈希表中对应的双向链表末端（O(1)），此时可能需要更新 min_freq 的值；</li>
</ul>
</li>
<li>
<ul>
<li>如果不存在，首先检查可用容量 capacity 是否大于 0，如果大于 0，新建这个结点，并插入到访问频率为 0 的双向链表末端，最后在总哈希表中填入引用；</li>
</ul>
</li>
<li>
<ul>
<li>如果小于 0，检查 min_freq 的值，在访问频率为 min_freq 的双向链表中移除头部的值再插入；</li>
</ul>
</li>
<li>
<ul>
<li>写入新结点完成后，重新把 min_freq 的值设为 0。</li>
</ul>
</li>
<li>调用 get 时和 set 类似，如果存在，更新频率后返回值；如果不存在，返回 -1。</li>
</ul>
<p>很精巧的设计！就算看懂了，要写起来也并不容易。怎么表示双向链表呢？怎么检查双向链表是否为空呢（此时 min_freq += 1）？写着写着，一个晚上就没了😭</p>
<p>最后还是磕磕碰碰照着题解写了 100 行……<del>如果面试遇到这道题，快跑！</del></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span> <span class="c1"># 双向链表结点，存储 key, val, freq</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>
    
<span class="k">class</span> <span class="nc">DLL</span><span class="p">:</span> <span class="c1"># 定义双链表</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">def</span> <span class="nf">insert_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># 插入尾结点</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">node</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
    
    <span class="k">def</span> <span class="nf">remove_head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># 删除头结点</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># node == self.tail</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
            <span class="k">return</span> <span class="n">node</span>
    
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># 移除特定结点</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_head</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">node</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">pre</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">pre</span>
    
    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># 判断是否为空</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">==</span> <span class="kc">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_cache</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">DLL</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span> <span class="c1"># 更新结点，访问频率+1</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_cache</span><span class="p">[</span><span class="n">freq</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_cache</span><span class="p">[</span><span class="n">freq</span><span class="p">]:</span> <span class="c1"># 双向链表为空</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">freq_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span> <span class="o">==</span> <span class="n">freq</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_cache</span><span class="p">[</span><span class="n">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">insert_end</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
                
    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 移除频率最低的缓存</span>
                <span class="n">old_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_cache</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">]</span><span class="o">.</span><span class="n">remove_head</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_cache</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">]:</span> <span class="c1"># 双向链表为空</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">freq_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">old_node</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">freq_cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">insert_end</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
        
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    
    <span class="k">def</span> <span class="nf">LFU</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">operators</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operators</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># set 操作</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># get 操作</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div><p>天啊，整整 100 行！调试调了一个小时！终于结束了😭</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="https://c4rla.github.io/roll/tags/oj/">OJ</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    <aside class="related-contents--wrapper">
    
    
</aside>

     
    
        
    <script
    src="https://giscus.app/client.js"
    data-repo="c4rla/roll"
    data-repo-id="R_kgDOHFDxiw"
    data-category="Announcements"
    data-category-id="DIC_kwDOHFDxi84COtuG"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin="anonymous"
    async
></script>
<script>
    function setGiscusTheme(theme) {
        let giscus = document.querySelector('iframe.giscus-frame');
        if (giscus) {
            giscus.contentWindow.postMessage(
                { 
                    giscus: {
                        setConfig: { 
                            theme: theme 
                        }
                    }
                },
                "https://giscus.app"
            );
        };
    };

    (function(){
        addEventListener('message', (e) => {
            if (event.origin !== 'https://giscus.app') return;
            handler()
        });
        window.addEventListener('onColorSchemeChange', handler);

        function handler() {
            if (document.documentElement.dataset.scheme === "light") {
                setGiscusTheme('light');
            } else {
                setGiscusTheme('dark_dimmed');
            };
        };
    }());
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2022 卷心菜
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.8.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#bm83-字符串变形">BM83 字符串变形</a></li>
    <li><a href="#bm84-最长公共前缀">BM84 最长公共前缀</a></li>
    <li><a href="#bm85-验证ip地址">BM85 验证IP地址</a></li>
    <li><a href="#bm86-大数加法">BM86 大数加法</a></li>
    <li><a href="#bm87-合并两个有序的数组">BM87 合并两个有序的数组</a></li>
    <li><a href="#bm88-判断是否为回文字符串">BM88 判断是否为回文字符串</a></li>
    <li><a href="#bm89-合并区间">BM89 合并区间</a></li>
    <li><a href="#bm90-最小覆盖子串">BM90 最小覆盖子串</a></li>
    <li><a href="#bm91-反转字符串">BM91 反转字符串</a></li>
    <li><a href="#bm92-最长无重复子数组">BM92 最长无重复子数组</a></li>
    <li><a href="#bm93-盛水最多的容器">BM93 盛水最多的容器</a></li>
    <li><a href="#bm94-接雨水问题">BM94 接雨水问题</a>
      <ol>
        <li><a href="#方法一正反遍历">方法一：正反遍历</a></li>
        <li><a href="#方法二双指针">方法二：双指针</a></li>
        <li><a href="#方法三单调栈">方法三：单调栈</a></li>
      </ol>
    </li>
    <li><a href="#bm95-分糖果问题">BM95 分糖果问题</a>
      <ol>
        <li><a href="#方法一直接法">方法一：直接法</a></li>
        <li><a href="#方法二贪心法">方法二：贪心法</a></li>
      </ol>
    </li>
    <li><a href="#bm96-主持人调度二">BM96 主持人调度（二）</a></li>
    <li><a href="#bm97-旋转数组">BM97 旋转数组</a>
      <ol>
        <li><a href="#方法一三次镜像">方法一：三次镜像</a></li>
        <li><a href="#方法二循环移位">方法二：循环移位</a></li>
        <li><a href="#方法三块交换">方法三：块交换</a></li>
      </ol>
    </li>
    <li><a href="#bm98-螺旋矩阵">BM98 螺旋矩阵</a></li>
    <li><a href="#bm99-顺时针旋转矩阵">BM99 顺时针旋转矩阵</a></li>
    <li><a href="#bm100-设计lru缓存结构">BM100 设计LRU缓存结构</a></li>
    <li><a href="#bm101-设计lfu缓存结构">BM101 设计LFU缓存结构</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="https://c4rla.github.io/roll/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
