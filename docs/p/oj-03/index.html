<!DOCTYPE html>
<html lang="zh-CN">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='讨厌递归！'><title>做题笔记03：二叉树</title>

<link rel='canonical' href='https://c4rla.github.io/roll/p/oj-03/'>

<link rel="stylesheet" href="https://c4rla.github.io/roll/scss/style.min.b949db8bead9abdc40291b93383b8da6abc3aa62e74f5580356c06ddbb792dab.css"><meta property='og:title' content='做题笔记03：二叉树'>
<meta property='og:description' content='讨厌递归！'>
<meta property='og:url' content='https://c4rla.github.io/roll/p/oj-03/'>
<meta property='og:site_name' content='卷心菜'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='OJ' /><meta property='article:published_time' content='2022-04-03T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2022-04-03T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="做题笔记03：二叉树">
<meta name="twitter:description" content="讨厌递归！">
    <link rel="shortcut icon" href="https://c4rla.github.io/roll/img/favicon.png" />
<style type="text/css">
    .site-info {text-align: center;}
    .site-info > figure.site-avatar {margin: 0 auto var(--sidebar-element-separation);}
     
     
    @media (min-width: 768px) {.container .left-sidebar {width: 100%;}}
    blockquote.quote {position: relative; margin: 1.5em -10em 0 -10; padding-left: 18%; padding-right: 15%; border: none; background-color: transparent}
    blockquote.quote::before {position: absolute; left: 7%; content: '“'; color: var(--color-contrast-low); font-family: serif; font-size: 3em; font-weight: 700; line-height: 1}
    blockquote cite {display: block; text-align: right;}
    .article-content>p:not(.no-text) {overflow-x: auto; overflow-y: hidden;}
</style>
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://c4rla.github.io/roll/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <h2 class="article-title">
        <a href="https://c4rla.github.io/roll/p/oj-03/">做题笔记03：二叉树</a>
    </h2>

    
    <h3 class="article-subtitle">
        讨厌递归！
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2022年4月3日</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 6 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    
    
    <h2 id="bm23-二叉树的前序遍历">BM23 二叉树的前序遍历</h2>
<p>继续记模板！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preOrder</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
        
    <span class="k">def</span> <span class="nf">preOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preOrder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</code></pre></div><h2 id="bm24-二叉树的中序遍历">BM24 二叉树的中序遍历</h2>
<p>直接使用递归超出系统限制了，虽然可以使用作弊器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
</code></pre></div><p>但还是学习一下非递归的写法吧：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inOrder</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    
    <span class="k">def</span> <span class="nf">preOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span> <span class="c1"># 前序，“根左右”</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">top</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="c1"># 优先加入右结点，因为是栈，左结点会先出来</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">top</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span> <span class="c1"># 中序，“左根右”</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span> <span class="c1"># 左</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c1"># root 是当前访问的结点</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 根</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="c1"># 右</span>
            <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
</code></pre></div><h2 id="bm25-二叉树的后序遍历">BM25 二叉树的后序遍历</h2>
<p>后序的非递归版本并不好写，最简单的做法似乎是把前序遍历反转一下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postOrder</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">postOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span> <span class="c1"># 后序1，前序“根右左”，反转在上面</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">top</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">top</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">postOrder2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span> <span class="c1"># 后序2，“左右根”</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 根</span>
            <span class="k">if</span> <span class="n">top</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="c1"># 标记此结点已经访问过</span>
                <span class="k">if</span> <span class="n">top</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="c1"># 右</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">top</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="c1"># 左</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</code></pre></div><h2 id="bm26-求二叉树的层序遍历">BM26 求二叉树的层序遍历</h2>
<p>相对简单，使用队列一层一层扫描即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">queue</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><p>比较有趣的是递归的写法，然而直接 Stack Overflow……</p>
<h2 id="bm27-按之字形顺序打印二叉树">BM27 按之字形顺序打印二叉树</h2>
<p>层序遍历+判断正负，也很简单。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Print</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">tik</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">]),</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tik</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tik</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tik</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div><h2 id="bm28-二叉树的最大深度">BM28 二叉树的最大深度</h2>
<p>依然是层序遍历。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        <span class="n">queue</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">]),</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">depth</span>
</code></pre></div><h2 id="bm29-二叉树中和为某一值的路径一">BM29 二叉树中和为某一值的路径(一)</h2>
<p>本来以为很简单，但写起来意外不顺手，最后还是基于后序遍历的代码修改。只要再加一个栈，就可以获得完整的路径。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasPathSum</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">sumup</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">stack</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">==</span> <span class="n">sumup</span><span class="p">:</span> <span class="c1"># 叶子结点</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">-=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div><h2 id="bm30-二叉搜索树与双向链表">BM30 二叉搜索树与双向链表</h2>
<p>中序遍历，二叉树的题目写起来意外棘手……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Convert</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span> <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">stack</span><span class="p">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">None</span> <span class="c1"># 使用两个指针记录状态</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span> <span class="c1"># 左</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c1"># root 是当前访问的结点</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 根</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="c1"># 右</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">pre</span>
            <span class="k">if</span> <span class="n">pre</span><span class="p">:</span>
                <span class="n">pre</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="k">return</span> <span class="n">head</span>
</code></pre></div><h2 id="bm31-对称的二叉树">BM31 对称的二叉树</h2>
<p>仔细想想，好像任何一种遍历方式都可以，只要把左右颠倒过来遍历，再比较即可。</p>
<p>这里使用层序遍历，不过要注意，元素为空也是一种需要比较的状态……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetrical</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">queue_left</span><span class="p">,</span> <span class="n">queue_right</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">queue_left</span> <span class="ow">and</span> <span class="n">queue_right</span><span class="p">:</span>
            <span class="n">node_left</span> <span class="o">=</span> <span class="n">queue_left</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">node_right</span> <span class="o">=</span> <span class="n">queue_right</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node_left</span> <span class="ow">and</span> <span class="n">node_right</span><span class="p">:</span> <span class="c1"># 同时存在</span>
                <span class="k">if</span> <span class="n">node_left</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">node_right</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">queue_left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_left</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># 空状态也要记录</span>
                    <span class="n">queue_left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_left</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                    <span class="n">queue_right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_right</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                    <span class="n">queue_right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_right</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node_left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node_right</span><span class="p">):</span> <span class="c1"># 同时为空</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="n">queue_left</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">queue_right</span><span class="p">)</span>
</code></pre></div><h2 id="bm32-合并二叉树">BM32 合并二叉树</h2>
<p>同样是任何一种遍历方式都可以，依然是层序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">t1</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">t2</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">t1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">t2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t1</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">t2</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">,</span> <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">t1</span><span class="p">],</span> <span class="p">[</span><span class="n">t2</span><span class="p">],</span> <span class="p">[</span><span class="n">head</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">queue1</span> <span class="ow">and</span> <span class="n">queue2</span><span class="p">:</span>
            <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue1</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">queue2</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node1</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">node2</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">node2</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">queue1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">queue2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node2</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node1</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node1</span><span class="o">.</span><span class="n">left</span>
            <span class="k">elif</span> <span class="n">node2</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node2</span><span class="o">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="n">node1</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node2</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">node2</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">queue1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">queue2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node2</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node1</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node1</span><span class="o">.</span><span class="n">right</span>
            <span class="k">elif</span> <span class="n">node2</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node2</span><span class="o">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">head</span>
</code></pre></div><h2 id="bm33-二叉树的镜像">BM33 二叉树的镜像</h2>
<p>爱上了层序……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Mirror</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="c1"># 原地镜像</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div><h2 id="bm34-判断是不是二叉搜索树">BM34 判断是不是二叉搜索树</h2>
<p>又是中序遍历……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">stack</span><span class="p">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="p">[],</span> <span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">pre</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>
            <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div><h2 id="bm35-判断是不是完全二叉树">BM35 判断是不是完全二叉树</h2>
<p>又是层序遍历。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isCompleteTree</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        <span class="n">queue</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">]),</span> <span class="kc">False</span> <span class="c1"># 标记是否出现叶子结点</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">flag</span><span class="p">:</span> <span class="c1"># 之前有空结点</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># 出现空结点</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="c1"># 遍历完成，没有中途退出，是完全二叉树</span>
</code></pre></div><h2 id="bm36-判断是不是平衡二叉树">BM36 判断是不是平衡二叉树</h2>
<p>美好的一天从一道“简单”题开始😭</p>
<h3 id="方法一递归credit官方解答">方法一：递归（Credit：官方解答）</h3>
<p>其实就是要写一个递归计算二叉树深度的函数，发现不平衡立刻返回 False：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">IsBalanced_Solution</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="c1"># 能求出高度就是平衡二叉树</span>
    
    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="c1"># 空结点，高度自然是 0</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leftHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">rightHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">leftHeight</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">rightHeight</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">leftHeight</span> <span class="o">-</span> <span class="n">rightHeight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">leftHeight</span><span class="p">,</span> <span class="n">rightHeight</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div><h3 id="方法二后序遍历">方法二：后序遍历</h3>
<p>类似 BM29，使用一个字典存储每个结点的深度：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">IsBalanced_Solution</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">stack</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">root</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="c1"># 不小心写反了！</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">]</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">height</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div><h2 id="bm37-二叉搜索树的最近公共祖先">BM37 二叉搜索树的最近公共祖先</h2>
<p>偷懒了，怎么简单怎么写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
            <span class="k">elif</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>
</code></pre></div><h2 id="bm38-在二叉树中找到两个节点的最近公共祖先">BM38 在二叉树中找到两个节点的最近公共祖先</h2>
<p>就很朴素：</p>
<ol>
<li>后序遍历二叉树，找到前往两个结点的路径；</li>
<li>按顺序逐个比较路径中的每个结点，找到最后一个相同的并返回。</li>
</ol>
<p>奇怪的是，如果用数组保存 TreeNode 的话，在比较相等的时候会出问题……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">o1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">o2</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">commonprefix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">stack</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">path1</span><span class="p">,</span> <span class="n">path2</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
                <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">o1</span><span class="p">:</span>
                    <span class="n">path1</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># 浅复制</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">o2</span><span class="p">:</span>
                    <span class="n">path2</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">commonprefix</span><span class="p">([</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div><h2 id="bm39-序列化二叉树">BM39 序列化二叉树</h2>
<p>标准答案是按前序和中序遍历做的，还是喜欢层序（因为官方使用的就是层序），虽然不难，但是很长……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">queue</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&#34;,&#34;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&#34;{&#34;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="s2">&#34;,#&#34;</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="s2">&#34;}&#34;</span>
            
    <span class="k">def</span> <span class="nf">Deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&#34;</span><span class="si">{}</span><span class="s2">&#34;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">head</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span> <span class="c1"># 编号为 N 的结点子结点编号为 2N, 2N+1，对应的数组坐标为 N-1</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                        <span class="n">head</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">!=</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                        <span class="n">head</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># 到达最底层</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># 空结点</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div><h2 id="bm40-重建二叉树">BM40 重建二叉树</h2>
<p>明明这题更难一点😭题解的做法是递归：</p>
<ol>
<li>找到前序遍历的第一个结点，即为根结点；</li>
<li>找到中序遍历中根结点所在的位置，根结点左边的结点即为左子树，右边的结点即为右子树；</li>
<li>同样对前序遍历的结点进行左右子树的切分，递归做下去即可。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reConstructBinaryTree</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">pre</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">vin</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">vin</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">root_index</span> <span class="o">=</span> <span class="n">vin</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">root_index</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">vin</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">root_index</span><span class="p">])</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">root_index</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">vin</span><span class="p">[</span><span class="n">root_index</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div><p>如果不使用递归，考虑使用栈作为辅助存储：</p>
<ol>
<li>从前序遍历读取第一个结点，栈为空，新建结点后放入栈中；</li>
<li>从前序遍历中读取下一个结点，计算中序索引，并与栈中的结点在中序中的索引大小进行比较；</li>
<li>如果小于栈最后一个结点的索引，说明是栈最后一个结点的左子结点，入栈；</li>
<li>如果大于栈最后一个结点的索引，说明这个结点一定是栈中某个元素的右结点，以反方向遍历栈，找到栈中中序索引比结点索引小且距离最小的第一个结点，就是所求的祖先。</li>
</ol>
<p>终于写出来了，然而效率并不如递归……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reConstructBinaryTree</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">pre</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">vin</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">vin</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">stack</span><span class="p">,</span> <span class="n">vin_index</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">dict</span><span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vin</span><span class="p">)),</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">pre</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span> <span class="c1"># 刚开始 栈为空</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># 栈不为空，开始比较结点</span>
                <span class="k">while</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span> <span class="c1"># 结点未入栈</span>
                    <span class="k">if</span> <span class="n">vin_index</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vin_index</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">]:</span> <span class="c1"># 小于最后一个结点，为左子结点</span>
                        <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1"># 是某个祖先的右结点</span>
                        <span class="n">closest_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 中序遍历栈中离结点最近的左边结点坐标</span>
                        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">vin_index</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vin_index</span><span class="p">[</span><span class="n">val</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">vin_index</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">closest_index</span><span class="p">:</span>
                                    <span class="n">closest_index</span> <span class="o">=</span> <span class="n">vin_index</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
                                    <span class="k">if</span> <span class="n">closest_index</span> <span class="o">==</span> <span class="n">vin_index</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                                        <span class="k">break</span>
                                <span class="k">else</span><span class="p">:</span> <span class="c1"># 似乎可以再优化一下……</span>
                                    <span class="k">pass</span>
                            <span class="k">else</span><span class="p">:</span> <span class="c1"># 遇到右边的结点，停止</span>
                                <span class="k">break</span>
                        <span class="k">while</span> <span class="n">vin_index</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">!=</span> <span class="n">closest_index</span><span class="p">:</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">tmp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div><h2 id="bm41-输出二叉树的右视图">BM41 输出二叉树的右视图</h2>
<p>又是层序遍历！收工👏</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">pre</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">vin</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">vin</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        <span class="n">queue</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">tree</span><span class="p">]),</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="https://c4rla.github.io/roll/tags/oj/">OJ</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    <aside class="related-contents--wrapper">
    
    
</aside>

     
    
        
    <script
    src="https://giscus.app/client.js"
    data-repo="c4rla/roll"
    data-repo-id="R_kgDOHFDxiw"
    data-category="Announcements"
    data-category-id="DIC_kwDOHFDxi84COtuG"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin="anonymous"
    async
></script>
<script>
    function setGiscusTheme(theme) {
        let giscus = document.querySelector('iframe.giscus-frame');
        if (giscus) {
            giscus.contentWindow.postMessage(
                { 
                    giscus: {
                        setConfig: { 
                            theme: theme 
                        }
                    }
                },
                "https://giscus.app"
            );
        };
    };

    (function(){
        addEventListener('message', (e) => {
            if (event.origin !== 'https://giscus.app') return;
            handler()
        });
        window.addEventListener('onColorSchemeChange', handler);

        function handler() {
            if (document.documentElement.dataset.scheme === "light") {
                setGiscusTheme('light');
            } else {
                setGiscusTheme('dark_dimmed');
            };
        };
    }());
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2022 卷心菜
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.8.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#bm23-二叉树的前序遍历">BM23 二叉树的前序遍历</a></li>
    <li><a href="#bm24-二叉树的中序遍历">BM24 二叉树的中序遍历</a></li>
    <li><a href="#bm25-二叉树的后序遍历">BM25 二叉树的后序遍历</a></li>
    <li><a href="#bm26-求二叉树的层序遍历">BM26 求二叉树的层序遍历</a></li>
    <li><a href="#bm27-按之字形顺序打印二叉树">BM27 按之字形顺序打印二叉树</a></li>
    <li><a href="#bm28-二叉树的最大深度">BM28 二叉树的最大深度</a></li>
    <li><a href="#bm29-二叉树中和为某一值的路径一">BM29 二叉树中和为某一值的路径(一)</a></li>
    <li><a href="#bm30-二叉搜索树与双向链表">BM30 二叉搜索树与双向链表</a></li>
    <li><a href="#bm31-对称的二叉树">BM31 对称的二叉树</a></li>
    <li><a href="#bm32-合并二叉树">BM32 合并二叉树</a></li>
    <li><a href="#bm33-二叉树的镜像">BM33 二叉树的镜像</a></li>
    <li><a href="#bm34-判断是不是二叉搜索树">BM34 判断是不是二叉搜索树</a></li>
    <li><a href="#bm35-判断是不是完全二叉树">BM35 判断是不是完全二叉树</a></li>
    <li><a href="#bm36-判断是不是平衡二叉树">BM36 判断是不是平衡二叉树</a>
      <ol>
        <li><a href="#方法一递归credit官方解答">方法一：递归（Credit：官方解答）</a></li>
        <li><a href="#方法二后序遍历">方法二：后序遍历</a></li>
      </ol>
    </li>
    <li><a href="#bm37-二叉搜索树的最近公共祖先">BM37 二叉搜索树的最近公共祖先</a></li>
    <li><a href="#bm38-在二叉树中找到两个节点的最近公共祖先">BM38 在二叉树中找到两个节点的最近公共祖先</a></li>
    <li><a href="#bm39-序列化二叉树">BM39 序列化二叉树</a></li>
    <li><a href="#bm40-重建二叉树">BM40 重建二叉树</a></li>
    <li><a href="#bm41-输出二叉树的右视图">BM41 输出二叉树的右视图</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="https://c4rla.github.io/roll/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
